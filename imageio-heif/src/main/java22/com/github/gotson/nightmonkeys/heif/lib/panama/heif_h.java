// Generated by jextract

package com.github.gotson.nightmonkeys.heif.lib.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class heif_h {

    heif_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }


    static {
        System.loadLibrary("heif");
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __has_safe_buffers = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 0
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = heif_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = heif_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = heif_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = heif_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = heif_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = heif_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = heif_h.C_LONG;

    private static class heif_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_get_version()
     * }
     */
    public static FunctionDescriptor heif_get_version$descriptor() {
        return heif_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_get_version()
     * }
     */
    public static MethodHandle heif_get_version$handle() {
        return heif_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_get_version()
     * }
     */
    public static MemorySegment heif_get_version$address() {
        return heif_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_get_version()
     * }
     */
    public static MemorySegment heif_get_version() {
        var mh$ = heif_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_version_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_version_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t heif_get_version_number()
     * }
     */
    public static FunctionDescriptor heif_get_version_number$descriptor() {
        return heif_get_version_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t heif_get_version_number()
     * }
     */
    public static MethodHandle heif_get_version_number$handle() {
        return heif_get_version_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t heif_get_version_number()
     * }
     */
    public static MemorySegment heif_get_version_number$address() {
        return heif_get_version_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t heif_get_version_number()
     * }
     */
    public static int heif_get_version_number() {
        var mh$ = heif_get_version_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_version_number");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_version_number_major {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_version_number_major");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_get_version_number_major()
     * }
     */
    public static FunctionDescriptor heif_get_version_number_major$descriptor() {
        return heif_get_version_number_major.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_get_version_number_major()
     * }
     */
    public static MethodHandle heif_get_version_number_major$handle() {
        return heif_get_version_number_major.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_get_version_number_major()
     * }
     */
    public static MemorySegment heif_get_version_number_major$address() {
        return heif_get_version_number_major.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_get_version_number_major()
     * }
     */
    public static int heif_get_version_number_major() {
        var mh$ = heif_get_version_number_major.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_version_number_major");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_version_number_minor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_version_number_minor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_get_version_number_minor()
     * }
     */
    public static FunctionDescriptor heif_get_version_number_minor$descriptor() {
        return heif_get_version_number_minor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_get_version_number_minor()
     * }
     */
    public static MethodHandle heif_get_version_number_minor$handle() {
        return heif_get_version_number_minor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_get_version_number_minor()
     * }
     */
    public static MemorySegment heif_get_version_number_minor$address() {
        return heif_get_version_number_minor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_get_version_number_minor()
     * }
     */
    public static int heif_get_version_number_minor() {
        var mh$ = heif_get_version_number_minor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_version_number_minor");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_version_number_maintenance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_version_number_maintenance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_get_version_number_maintenance()
     * }
     */
    public static FunctionDescriptor heif_get_version_number_maintenance$descriptor() {
        return heif_get_version_number_maintenance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_get_version_number_maintenance()
     * }
     */
    public static MethodHandle heif_get_version_number_maintenance$handle() {
        return heif_get_version_number_maintenance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_get_version_number_maintenance()
     * }
     */
    public static MemorySegment heif_get_version_number_maintenance$address() {
        return heif_get_version_number_maintenance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_get_version_number_maintenance()
     * }
     */
    public static int heif_get_version_number_maintenance() {
        var mh$ = heif_get_version_number_maintenance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_version_number_maintenance");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_error_Ok = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Ok = 0
     * }
     */
    public static int heif_error_Ok() {
        return heif_error_Ok;
    }
    private static final int heif_error_Input_does_not_exist = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Input_does_not_exist = 1
     * }
     */
    public static int heif_error_Input_does_not_exist() {
        return heif_error_Input_does_not_exist;
    }
    private static final int heif_error_Invalid_input = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Invalid_input = 2
     * }
     */
    public static int heif_error_Invalid_input() {
        return heif_error_Invalid_input;
    }
    private static final int heif_error_Unsupported_filetype = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Unsupported_filetype = 3
     * }
     */
    public static int heif_error_Unsupported_filetype() {
        return heif_error_Unsupported_filetype;
    }
    private static final int heif_error_Unsupported_feature = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Unsupported_feature = 4
     * }
     */
    public static int heif_error_Unsupported_feature() {
        return heif_error_Unsupported_feature;
    }
    private static final int heif_error_Usage_error = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Usage_error = 5
     * }
     */
    public static int heif_error_Usage_error() {
        return heif_error_Usage_error;
    }
    private static final int heif_error_Memory_allocation_error = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Memory_allocation_error = 6
     * }
     */
    public static int heif_error_Memory_allocation_error() {
        return heif_error_Memory_allocation_error;
    }
    private static final int heif_error_Decoder_plugin_error = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Decoder_plugin_error = 7
     * }
     */
    public static int heif_error_Decoder_plugin_error() {
        return heif_error_Decoder_plugin_error;
    }
    private static final int heif_error_Encoder_plugin_error = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Encoder_plugin_error = 8
     * }
     */
    public static int heif_error_Encoder_plugin_error() {
        return heif_error_Encoder_plugin_error;
    }
    private static final int heif_error_Encoding_error = (int)9L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Encoding_error = 9
     * }
     */
    public static int heif_error_Encoding_error() {
        return heif_error_Encoding_error;
    }
    private static final int heif_error_Color_profile_does_not_exist = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Color_profile_does_not_exist = 10
     * }
     */
    public static int heif_error_Color_profile_does_not_exist() {
        return heif_error_Color_profile_does_not_exist;
    }
    private static final int heif_error_Plugin_loading_error = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_error_code.heif_error_Plugin_loading_error = 11
     * }
     */
    public static int heif_error_Plugin_loading_error() {
        return heif_error_Plugin_loading_error;
    }
    private static final int heif_suberror_Unspecified = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unspecified = 0
     * }
     */
    public static int heif_suberror_Unspecified() {
        return heif_suberror_Unspecified;
    }
    private static final int heif_suberror_End_of_data = (int)100L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_End_of_data = 100
     * }
     */
    public static int heif_suberror_End_of_data() {
        return heif_suberror_End_of_data;
    }
    private static final int heif_suberror_Invalid_box_size = (int)101L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_box_size = 101
     * }
     */
    public static int heif_suberror_Invalid_box_size() {
        return heif_suberror_Invalid_box_size;
    }
    private static final int heif_suberror_No_ftyp_box = (int)102L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_ftyp_box = 102
     * }
     */
    public static int heif_suberror_No_ftyp_box() {
        return heif_suberror_No_ftyp_box;
    }
    private static final int heif_suberror_No_idat_box = (int)103L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_idat_box = 103
     * }
     */
    public static int heif_suberror_No_idat_box() {
        return heif_suberror_No_idat_box;
    }
    private static final int heif_suberror_No_meta_box = (int)104L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_meta_box = 104
     * }
     */
    public static int heif_suberror_No_meta_box() {
        return heif_suberror_No_meta_box;
    }
    private static final int heif_suberror_No_hdlr_box = (int)105L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_hdlr_box = 105
     * }
     */
    public static int heif_suberror_No_hdlr_box() {
        return heif_suberror_No_hdlr_box;
    }
    private static final int heif_suberror_No_hvcC_box = (int)106L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_hvcC_box = 106
     * }
     */
    public static int heif_suberror_No_hvcC_box() {
        return heif_suberror_No_hvcC_box;
    }
    private static final int heif_suberror_No_pitm_box = (int)107L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_pitm_box = 107
     * }
     */
    public static int heif_suberror_No_pitm_box() {
        return heif_suberror_No_pitm_box;
    }
    private static final int heif_suberror_No_ipco_box = (int)108L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_ipco_box = 108
     * }
     */
    public static int heif_suberror_No_ipco_box() {
        return heif_suberror_No_ipco_box;
    }
    private static final int heif_suberror_No_ipma_box = (int)109L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_ipma_box = 109
     * }
     */
    public static int heif_suberror_No_ipma_box() {
        return heif_suberror_No_ipma_box;
    }
    private static final int heif_suberror_No_iloc_box = (int)110L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_iloc_box = 110
     * }
     */
    public static int heif_suberror_No_iloc_box() {
        return heif_suberror_No_iloc_box;
    }
    private static final int heif_suberror_No_iinf_box = (int)111L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_iinf_box = 111
     * }
     */
    public static int heif_suberror_No_iinf_box() {
        return heif_suberror_No_iinf_box;
    }
    private static final int heif_suberror_No_iprp_box = (int)112L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_iprp_box = 112
     * }
     */
    public static int heif_suberror_No_iprp_box() {
        return heif_suberror_No_iprp_box;
    }
    private static final int heif_suberror_No_iref_box = (int)113L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_iref_box = 113
     * }
     */
    public static int heif_suberror_No_iref_box() {
        return heif_suberror_No_iref_box;
    }
    private static final int heif_suberror_No_pict_handler = (int)114L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_pict_handler = 114
     * }
     */
    public static int heif_suberror_No_pict_handler() {
        return heif_suberror_No_pict_handler;
    }
    private static final int heif_suberror_Ipma_box_references_nonexisting_property = (int)115L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Ipma_box_references_nonexisting_property = 115
     * }
     */
    public static int heif_suberror_Ipma_box_references_nonexisting_property() {
        return heif_suberror_Ipma_box_references_nonexisting_property;
    }
    private static final int heif_suberror_No_properties_assigned_to_item = (int)116L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_properties_assigned_to_item = 116
     * }
     */
    public static int heif_suberror_No_properties_assigned_to_item() {
        return heif_suberror_No_properties_assigned_to_item;
    }
    private static final int heif_suberror_No_item_data = (int)117L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_item_data = 117
     * }
     */
    public static int heif_suberror_No_item_data() {
        return heif_suberror_No_item_data;
    }
    private static final int heif_suberror_Invalid_grid_data = (int)118L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_grid_data = 118
     * }
     */
    public static int heif_suberror_Invalid_grid_data() {
        return heif_suberror_Invalid_grid_data;
    }
    private static final int heif_suberror_Missing_grid_images = (int)119L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Missing_grid_images = 119
     * }
     */
    public static int heif_suberror_Missing_grid_images() {
        return heif_suberror_Missing_grid_images;
    }
    private static final int heif_suberror_Invalid_clean_aperture = (int)120L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_clean_aperture = 120
     * }
     */
    public static int heif_suberror_Invalid_clean_aperture() {
        return heif_suberror_Invalid_clean_aperture;
    }
    private static final int heif_suberror_Invalid_overlay_data = (int)121L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_overlay_data = 121
     * }
     */
    public static int heif_suberror_Invalid_overlay_data() {
        return heif_suberror_Invalid_overlay_data;
    }
    private static final int heif_suberror_Overlay_image_outside_of_canvas = (int)122L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Overlay_image_outside_of_canvas = 122
     * }
     */
    public static int heif_suberror_Overlay_image_outside_of_canvas() {
        return heif_suberror_Overlay_image_outside_of_canvas;
    }
    private static final int heif_suberror_Auxiliary_image_type_unspecified = (int)123L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Auxiliary_image_type_unspecified = 123
     * }
     */
    public static int heif_suberror_Auxiliary_image_type_unspecified() {
        return heif_suberror_Auxiliary_image_type_unspecified;
    }
    private static final int heif_suberror_No_or_invalid_primary_item = (int)124L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_or_invalid_primary_item = 124
     * }
     */
    public static int heif_suberror_No_or_invalid_primary_item() {
        return heif_suberror_No_or_invalid_primary_item;
    }
    private static final int heif_suberror_No_infe_box = (int)125L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_infe_box = 125
     * }
     */
    public static int heif_suberror_No_infe_box() {
        return heif_suberror_No_infe_box;
    }
    private static final int heif_suberror_Unknown_color_profile_type = (int)126L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unknown_color_profile_type = 126
     * }
     */
    public static int heif_suberror_Unknown_color_profile_type() {
        return heif_suberror_Unknown_color_profile_type;
    }
    private static final int heif_suberror_Wrong_tile_image_chroma_format = (int)127L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Wrong_tile_image_chroma_format = 127
     * }
     */
    public static int heif_suberror_Wrong_tile_image_chroma_format() {
        return heif_suberror_Wrong_tile_image_chroma_format;
    }
    private static final int heif_suberror_Invalid_fractional_number = (int)128L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_fractional_number = 128
     * }
     */
    public static int heif_suberror_Invalid_fractional_number() {
        return heif_suberror_Invalid_fractional_number;
    }
    private static final int heif_suberror_Invalid_image_size = (int)129L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_image_size = 129
     * }
     */
    public static int heif_suberror_Invalid_image_size() {
        return heif_suberror_Invalid_image_size;
    }
    private static final int heif_suberror_Invalid_pixi_box = (int)130L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_pixi_box = 130
     * }
     */
    public static int heif_suberror_Invalid_pixi_box() {
        return heif_suberror_Invalid_pixi_box;
    }
    private static final int heif_suberror_No_av1C_box = (int)131L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_No_av1C_box = 131
     * }
     */
    public static int heif_suberror_No_av1C_box() {
        return heif_suberror_No_av1C_box;
    }
    private static final int heif_suberror_Wrong_tile_image_pixel_depth = (int)132L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Wrong_tile_image_pixel_depth = 132
     * }
     */
    public static int heif_suberror_Wrong_tile_image_pixel_depth() {
        return heif_suberror_Wrong_tile_image_pixel_depth;
    }
    private static final int heif_suberror_Unknown_NCLX_color_primaries = (int)133L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unknown_NCLX_color_primaries = 133
     * }
     */
    public static int heif_suberror_Unknown_NCLX_color_primaries() {
        return heif_suberror_Unknown_NCLX_color_primaries;
    }
    private static final int heif_suberror_Unknown_NCLX_transfer_characteristics = (int)134L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unknown_NCLX_transfer_characteristics = 134
     * }
     */
    public static int heif_suberror_Unknown_NCLX_transfer_characteristics() {
        return heif_suberror_Unknown_NCLX_transfer_characteristics;
    }
    private static final int heif_suberror_Unknown_NCLX_matrix_coefficients = (int)135L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unknown_NCLX_matrix_coefficients = 135
     * }
     */
    public static int heif_suberror_Unknown_NCLX_matrix_coefficients() {
        return heif_suberror_Unknown_NCLX_matrix_coefficients;
    }
    private static final int heif_suberror_Invalid_region_data = (int)136L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_region_data = 136
     * }
     */
    public static int heif_suberror_Invalid_region_data() {
        return heif_suberror_Invalid_region_data;
    }
    private static final int heif_suberror_Security_limit_exceeded = (int)1000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Security_limit_exceeded = 1000
     * }
     */
    public static int heif_suberror_Security_limit_exceeded() {
        return heif_suberror_Security_limit_exceeded;
    }
    private static final int heif_suberror_Nonexisting_item_referenced = (int)2000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Nonexisting_item_referenced = 2000
     * }
     */
    public static int heif_suberror_Nonexisting_item_referenced() {
        return heif_suberror_Nonexisting_item_referenced;
    }
    private static final int heif_suberror_Null_pointer_argument = (int)2001L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Null_pointer_argument = 2001
     * }
     */
    public static int heif_suberror_Null_pointer_argument() {
        return heif_suberror_Null_pointer_argument;
    }
    private static final int heif_suberror_Nonexisting_image_channel_referenced = (int)2002L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Nonexisting_image_channel_referenced = 2002
     * }
     */
    public static int heif_suberror_Nonexisting_image_channel_referenced() {
        return heif_suberror_Nonexisting_image_channel_referenced;
    }
    private static final int heif_suberror_Unsupported_plugin_version = (int)2003L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_plugin_version = 2003
     * }
     */
    public static int heif_suberror_Unsupported_plugin_version() {
        return heif_suberror_Unsupported_plugin_version;
    }
    private static final int heif_suberror_Unsupported_writer_version = (int)2004L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_writer_version = 2004
     * }
     */
    public static int heif_suberror_Unsupported_writer_version() {
        return heif_suberror_Unsupported_writer_version;
    }
    private static final int heif_suberror_Unsupported_parameter = (int)2005L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_parameter = 2005
     * }
     */
    public static int heif_suberror_Unsupported_parameter() {
        return heif_suberror_Unsupported_parameter;
    }
    private static final int heif_suberror_Invalid_parameter_value = (int)2006L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_parameter_value = 2006
     * }
     */
    public static int heif_suberror_Invalid_parameter_value() {
        return heif_suberror_Invalid_parameter_value;
    }
    private static final int heif_suberror_Invalid_property = (int)2007L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Invalid_property = 2007
     * }
     */
    public static int heif_suberror_Invalid_property() {
        return heif_suberror_Invalid_property;
    }
    private static final int heif_suberror_Item_reference_cycle = (int)2008L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Item_reference_cycle = 2008
     * }
     */
    public static int heif_suberror_Item_reference_cycle() {
        return heif_suberror_Item_reference_cycle;
    }
    private static final int heif_suberror_Unsupported_codec = (int)3000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_codec = 3000
     * }
     */
    public static int heif_suberror_Unsupported_codec() {
        return heif_suberror_Unsupported_codec;
    }
    private static final int heif_suberror_Unsupported_image_type = (int)3001L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_image_type = 3001
     * }
     */
    public static int heif_suberror_Unsupported_image_type() {
        return heif_suberror_Unsupported_image_type;
    }
    private static final int heif_suberror_Unsupported_data_version = (int)3002L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_data_version = 3002
     * }
     */
    public static int heif_suberror_Unsupported_data_version() {
        return heif_suberror_Unsupported_data_version;
    }
    private static final int heif_suberror_Unsupported_color_conversion = (int)3003L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_color_conversion = 3003
     * }
     */
    public static int heif_suberror_Unsupported_color_conversion() {
        return heif_suberror_Unsupported_color_conversion;
    }
    private static final int heif_suberror_Unsupported_item_construction_method = (int)3004L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_item_construction_method = 3004
     * }
     */
    public static int heif_suberror_Unsupported_item_construction_method() {
        return heif_suberror_Unsupported_item_construction_method;
    }
    private static final int heif_suberror_Unsupported_header_compression_method = (int)3005L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_header_compression_method = 3005
     * }
     */
    public static int heif_suberror_Unsupported_header_compression_method() {
        return heif_suberror_Unsupported_header_compression_method;
    }
    private static final int heif_suberror_Unsupported_bit_depth = (int)4000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Unsupported_bit_depth = 4000
     * }
     */
    public static int heif_suberror_Unsupported_bit_depth() {
        return heif_suberror_Unsupported_bit_depth;
    }
    private static final int heif_suberror_Cannot_write_output_data = (int)5000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Cannot_write_output_data = 5000
     * }
     */
    public static int heif_suberror_Cannot_write_output_data() {
        return heif_suberror_Cannot_write_output_data;
    }
    private static final int heif_suberror_Encoder_initialization = (int)5001L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Encoder_initialization = 5001
     * }
     */
    public static int heif_suberror_Encoder_initialization() {
        return heif_suberror_Encoder_initialization;
    }
    private static final int heif_suberror_Encoder_encoding = (int)5002L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Encoder_encoding = 5002
     * }
     */
    public static int heif_suberror_Encoder_encoding() {
        return heif_suberror_Encoder_encoding;
    }
    private static final int heif_suberror_Encoder_cleanup = (int)5003L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Encoder_cleanup = 5003
     * }
     */
    public static int heif_suberror_Encoder_cleanup() {
        return heif_suberror_Encoder_cleanup;
    }
    private static final int heif_suberror_Too_many_regions = (int)5004L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Too_many_regions = 5004
     * }
     */
    public static int heif_suberror_Too_many_regions() {
        return heif_suberror_Too_many_regions;
    }
    private static final int heif_suberror_Plugin_loading_error = (int)6000L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Plugin_loading_error = 6000
     * }
     */
    public static int heif_suberror_Plugin_loading_error() {
        return heif_suberror_Plugin_loading_error;
    }
    private static final int heif_suberror_Plugin_is_not_loaded = (int)6001L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Plugin_is_not_loaded = 6001
     * }
     */
    public static int heif_suberror_Plugin_is_not_loaded() {
        return heif_suberror_Plugin_is_not_loaded;
    }
    private static final int heif_suberror_Cannot_read_plugin_directory = (int)6002L;
    /**
     * {@snippet lang=c :
     * enum heif_suberror_code.heif_suberror_Cannot_read_plugin_directory = 6002
     * }
     */
    public static int heif_suberror_Cannot_read_plugin_directory() {
        return heif_suberror_Cannot_read_plugin_directory;
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t heif_item_id
     * }
     */
    public static final OfInt heif_item_id = heif_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t heif_property_id
     * }
     */
    public static final OfInt heif_property_id = heif_h.C_INT;

    private static class heif_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_init(struct heif_init_params *)
     * }
     */
    public static FunctionDescriptor heif_init$descriptor() {
        return heif_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_init(struct heif_init_params *)
     * }
     */
    public static MethodHandle heif_init$handle() {
        return heif_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_init(struct heif_init_params *)
     * }
     */
    public static MemorySegment heif_init$address() {
        return heif_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_init(struct heif_init_params *)
     * }
     */
    public static MemorySegment heif_init(SegmentAllocator allocator, MemorySegment x0) {
        var mh$ = heif_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_init", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_deinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_deinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_deinit()
     * }
     */
    public static FunctionDescriptor heif_deinit$descriptor() {
        return heif_deinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_deinit()
     * }
     */
    public static MethodHandle heif_deinit$handle() {
        return heif_deinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_deinit()
     * }
     */
    public static MemorySegment heif_deinit$address() {
        return heif_deinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_deinit()
     * }
     */
    public static void heif_deinit() {
        var mh$ = heif_deinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_deinit");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_plugin_type_encoder = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_plugin_type.heif_plugin_type_encoder = 0
     * }
     */
    public static int heif_plugin_type_encoder() {
        return heif_plugin_type_encoder;
    }
    private static final int heif_plugin_type_decoder = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_plugin_type.heif_plugin_type_decoder = 1
     * }
     */
    public static int heif_plugin_type_decoder() {
        return heif_plugin_type_decoder;
    }

    private static class heif_load_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_load_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugin(const char *filename, const struct heif_plugin_info **out_plugin)
     * }
     */
    public static FunctionDescriptor heif_load_plugin$descriptor() {
        return heif_load_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugin(const char *filename, const struct heif_plugin_info **out_plugin)
     * }
     */
    public static MethodHandle heif_load_plugin$handle() {
        return heif_load_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugin(const char *filename, const struct heif_plugin_info **out_plugin)
     * }
     */
    public static MemorySegment heif_load_plugin$address() {
        return heif_load_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_load_plugin(const char *filename, const struct heif_plugin_info **out_plugin)
     * }
     */
    public static MemorySegment heif_load_plugin(SegmentAllocator allocator, MemorySegment filename, MemorySegment out_plugin) {
        var mh$ = heif_load_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_load_plugin", allocator, filename, out_plugin);
            }
            return (MemorySegment)mh$.invokeExact(allocator, filename, out_plugin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_load_plugins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_load_plugins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugins(const char *directory, const struct heif_plugin_info **out_plugins, int *out_nPluginsLoaded, int output_array_size)
     * }
     */
    public static FunctionDescriptor heif_load_plugins$descriptor() {
        return heif_load_plugins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugins(const char *directory, const struct heif_plugin_info **out_plugins, int *out_nPluginsLoaded, int output_array_size)
     * }
     */
    public static MethodHandle heif_load_plugins$handle() {
        return heif_load_plugins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_load_plugins(const char *directory, const struct heif_plugin_info **out_plugins, int *out_nPluginsLoaded, int output_array_size)
     * }
     */
    public static MemorySegment heif_load_plugins$address() {
        return heif_load_plugins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_load_plugins(const char *directory, const struct heif_plugin_info **out_plugins, int *out_nPluginsLoaded, int output_array_size)
     * }
     */
    public static MemorySegment heif_load_plugins(SegmentAllocator allocator, MemorySegment directory, MemorySegment out_plugins, MemorySegment out_nPluginsLoaded, int output_array_size) {
        var mh$ = heif_load_plugins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_load_plugins", allocator, directory, out_plugins, out_nPluginsLoaded, output_array_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, directory, out_plugins, out_nPluginsLoaded, output_array_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_unload_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_unload_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_unload_plugin(const struct heif_plugin_info *plugin)
     * }
     */
    public static FunctionDescriptor heif_unload_plugin$descriptor() {
        return heif_unload_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_unload_plugin(const struct heif_plugin_info *plugin)
     * }
     */
    public static MethodHandle heif_unload_plugin$handle() {
        return heif_unload_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_unload_plugin(const struct heif_plugin_info *plugin)
     * }
     */
    public static MemorySegment heif_unload_plugin$address() {
        return heif_unload_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_unload_plugin(const struct heif_plugin_info *plugin)
     * }
     */
    public static MemorySegment heif_unload_plugin(SegmentAllocator allocator, MemorySegment plugin) {
        var mh$ = heif_unload_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_unload_plugin", allocator, plugin);
            }
            return (MemorySegment)mh$.invokeExact(allocator, plugin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_filetype_no = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_filetype_result.heif_filetype_no = 0
     * }
     */
    public static int heif_filetype_no() {
        return heif_filetype_no;
    }
    private static final int heif_filetype_yes_supported = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_filetype_result.heif_filetype_yes_supported = 1
     * }
     */
    public static int heif_filetype_yes_supported() {
        return heif_filetype_yes_supported;
    }
    private static final int heif_filetype_yes_unsupported = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_filetype_result.heif_filetype_yes_unsupported = 2
     * }
     */
    public static int heif_filetype_yes_unsupported() {
        return heif_filetype_yes_unsupported;
    }
    private static final int heif_filetype_maybe = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_filetype_result.heif_filetype_maybe = 3
     * }
     */
    public static int heif_filetype_maybe() {
        return heif_filetype_maybe;
    }

    private static class heif_check_filetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_check_filetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_filetype_result heif_check_filetype(const uint8_t *data, int len)
     * }
     */
    public static FunctionDescriptor heif_check_filetype$descriptor() {
        return heif_check_filetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_filetype_result heif_check_filetype(const uint8_t *data, int len)
     * }
     */
    public static MethodHandle heif_check_filetype$handle() {
        return heif_check_filetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_filetype_result heif_check_filetype(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_check_filetype$address() {
        return heif_check_filetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_filetype_result heif_check_filetype(const uint8_t *data, int len)
     * }
     */
    public static int heif_check_filetype(MemorySegment data, int len) {
        var mh$ = heif_check_filetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_check_filetype", data, len);
            }
            return (int)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_check_jpeg_filetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_check_jpeg_filetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_check_jpeg_filetype(const uint8_t *data, int len)
     * }
     */
    public static FunctionDescriptor heif_check_jpeg_filetype$descriptor() {
        return heif_check_jpeg_filetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_check_jpeg_filetype(const uint8_t *data, int len)
     * }
     */
    public static MethodHandle heif_check_jpeg_filetype$handle() {
        return heif_check_jpeg_filetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_check_jpeg_filetype(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_check_jpeg_filetype$address() {
        return heif_check_jpeg_filetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_check_jpeg_filetype(const uint8_t *data, int len)
     * }
     */
    public static int heif_check_jpeg_filetype(MemorySegment data, int len) {
        var mh$ = heif_check_jpeg_filetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_check_jpeg_filetype", data, len);
            }
            return (int)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_unknown_brand = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_unknown_brand = 0
     * }
     */
    public static int heif_unknown_brand() {
        return heif_unknown_brand;
    }
    private static final int heif_heic = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_heic = 1
     * }
     */
    public static int heif_heic() {
        return heif_heic;
    }
    private static final int heif_heix = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_heix = 2
     * }
     */
    public static int heif_heix() {
        return heif_heix;
    }
    private static final int heif_hevc = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_hevc = 3
     * }
     */
    public static int heif_hevc() {
        return heif_hevc;
    }
    private static final int heif_hevx = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_hevx = 4
     * }
     */
    public static int heif_hevx() {
        return heif_hevx;
    }
    private static final int heif_heim = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_heim = 5
     * }
     */
    public static int heif_heim() {
        return heif_heim;
    }
    private static final int heif_heis = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_heis = 6
     * }
     */
    public static int heif_heis() {
        return heif_heis;
    }
    private static final int heif_hevm = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_hevm = 7
     * }
     */
    public static int heif_hevm() {
        return heif_hevm;
    }
    private static final int heif_hevs = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_hevs = 8
     * }
     */
    public static int heif_hevs() {
        return heif_hevs;
    }
    private static final int heif_mif1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_mif1 = 9
     * }
     */
    public static int heif_mif1() {
        return heif_mif1;
    }
    private static final int heif_msf1 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_msf1 = 10
     * }
     */
    public static int heif_msf1() {
        return heif_msf1;
    }
    private static final int heif_avif = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_avif = 11
     * }
     */
    public static int heif_avif() {
        return heif_avif;
    }
    private static final int heif_avis = (int)12L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_avis = 12
     * }
     */
    public static int heif_avis() {
        return heif_avis;
    }
    private static final int heif_vvic = (int)13L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_vvic = 13
     * }
     */
    public static int heif_vvic() {
        return heif_vvic;
    }
    private static final int heif_vvis = (int)14L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_vvis = 14
     * }
     */
    public static int heif_vvis() {
        return heif_vvis;
    }
    private static final int heif_evbi = (int)15L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_evbi = 15
     * }
     */
    public static int heif_evbi() {
        return heif_evbi;
    }
    private static final int heif_evbs = (int)16L;
    /**
     * {@snippet lang=c :
     * enum heif_brand.heif_evbs = 16
     * }
     */
    public static int heif_evbs() {
        return heif_evbs;
    }

    private static class heif_main_brand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_main_brand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_brand heif_main_brand(const uint8_t *data, int len)
     * }
     */
    public static FunctionDescriptor heif_main_brand$descriptor() {
        return heif_main_brand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_brand heif_main_brand(const uint8_t *data, int len)
     * }
     */
    public static MethodHandle heif_main_brand$handle() {
        return heif_main_brand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_brand heif_main_brand(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_main_brand$address() {
        return heif_main_brand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_brand heif_main_brand(const uint8_t *data, int len)
     * }
     */
    public static int heif_main_brand(MemorySegment data, int len) {
        var mh$ = heif_main_brand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_main_brand", data, len);
            }
            return (int)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t heif_brand2
     * }
     */
    public static final OfInt heif_brand2 = heif_h.C_INT;

    private static class heif_read_main_brand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_read_main_brand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * heif_brand2 heif_read_main_brand(const uint8_t *data, int len)
     * }
     */
    public static FunctionDescriptor heif_read_main_brand$descriptor() {
        return heif_read_main_brand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * heif_brand2 heif_read_main_brand(const uint8_t *data, int len)
     * }
     */
    public static MethodHandle heif_read_main_brand$handle() {
        return heif_read_main_brand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * heif_brand2 heif_read_main_brand(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_read_main_brand$address() {
        return heif_read_main_brand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * heif_brand2 heif_read_main_brand(const uint8_t *data, int len)
     * }
     */
    public static int heif_read_main_brand(MemorySegment data, int len) {
        var mh$ = heif_read_main_brand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_read_main_brand", data, len);
            }
            return (int)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_fourcc_to_brand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_fourcc_to_brand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * heif_brand2 heif_fourcc_to_brand(const char *brand_fourcc)
     * }
     */
    public static FunctionDescriptor heif_fourcc_to_brand$descriptor() {
        return heif_fourcc_to_brand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * heif_brand2 heif_fourcc_to_brand(const char *brand_fourcc)
     * }
     */
    public static MethodHandle heif_fourcc_to_brand$handle() {
        return heif_fourcc_to_brand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * heif_brand2 heif_fourcc_to_brand(const char *brand_fourcc)
     * }
     */
    public static MemorySegment heif_fourcc_to_brand$address() {
        return heif_fourcc_to_brand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * heif_brand2 heif_fourcc_to_brand(const char *brand_fourcc)
     * }
     */
    public static int heif_fourcc_to_brand(MemorySegment brand_fourcc) {
        var mh$ = heif_fourcc_to_brand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_fourcc_to_brand", brand_fourcc);
            }
            return (int)mh$.invokeExact(brand_fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_brand_to_fourcc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_brand_to_fourcc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_brand_to_fourcc(heif_brand2 brand, char *out_fourcc)
     * }
     */
    public static FunctionDescriptor heif_brand_to_fourcc$descriptor() {
        return heif_brand_to_fourcc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_brand_to_fourcc(heif_brand2 brand, char *out_fourcc)
     * }
     */
    public static MethodHandle heif_brand_to_fourcc$handle() {
        return heif_brand_to_fourcc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_brand_to_fourcc(heif_brand2 brand, char *out_fourcc)
     * }
     */
    public static MemorySegment heif_brand_to_fourcc$address() {
        return heif_brand_to_fourcc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_brand_to_fourcc(heif_brand2 brand, char *out_fourcc)
     * }
     */
    public static void heif_brand_to_fourcc(int brand, MemorySegment out_fourcc) {
        var mh$ = heif_brand_to_fourcc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_brand_to_fourcc", brand, out_fourcc);
            }
            mh$.invokeExact(brand, out_fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_has_compatible_brand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_has_compatible_brand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_has_compatible_brand(const uint8_t *data, int len, const char *brand_fourcc)
     * }
     */
    public static FunctionDescriptor heif_has_compatible_brand$descriptor() {
        return heif_has_compatible_brand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_has_compatible_brand(const uint8_t *data, int len, const char *brand_fourcc)
     * }
     */
    public static MethodHandle heif_has_compatible_brand$handle() {
        return heif_has_compatible_brand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_has_compatible_brand(const uint8_t *data, int len, const char *brand_fourcc)
     * }
     */
    public static MemorySegment heif_has_compatible_brand$address() {
        return heif_has_compatible_brand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_has_compatible_brand(const uint8_t *data, int len, const char *brand_fourcc)
     * }
     */
    public static int heif_has_compatible_brand(MemorySegment data, int len, MemorySegment brand_fourcc) {
        var mh$ = heif_has_compatible_brand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_has_compatible_brand", data, len, brand_fourcc);
            }
            return (int)mh$.invokeExact(data, len, brand_fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_list_compatible_brands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_list_compatible_brands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_list_compatible_brands(const uint8_t *data, int len, heif_brand2 **out_brands, int *out_size)
     * }
     */
    public static FunctionDescriptor heif_list_compatible_brands$descriptor() {
        return heif_list_compatible_brands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_list_compatible_brands(const uint8_t *data, int len, heif_brand2 **out_brands, int *out_size)
     * }
     */
    public static MethodHandle heif_list_compatible_brands$handle() {
        return heif_list_compatible_brands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_list_compatible_brands(const uint8_t *data, int len, heif_brand2 **out_brands, int *out_size)
     * }
     */
    public static MemorySegment heif_list_compatible_brands$address() {
        return heif_list_compatible_brands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_list_compatible_brands(const uint8_t *data, int len, heif_brand2 **out_brands, int *out_size)
     * }
     */
    public static MemorySegment heif_list_compatible_brands(SegmentAllocator allocator, MemorySegment data, int len, MemorySegment out_brands, MemorySegment out_size) {
        var mh$ = heif_list_compatible_brands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_list_compatible_brands", allocator, data, len, out_brands, out_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, data, len, out_brands, out_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_free_list_of_compatible_brands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_free_list_of_compatible_brands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_free_list_of_compatible_brands(heif_brand2 *brands_list)
     * }
     */
    public static FunctionDescriptor heif_free_list_of_compatible_brands$descriptor() {
        return heif_free_list_of_compatible_brands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_free_list_of_compatible_brands(heif_brand2 *brands_list)
     * }
     */
    public static MethodHandle heif_free_list_of_compatible_brands$handle() {
        return heif_free_list_of_compatible_brands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_free_list_of_compatible_brands(heif_brand2 *brands_list)
     * }
     */
    public static MemorySegment heif_free_list_of_compatible_brands$address() {
        return heif_free_list_of_compatible_brands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_free_list_of_compatible_brands(heif_brand2 *brands_list)
     * }
     */
    public static void heif_free_list_of_compatible_brands(MemorySegment brands_list) {
        var mh$ = heif_free_list_of_compatible_brands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_free_list_of_compatible_brands", brands_list);
            }
            mh$.invokeExact(brands_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_file_mime_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_file_mime_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_get_file_mime_type(const uint8_t *data, int len)
     * }
     */
    public static FunctionDescriptor heif_get_file_mime_type$descriptor() {
        return heif_get_file_mime_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_get_file_mime_type(const uint8_t *data, int len)
     * }
     */
    public static MethodHandle heif_get_file_mime_type$handle() {
        return heif_get_file_mime_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_get_file_mime_type(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_get_file_mime_type$address() {
        return heif_get_file_mime_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_get_file_mime_type(const uint8_t *data, int len)
     * }
     */
    public static MemorySegment heif_get_file_mime_type(MemorySegment data, int len) {
        var mh$ = heif_get_file_mime_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_file_mime_type", data, len);
            }
            return (MemorySegment)mh$.invokeExact(data, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER    );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_context *heif_context_alloc()
     * }
     */
    public static FunctionDescriptor heif_context_alloc$descriptor() {
        return heif_context_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_context *heif_context_alloc()
     * }
     */
    public static MethodHandle heif_context_alloc$handle() {
        return heif_context_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_context *heif_context_alloc()
     * }
     */
    public static MemorySegment heif_context_alloc$address() {
        return heif_context_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_context *heif_context_alloc()
     * }
     */
    public static MemorySegment heif_context_alloc() {
        var mh$ = heif_context_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_context_free(struct heif_context *)
     * }
     */
    public static FunctionDescriptor heif_context_free$descriptor() {
        return heif_context_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_context_free(struct heif_context *)
     * }
     */
    public static MethodHandle heif_context_free$handle() {
        return heif_context_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_context_free(struct heif_context *)
     * }
     */
    public static MemorySegment heif_context_free$address() {
        return heif_context_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_context_free(struct heif_context *)
     * }
     */
    public static void heif_context_free(MemorySegment x0) {
        var mh$ = heif_context_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_reader_grow_status_size_reached = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_reader_grow_status.heif_reader_grow_status_size_reached = 0
     * }
     */
    public static int heif_reader_grow_status_size_reached() {
        return heif_reader_grow_status_size_reached;
    }
    private static final int heif_reader_grow_status_timeout = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_reader_grow_status.heif_reader_grow_status_timeout = 1
     * }
     */
    public static int heif_reader_grow_status_timeout() {
        return heif_reader_grow_status_timeout;
    }
    private static final int heif_reader_grow_status_size_beyond_eof = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_reader_grow_status.heif_reader_grow_status_size_beyond_eof = 2
     * }
     */
    public static int heif_reader_grow_status_size_beyond_eof() {
        return heif_reader_grow_status_size_beyond_eof;
    }

    private static class heif_context_read_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_read_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_file(struct heif_context *, const char *filename, const struct heif_reading_options *)
     * }
     */
    public static FunctionDescriptor heif_context_read_from_file$descriptor() {
        return heif_context_read_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_file(struct heif_context *, const char *filename, const struct heif_reading_options *)
     * }
     */
    public static MethodHandle heif_context_read_from_file$handle() {
        return heif_context_read_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_file(struct heif_context *, const char *filename, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_file$address() {
        return heif_context_read_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_file(struct heif_context *, const char *filename, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_file(SegmentAllocator allocator, MemorySegment x0, MemorySegment filename, MemorySegment x2) {
        var mh$ = heif_context_read_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_read_from_file", allocator, x0, filename, x2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, filename, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_read_from_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_LONG,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_read_from_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static FunctionDescriptor heif_context_read_from_memory$descriptor() {
        return heif_context_read_from_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MethodHandle heif_context_read_from_memory$handle() {
        return heif_context_read_from_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_memory$address() {
        return heif_context_read_from_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_memory(SegmentAllocator allocator, MemorySegment x0, MemorySegment mem, long size, MemorySegment x3) {
        var mh$ = heif_context_read_from_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_read_from_memory", allocator, x0, mem, size, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, mem, size, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_read_from_memory_without_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_LONG,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_read_from_memory_without_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory_without_copy(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static FunctionDescriptor heif_context_read_from_memory_without_copy$descriptor() {
        return heif_context_read_from_memory_without_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory_without_copy(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MethodHandle heif_context_read_from_memory_without_copy$handle() {
        return heif_context_read_from_memory_without_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory_without_copy(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_memory_without_copy$address() {
        return heif_context_read_from_memory_without_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_memory_without_copy(struct heif_context *, const void *mem, size_t size, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_memory_without_copy(SegmentAllocator allocator, MemorySegment x0, MemorySegment mem, long size, MemorySegment x3) {
        var mh$ = heif_context_read_from_memory_without_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_read_from_memory_without_copy", allocator, x0, mem, size, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, mem, size, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_read_from_reader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_read_from_reader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_reader(struct heif_context *, const struct heif_reader *reader, void *userdata, const struct heif_reading_options *)
     * }
     */
    public static FunctionDescriptor heif_context_read_from_reader$descriptor() {
        return heif_context_read_from_reader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_reader(struct heif_context *, const struct heif_reader *reader, void *userdata, const struct heif_reading_options *)
     * }
     */
    public static MethodHandle heif_context_read_from_reader$handle() {
        return heif_context_read_from_reader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_reader(struct heif_context *, const struct heif_reader *reader, void *userdata, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_reader$address() {
        return heif_context_read_from_reader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_read_from_reader(struct heif_context *, const struct heif_reader *reader, void *userdata, const struct heif_reading_options *)
     * }
     */
    public static MemorySegment heif_context_read_from_reader(SegmentAllocator allocator, MemorySegment x0, MemorySegment reader, MemorySegment userdata, MemorySegment x3) {
        var mh$ = heif_context_read_from_reader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_read_from_reader", allocator, x0, reader, userdata, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, reader, userdata, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_number_of_top_level_images {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_number_of_top_level_images");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_context_get_number_of_top_level_images(struct heif_context *ctx)
     * }
     */
    public static FunctionDescriptor heif_context_get_number_of_top_level_images$descriptor() {
        return heif_context_get_number_of_top_level_images.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_context_get_number_of_top_level_images(struct heif_context *ctx)
     * }
     */
    public static MethodHandle heif_context_get_number_of_top_level_images$handle() {
        return heif_context_get_number_of_top_level_images.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_context_get_number_of_top_level_images(struct heif_context *ctx)
     * }
     */
    public static MemorySegment heif_context_get_number_of_top_level_images$address() {
        return heif_context_get_number_of_top_level_images.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_context_get_number_of_top_level_images(struct heif_context *ctx)
     * }
     */
    public static int heif_context_get_number_of_top_level_images(MemorySegment ctx) {
        var mh$ = heif_context_get_number_of_top_level_images.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_number_of_top_level_images", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_is_top_level_image_ID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_is_top_level_image_ID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_context_is_top_level_image_ID(struct heif_context *ctx, heif_item_id id)
     * }
     */
    public static FunctionDescriptor heif_context_is_top_level_image_ID$descriptor() {
        return heif_context_is_top_level_image_ID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_context_is_top_level_image_ID(struct heif_context *ctx, heif_item_id id)
     * }
     */
    public static MethodHandle heif_context_is_top_level_image_ID$handle() {
        return heif_context_is_top_level_image_ID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_context_is_top_level_image_ID(struct heif_context *ctx, heif_item_id id)
     * }
     */
    public static MemorySegment heif_context_is_top_level_image_ID$address() {
        return heif_context_is_top_level_image_ID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_context_is_top_level_image_ID(struct heif_context *ctx, heif_item_id id)
     * }
     */
    public static int heif_context_is_top_level_image_ID(MemorySegment ctx, int id) {
        var mh$ = heif_context_is_top_level_image_ID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_is_top_level_image_ID", ctx, id);
            }
            return (int)mh$.invokeExact(ctx, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_list_of_top_level_image_IDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_list_of_top_level_image_IDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_context_get_list_of_top_level_image_IDs(struct heif_context *ctx, heif_item_id *ID_array, int count)
     * }
     */
    public static FunctionDescriptor heif_context_get_list_of_top_level_image_IDs$descriptor() {
        return heif_context_get_list_of_top_level_image_IDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_context_get_list_of_top_level_image_IDs(struct heif_context *ctx, heif_item_id *ID_array, int count)
     * }
     */
    public static MethodHandle heif_context_get_list_of_top_level_image_IDs$handle() {
        return heif_context_get_list_of_top_level_image_IDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_context_get_list_of_top_level_image_IDs(struct heif_context *ctx, heif_item_id *ID_array, int count)
     * }
     */
    public static MemorySegment heif_context_get_list_of_top_level_image_IDs$address() {
        return heif_context_get_list_of_top_level_image_IDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_context_get_list_of_top_level_image_IDs(struct heif_context *ctx, heif_item_id *ID_array, int count)
     * }
     */
    public static int heif_context_get_list_of_top_level_image_IDs(MemorySegment ctx, MemorySegment ID_array, int count) {
        var mh$ = heif_context_get_list_of_top_level_image_IDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_list_of_top_level_image_IDs", ctx, ID_array, count);
            }
            return (int)mh$.invokeExact(ctx, ID_array, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_primary_image_ID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_primary_image_ID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_ID(struct heif_context *ctx, heif_item_id *id)
     * }
     */
    public static FunctionDescriptor heif_context_get_primary_image_ID$descriptor() {
        return heif_context_get_primary_image_ID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_ID(struct heif_context *ctx, heif_item_id *id)
     * }
     */
    public static MethodHandle heif_context_get_primary_image_ID$handle() {
        return heif_context_get_primary_image_ID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_ID(struct heif_context *ctx, heif_item_id *id)
     * }
     */
    public static MemorySegment heif_context_get_primary_image_ID$address() {
        return heif_context_get_primary_image_ID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_ID(struct heif_context *ctx, heif_item_id *id)
     * }
     */
    public static MemorySegment heif_context_get_primary_image_ID(SegmentAllocator allocator, MemorySegment ctx, MemorySegment id) {
        var mh$ = heif_context_get_primary_image_ID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_primary_image_ID", allocator, ctx, id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_primary_image_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_primary_image_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_handle(struct heif_context *ctx, struct heif_image_handle **)
     * }
     */
    public static FunctionDescriptor heif_context_get_primary_image_handle$descriptor() {
        return heif_context_get_primary_image_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_handle(struct heif_context *ctx, struct heif_image_handle **)
     * }
     */
    public static MethodHandle heif_context_get_primary_image_handle$handle() {
        return heif_context_get_primary_image_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_handle(struct heif_context *ctx, struct heif_image_handle **)
     * }
     */
    public static MemorySegment heif_context_get_primary_image_handle$address() {
        return heif_context_get_primary_image_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_primary_image_handle(struct heif_context *ctx, struct heif_image_handle **)
     * }
     */
    public static MemorySegment heif_context_get_primary_image_handle(SegmentAllocator allocator, MemorySegment ctx, MemorySegment x1) {
        var mh$ = heif_context_get_primary_image_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_primary_image_handle", allocator, ctx, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_image_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_image_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_image_handle(struct heif_context *ctx, heif_item_id id, struct heif_image_handle **)
     * }
     */
    public static FunctionDescriptor heif_context_get_image_handle$descriptor() {
        return heif_context_get_image_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_image_handle(struct heif_context *ctx, heif_item_id id, struct heif_image_handle **)
     * }
     */
    public static MethodHandle heif_context_get_image_handle$handle() {
        return heif_context_get_image_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_image_handle(struct heif_context *ctx, heif_item_id id, struct heif_image_handle **)
     * }
     */
    public static MemorySegment heif_context_get_image_handle$address() {
        return heif_context_get_image_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_image_handle(struct heif_context *ctx, heif_item_id id, struct heif_image_handle **)
     * }
     */
    public static MemorySegment heif_context_get_image_handle(SegmentAllocator allocator, MemorySegment ctx, int id, MemorySegment x2) {
        var mh$ = heif_context_get_image_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_image_handle", allocator, ctx, id, x2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, id, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_debug_dump_boxes_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_debug_dump_boxes_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_context_debug_dump_boxes_to_file(struct heif_context *ctx, int fd)
     * }
     */
    public static FunctionDescriptor heif_context_debug_dump_boxes_to_file$descriptor() {
        return heif_context_debug_dump_boxes_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_context_debug_dump_boxes_to_file(struct heif_context *ctx, int fd)
     * }
     */
    public static MethodHandle heif_context_debug_dump_boxes_to_file$handle() {
        return heif_context_debug_dump_boxes_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_context_debug_dump_boxes_to_file(struct heif_context *ctx, int fd)
     * }
     */
    public static MemorySegment heif_context_debug_dump_boxes_to_file$address() {
        return heif_context_debug_dump_boxes_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_context_debug_dump_boxes_to_file(struct heif_context *ctx, int fd)
     * }
     */
    public static void heif_context_debug_dump_boxes_to_file(MemorySegment ctx, int fd) {
        var mh$ = heif_context_debug_dump_boxes_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_debug_dump_boxes_to_file", ctx, fd);
            }
            mh$.invokeExact(ctx, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_set_maximum_image_size_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_set_maximum_image_size_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_context_set_maximum_image_size_limit(struct heif_context *ctx, int maximum_width)
     * }
     */
    public static FunctionDescriptor heif_context_set_maximum_image_size_limit$descriptor() {
        return heif_context_set_maximum_image_size_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_context_set_maximum_image_size_limit(struct heif_context *ctx, int maximum_width)
     * }
     */
    public static MethodHandle heif_context_set_maximum_image_size_limit$handle() {
        return heif_context_set_maximum_image_size_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_context_set_maximum_image_size_limit(struct heif_context *ctx, int maximum_width)
     * }
     */
    public static MemorySegment heif_context_set_maximum_image_size_limit$address() {
        return heif_context_set_maximum_image_size_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_context_set_maximum_image_size_limit(struct heif_context *ctx, int maximum_width)
     * }
     */
    public static void heif_context_set_maximum_image_size_limit(MemorySegment ctx, int maximum_width) {
        var mh$ = heif_context_set_maximum_image_size_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_set_maximum_image_size_limit", ctx, maximum_width);
            }
            mh$.invokeExact(ctx, maximum_width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_set_max_decoding_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_set_max_decoding_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_context_set_max_decoding_threads(struct heif_context *ctx, int max_threads)
     * }
     */
    public static FunctionDescriptor heif_context_set_max_decoding_threads$descriptor() {
        return heif_context_set_max_decoding_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_context_set_max_decoding_threads(struct heif_context *ctx, int max_threads)
     * }
     */
    public static MethodHandle heif_context_set_max_decoding_threads$handle() {
        return heif_context_set_max_decoding_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_context_set_max_decoding_threads(struct heif_context *ctx, int max_threads)
     * }
     */
    public static MemorySegment heif_context_set_max_decoding_threads$address() {
        return heif_context_set_max_decoding_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_context_set_max_decoding_threads(struct heif_context *ctx, int max_threads)
     * }
     */
    public static void heif_context_set_max_decoding_threads(MemorySegment ctx, int max_threads) {
        var mh$ = heif_context_set_max_decoding_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_set_max_decoding_threads", ctx, max_threads);
            }
            mh$.invokeExact(ctx, max_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_handle_release(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_release$descriptor() {
        return heif_image_handle_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_handle_release(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_release$handle() {
        return heif_image_handle_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_handle_release(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_release$address() {
        return heif_image_handle_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_handle_release(const struct heif_image_handle *)
     * }
     */
    public static void heif_image_handle_release(MemorySegment x0) {
        var mh$ = heif_image_handle_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_is_primary_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_is_primary_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_is_primary_image(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_is_primary_image$descriptor() {
        return heif_image_handle_is_primary_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_is_primary_image(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_is_primary_image$handle() {
        return heif_image_handle_is_primary_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_is_primary_image(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_is_primary_image$address() {
        return heif_image_handle_is_primary_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_is_primary_image(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_is_primary_image(MemorySegment handle) {
        var mh$ = heif_image_handle_is_primary_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_is_primary_image", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_item_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_item_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * heif_item_id heif_image_handle_get_item_id(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_item_id$descriptor() {
        return heif_image_handle_get_item_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * heif_item_id heif_image_handle_get_item_id(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_item_id$handle() {
        return heif_image_handle_get_item_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * heif_item_id heif_image_handle_get_item_id(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_item_id$address() {
        return heif_image_handle_get_item_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * heif_item_id heif_image_handle_get_item_id(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_item_id(MemorySegment handle) {
        var mh$ = heif_image_handle_get_item_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_item_id", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_width(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_width$descriptor() {
        return heif_image_handle_get_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_width(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_width$handle() {
        return heif_image_handle_get_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_width(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_width$address() {
        return heif_image_handle_get_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_width(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_width(MemorySegment handle) {
        var mh$ = heif_image_handle_get_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_width", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_height(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_height$descriptor() {
        return heif_image_handle_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_height(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_height$handle() {
        return heif_image_handle_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_height(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_height$address() {
        return heif_image_handle_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_height(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_height(MemorySegment handle) {
        var mh$ = heif_image_handle_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_height", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_has_alpha_channel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_has_alpha_channel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_has_alpha_channel(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_has_alpha_channel$descriptor() {
        return heif_image_handle_has_alpha_channel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_has_alpha_channel(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_has_alpha_channel$handle() {
        return heif_image_handle_has_alpha_channel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_has_alpha_channel(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_has_alpha_channel$address() {
        return heif_image_handle_has_alpha_channel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_has_alpha_channel(const struct heif_image_handle *)
     * }
     */
    public static int heif_image_handle_has_alpha_channel(MemorySegment x0) {
        var mh$ = heif_image_handle_has_alpha_channel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_has_alpha_channel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_is_premultiplied_alpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_is_premultiplied_alpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_is_premultiplied_alpha(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_is_premultiplied_alpha$descriptor() {
        return heif_image_handle_is_premultiplied_alpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_is_premultiplied_alpha(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_is_premultiplied_alpha$handle() {
        return heif_image_handle_is_premultiplied_alpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_is_premultiplied_alpha(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_is_premultiplied_alpha$address() {
        return heif_image_handle_is_premultiplied_alpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_is_premultiplied_alpha(const struct heif_image_handle *)
     * }
     */
    public static int heif_image_handle_is_premultiplied_alpha(MemorySegment x0) {
        var mh$ = heif_image_handle_is_premultiplied_alpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_is_premultiplied_alpha", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_luma_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_luma_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_luma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_luma_bits_per_pixel$descriptor() {
        return heif_image_handle_get_luma_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_luma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_get_luma_bits_per_pixel$handle() {
        return heif_image_handle_get_luma_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_luma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_get_luma_bits_per_pixel$address() {
        return heif_image_handle_get_luma_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_luma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static int heif_image_handle_get_luma_bits_per_pixel(MemorySegment x0) {
        var mh$ = heif_image_handle_get_luma_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_luma_bits_per_pixel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_chroma_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_chroma_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_chroma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_chroma_bits_per_pixel$descriptor() {
        return heif_image_handle_get_chroma_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_chroma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_get_chroma_bits_per_pixel$handle() {
        return heif_image_handle_get_chroma_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_chroma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_get_chroma_bits_per_pixel$address() {
        return heif_image_handle_get_chroma_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_chroma_bits_per_pixel(const struct heif_image_handle *)
     * }
     */
    public static int heif_image_handle_get_chroma_bits_per_pixel(MemorySegment x0) {
        var mh$ = heif_image_handle_get_chroma_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_chroma_bits_per_pixel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_ispe_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_ispe_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_width(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_ispe_width$descriptor() {
        return heif_image_handle_get_ispe_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_width(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_ispe_width$handle() {
        return heif_image_handle_get_ispe_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_width(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_ispe_width$address() {
        return heif_image_handle_get_ispe_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_width(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_ispe_width(MemorySegment handle) {
        var mh$ = heif_image_handle_get_ispe_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_ispe_width", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_ispe_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_ispe_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_height(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_ispe_height$descriptor() {
        return heif_image_handle_get_ispe_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_height(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_ispe_height$handle() {
        return heif_image_handle_get_ispe_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_height(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_ispe_height$address() {
        return heif_image_handle_get_ispe_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_ispe_height(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_ispe_height(MemorySegment handle) {
        var mh$ = heif_image_handle_get_ispe_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_ispe_height", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_has_depth_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_has_depth_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_has_depth_image(const struct heif_image_handle *)
     * }
     */
    public static FunctionDescriptor heif_image_handle_has_depth_image$descriptor() {
        return heif_image_handle_has_depth_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_has_depth_image(const struct heif_image_handle *)
     * }
     */
    public static MethodHandle heif_image_handle_has_depth_image$handle() {
        return heif_image_handle_has_depth_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_has_depth_image(const struct heif_image_handle *)
     * }
     */
    public static MemorySegment heif_image_handle_has_depth_image$address() {
        return heif_image_handle_has_depth_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_has_depth_image(const struct heif_image_handle *)
     * }
     */
    public static int heif_image_handle_has_depth_image(MemorySegment x0) {
        var mh$ = heif_image_handle_has_depth_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_has_depth_image", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_number_of_depth_images {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_number_of_depth_images");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_depth_images(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_number_of_depth_images$descriptor() {
        return heif_image_handle_get_number_of_depth_images.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_depth_images(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_number_of_depth_images$handle() {
        return heif_image_handle_get_number_of_depth_images.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_depth_images(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_number_of_depth_images$address() {
        return heif_image_handle_get_number_of_depth_images.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_depth_images(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_number_of_depth_images(MemorySegment handle) {
        var mh$ = heif_image_handle_get_number_of_depth_images.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_number_of_depth_images", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_list_of_depth_image_IDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_list_of_depth_image_IDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_depth_image_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_list_of_depth_image_IDs$descriptor() {
        return heif_image_handle_get_list_of_depth_image_IDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_depth_image_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static MethodHandle heif_image_handle_get_list_of_depth_image_IDs$handle() {
        return heif_image_handle_get_list_of_depth_image_IDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_depth_image_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static MemorySegment heif_image_handle_get_list_of_depth_image_IDs$address() {
        return heif_image_handle_get_list_of_depth_image_IDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_depth_image_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static int heif_image_handle_get_list_of_depth_image_IDs(MemorySegment handle, MemorySegment ids, int count) {
        var mh$ = heif_image_handle_get_list_of_depth_image_IDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_list_of_depth_image_IDs", handle, ids, count);
            }
            return (int)mh$.invokeExact(handle, ids, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_depth_image_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_depth_image_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_depth_image_handle(const struct heif_image_handle *handle, heif_item_id depth_image_id, struct heif_image_handle **out_depth_handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_depth_image_handle$descriptor() {
        return heif_image_handle_get_depth_image_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_depth_image_handle(const struct heif_image_handle *handle, heif_item_id depth_image_id, struct heif_image_handle **out_depth_handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_depth_image_handle$handle() {
        return heif_image_handle_get_depth_image_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_depth_image_handle(const struct heif_image_handle *handle, heif_item_id depth_image_id, struct heif_image_handle **out_depth_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_depth_image_handle$address() {
        return heif_image_handle_get_depth_image_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_depth_image_handle(const struct heif_image_handle *handle, heif_item_id depth_image_id, struct heif_image_handle **out_depth_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_depth_image_handle(SegmentAllocator allocator, MemorySegment handle, int depth_image_id, MemorySegment out_depth_handle) {
        var mh$ = heif_image_handle_get_depth_image_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_depth_image_handle", allocator, handle, depth_image_id, out_depth_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, handle, depth_image_id, out_depth_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_depth_representation_type_uniform_inverse_Z = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_depth_representation_type.heif_depth_representation_type_uniform_inverse_Z = 0
     * }
     */
    public static int heif_depth_representation_type_uniform_inverse_Z() {
        return heif_depth_representation_type_uniform_inverse_Z;
    }
    private static final int heif_depth_representation_type_uniform_disparity = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_depth_representation_type.heif_depth_representation_type_uniform_disparity = 1
     * }
     */
    public static int heif_depth_representation_type_uniform_disparity() {
        return heif_depth_representation_type_uniform_disparity;
    }
    private static final int heif_depth_representation_type_uniform_Z = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_depth_representation_type.heif_depth_representation_type_uniform_Z = 2
     * }
     */
    public static int heif_depth_representation_type_uniform_Z() {
        return heif_depth_representation_type_uniform_Z;
    }
    private static final int heif_depth_representation_type_nonuniform_disparity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_depth_representation_type.heif_depth_representation_type_nonuniform_disparity = 3
     * }
     */
    public static int heif_depth_representation_type_nonuniform_disparity() {
        return heif_depth_representation_type_nonuniform_disparity;
    }

    private static class heif_depth_representation_info_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_depth_representation_info_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_depth_representation_info_free(const struct heif_depth_representation_info *info)
     * }
     */
    public static FunctionDescriptor heif_depth_representation_info_free$descriptor() {
        return heif_depth_representation_info_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_depth_representation_info_free(const struct heif_depth_representation_info *info)
     * }
     */
    public static MethodHandle heif_depth_representation_info_free$handle() {
        return heif_depth_representation_info_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_depth_representation_info_free(const struct heif_depth_representation_info *info)
     * }
     */
    public static MemorySegment heif_depth_representation_info_free$address() {
        return heif_depth_representation_info_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_depth_representation_info_free(const struct heif_depth_representation_info *info)
     * }
     */
    public static void heif_depth_representation_info_free(MemorySegment info) {
        var mh$ = heif_depth_representation_info_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_depth_representation_info_free", info);
            }
            mh$.invokeExact(info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_depth_image_representation_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_depth_image_representation_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_depth_image_representation_info(const struct heif_image_handle *handle, heif_item_id depth_image_id, const struct heif_depth_representation_info **out)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_depth_image_representation_info$descriptor() {
        return heif_image_handle_get_depth_image_representation_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_depth_image_representation_info(const struct heif_image_handle *handle, heif_item_id depth_image_id, const struct heif_depth_representation_info **out)
     * }
     */
    public static MethodHandle heif_image_handle_get_depth_image_representation_info$handle() {
        return heif_image_handle_get_depth_image_representation_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_depth_image_representation_info(const struct heif_image_handle *handle, heif_item_id depth_image_id, const struct heif_depth_representation_info **out)
     * }
     */
    public static MemorySegment heif_image_handle_get_depth_image_representation_info$address() {
        return heif_image_handle_get_depth_image_representation_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_depth_image_representation_info(const struct heif_image_handle *handle, heif_item_id depth_image_id, const struct heif_depth_representation_info **out)
     * }
     */
    public static int heif_image_handle_get_depth_image_representation_info(MemorySegment handle, int depth_image_id, MemorySegment out) {
        var mh$ = heif_image_handle_get_depth_image_representation_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_depth_image_representation_info", handle, depth_image_id, out);
            }
            return (int)mh$.invokeExact(handle, depth_image_id, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_number_of_thumbnails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_number_of_thumbnails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_thumbnails(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_number_of_thumbnails$descriptor() {
        return heif_image_handle_get_number_of_thumbnails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_thumbnails(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_number_of_thumbnails$handle() {
        return heif_image_handle_get_number_of_thumbnails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_thumbnails(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_number_of_thumbnails$address() {
        return heif_image_handle_get_number_of_thumbnails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_thumbnails(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_number_of_thumbnails(MemorySegment handle) {
        var mh$ = heif_image_handle_get_number_of_thumbnails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_number_of_thumbnails", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_list_of_thumbnail_IDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_list_of_thumbnail_IDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_thumbnail_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_list_of_thumbnail_IDs$descriptor() {
        return heif_image_handle_get_list_of_thumbnail_IDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_thumbnail_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static MethodHandle heif_image_handle_get_list_of_thumbnail_IDs$handle() {
        return heif_image_handle_get_list_of_thumbnail_IDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_thumbnail_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static MemorySegment heif_image_handle_get_list_of_thumbnail_IDs$address() {
        return heif_image_handle_get_list_of_thumbnail_IDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_thumbnail_IDs(const struct heif_image_handle *handle, heif_item_id *ids, int count)
     * }
     */
    public static int heif_image_handle_get_list_of_thumbnail_IDs(MemorySegment handle, MemorySegment ids, int count) {
        var mh$ = heif_image_handle_get_list_of_thumbnail_IDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_list_of_thumbnail_IDs", handle, ids, count);
            }
            return (int)mh$.invokeExact(handle, ids, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_thumbnail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_thumbnail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_thumbnail(const struct heif_image_handle *main_image_handle, heif_item_id thumbnail_id, struct heif_image_handle **out_thumbnail_handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_thumbnail$descriptor() {
        return heif_image_handle_get_thumbnail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_thumbnail(const struct heif_image_handle *main_image_handle, heif_item_id thumbnail_id, struct heif_image_handle **out_thumbnail_handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_thumbnail$handle() {
        return heif_image_handle_get_thumbnail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_thumbnail(const struct heif_image_handle *main_image_handle, heif_item_id thumbnail_id, struct heif_image_handle **out_thumbnail_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_thumbnail$address() {
        return heif_image_handle_get_thumbnail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_thumbnail(const struct heif_image_handle *main_image_handle, heif_item_id thumbnail_id, struct heif_image_handle **out_thumbnail_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_thumbnail(SegmentAllocator allocator, MemorySegment main_image_handle, int thumbnail_id, MemorySegment out_thumbnail_handle) {
        var mh$ = heif_image_handle_get_thumbnail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_thumbnail", allocator, main_image_handle, thumbnail_id, out_thumbnail_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, main_image_handle, thumbnail_id, out_thumbnail_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_number_of_auxiliary_images {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_number_of_auxiliary_images");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_auxiliary_images(const struct heif_image_handle *handle, int aux_filter)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_number_of_auxiliary_images$descriptor() {
        return heif_image_handle_get_number_of_auxiliary_images.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_auxiliary_images(const struct heif_image_handle *handle, int aux_filter)
     * }
     */
    public static MethodHandle heif_image_handle_get_number_of_auxiliary_images$handle() {
        return heif_image_handle_get_number_of_auxiliary_images.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_auxiliary_images(const struct heif_image_handle *handle, int aux_filter)
     * }
     */
    public static MemorySegment heif_image_handle_get_number_of_auxiliary_images$address() {
        return heif_image_handle_get_number_of_auxiliary_images.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_auxiliary_images(const struct heif_image_handle *handle, int aux_filter)
     * }
     */
    public static int heif_image_handle_get_number_of_auxiliary_images(MemorySegment handle, int aux_filter) {
        var mh$ = heif_image_handle_get_number_of_auxiliary_images.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_number_of_auxiliary_images", handle, aux_filter);
            }
            return (int)mh$.invokeExact(handle, aux_filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_list_of_auxiliary_image_IDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_list_of_auxiliary_image_IDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_auxiliary_image_IDs(const struct heif_image_handle *handle, int aux_filter, heif_item_id *ids, int count)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_list_of_auxiliary_image_IDs$descriptor() {
        return heif_image_handle_get_list_of_auxiliary_image_IDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_auxiliary_image_IDs(const struct heif_image_handle *handle, int aux_filter, heif_item_id *ids, int count)
     * }
     */
    public static MethodHandle heif_image_handle_get_list_of_auxiliary_image_IDs$handle() {
        return heif_image_handle_get_list_of_auxiliary_image_IDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_auxiliary_image_IDs(const struct heif_image_handle *handle, int aux_filter, heif_item_id *ids, int count)
     * }
     */
    public static MemorySegment heif_image_handle_get_list_of_auxiliary_image_IDs$address() {
        return heif_image_handle_get_list_of_auxiliary_image_IDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_auxiliary_image_IDs(const struct heif_image_handle *handle, int aux_filter, heif_item_id *ids, int count)
     * }
     */
    public static int heif_image_handle_get_list_of_auxiliary_image_IDs(MemorySegment handle, int aux_filter, MemorySegment ids, int count) {
        var mh$ = heif_image_handle_get_list_of_auxiliary_image_IDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_list_of_auxiliary_image_IDs", handle, aux_filter, ids, count);
            }
            return (int)mh$.invokeExact(handle, aux_filter, ids, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_auxiliary_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_auxiliary_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_auxiliary_type$descriptor() {
        return heif_image_handle_get_auxiliary_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MethodHandle heif_image_handle_get_auxiliary_type$handle() {
        return heif_image_handle_get_auxiliary_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MemorySegment heif_image_handle_get_auxiliary_type$address() {
        return heif_image_handle_get_auxiliary_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MemorySegment heif_image_handle_get_auxiliary_type(SegmentAllocator allocator, MemorySegment handle, MemorySegment out_type) {
        var mh$ = heif_image_handle_get_auxiliary_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_auxiliary_type", allocator, handle, out_type);
            }
            return (MemorySegment)mh$.invokeExact(allocator, handle, out_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_release_auxiliary_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_release_auxiliary_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_handle_release_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static FunctionDescriptor heif_image_handle_release_auxiliary_type$descriptor() {
        return heif_image_handle_release_auxiliary_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_handle_release_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MethodHandle heif_image_handle_release_auxiliary_type$handle() {
        return heif_image_handle_release_auxiliary_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_handle_release_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MemorySegment heif_image_handle_release_auxiliary_type$address() {
        return heif_image_handle_release_auxiliary_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_handle_release_auxiliary_type(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static void heif_image_handle_release_auxiliary_type(MemorySegment handle, MemorySegment out_type) {
        var mh$ = heif_image_handle_release_auxiliary_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_release_auxiliary_type", handle, out_type);
            }
            mh$.invokeExact(handle, out_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_free_auxiliary_types {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_free_auxiliary_types");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_handle_free_auxiliary_types(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static FunctionDescriptor heif_image_handle_free_auxiliary_types$descriptor() {
        return heif_image_handle_free_auxiliary_types.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_handle_free_auxiliary_types(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MethodHandle heif_image_handle_free_auxiliary_types$handle() {
        return heif_image_handle_free_auxiliary_types.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_handle_free_auxiliary_types(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static MemorySegment heif_image_handle_free_auxiliary_types$address() {
        return heif_image_handle_free_auxiliary_types.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_handle_free_auxiliary_types(const struct heif_image_handle *handle, const char **out_type)
     * }
     */
    public static void heif_image_handle_free_auxiliary_types(MemorySegment handle, MemorySegment out_type) {
        var mh$ = heif_image_handle_free_auxiliary_types.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_free_auxiliary_types", handle, out_type);
            }
            mh$.invokeExact(handle, out_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_auxiliary_image_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_auxiliary_image_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_image_handle(const struct heif_image_handle *main_image_handle, heif_item_id auxiliary_id, struct heif_image_handle **out_auxiliary_handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_auxiliary_image_handle$descriptor() {
        return heif_image_handle_get_auxiliary_image_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_image_handle(const struct heif_image_handle *main_image_handle, heif_item_id auxiliary_id, struct heif_image_handle **out_auxiliary_handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_auxiliary_image_handle$handle() {
        return heif_image_handle_get_auxiliary_image_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_image_handle(const struct heif_image_handle *main_image_handle, heif_item_id auxiliary_id, struct heif_image_handle **out_auxiliary_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_auxiliary_image_handle$address() {
        return heif_image_handle_get_auxiliary_image_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_auxiliary_image_handle(const struct heif_image_handle *main_image_handle, heif_item_id auxiliary_id, struct heif_image_handle **out_auxiliary_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_auxiliary_image_handle(SegmentAllocator allocator, MemorySegment main_image_handle, int auxiliary_id, MemorySegment out_auxiliary_handle) {
        var mh$ = heif_image_handle_get_auxiliary_image_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_auxiliary_image_handle", allocator, main_image_handle, auxiliary_id, out_auxiliary_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, main_image_handle, auxiliary_id, out_auxiliary_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_number_of_metadata_blocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_number_of_metadata_blocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_metadata_blocks(const struct heif_image_handle *handle, const char *type_filter)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_number_of_metadata_blocks$descriptor() {
        return heif_image_handle_get_number_of_metadata_blocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_metadata_blocks(const struct heif_image_handle *handle, const char *type_filter)
     * }
     */
    public static MethodHandle heif_image_handle_get_number_of_metadata_blocks$handle() {
        return heif_image_handle_get_number_of_metadata_blocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_metadata_blocks(const struct heif_image_handle *handle, const char *type_filter)
     * }
     */
    public static MemorySegment heif_image_handle_get_number_of_metadata_blocks$address() {
        return heif_image_handle_get_number_of_metadata_blocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_metadata_blocks(const struct heif_image_handle *handle, const char *type_filter)
     * }
     */
    public static int heif_image_handle_get_number_of_metadata_blocks(MemorySegment handle, MemorySegment type_filter) {
        var mh$ = heif_image_handle_get_number_of_metadata_blocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_number_of_metadata_blocks", handle, type_filter);
            }
            return (int)mh$.invokeExact(handle, type_filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_list_of_metadata_block_IDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_list_of_metadata_block_IDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_metadata_block_IDs(const struct heif_image_handle *handle, const char *type_filter, heif_item_id *ids, int count)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_list_of_metadata_block_IDs$descriptor() {
        return heif_image_handle_get_list_of_metadata_block_IDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_metadata_block_IDs(const struct heif_image_handle *handle, const char *type_filter, heif_item_id *ids, int count)
     * }
     */
    public static MethodHandle heif_image_handle_get_list_of_metadata_block_IDs$handle() {
        return heif_image_handle_get_list_of_metadata_block_IDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_metadata_block_IDs(const struct heif_image_handle *handle, const char *type_filter, heif_item_id *ids, int count)
     * }
     */
    public static MemorySegment heif_image_handle_get_list_of_metadata_block_IDs$address() {
        return heif_image_handle_get_list_of_metadata_block_IDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_metadata_block_IDs(const struct heif_image_handle *handle, const char *type_filter, heif_item_id *ids, int count)
     * }
     */
    public static int heif_image_handle_get_list_of_metadata_block_IDs(MemorySegment handle, MemorySegment type_filter, MemorySegment ids, int count) {
        var mh$ = heif_image_handle_get_list_of_metadata_block_IDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_list_of_metadata_block_IDs", handle, type_filter, ids, count);
            }
            return (int)mh$.invokeExact(handle, type_filter, ids, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_metadata_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_metadata_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_metadata_type$descriptor() {
        return heif_image_handle_get_metadata_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MethodHandle heif_image_handle_get_metadata_type$handle() {
        return heif_image_handle_get_metadata_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata_type$address() {
        return heif_image_handle_get_metadata_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata_type(MemorySegment handle, int metadata_id) {
        var mh$ = heif_image_handle_get_metadata_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_metadata_type", handle, metadata_id);
            }
            return (MemorySegment)mh$.invokeExact(handle, metadata_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_metadata_content_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_metadata_content_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_content_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_metadata_content_type$descriptor() {
        return heif_image_handle_get_metadata_content_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_content_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MethodHandle heif_image_handle_get_metadata_content_type$handle() {
        return heif_image_handle_get_metadata_content_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_content_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata_content_type$address() {
        return heif_image_handle_get_metadata_content_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_image_handle_get_metadata_content_type(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata_content_type(MemorySegment handle, int metadata_id) {
        var mh$ = heif_image_handle_get_metadata_content_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_metadata_content_type", handle, metadata_id);
            }
            return (MemorySegment)mh$.invokeExact(handle, metadata_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_metadata_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_LONG,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_metadata_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_metadata_size(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_metadata_size$descriptor() {
        return heif_image_handle_get_metadata_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_metadata_size(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MethodHandle heif_image_handle_get_metadata_size$handle() {
        return heif_image_handle_get_metadata_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_metadata_size(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata_size$address() {
        return heif_image_handle_get_metadata_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t heif_image_handle_get_metadata_size(const struct heif_image_handle *handle, heif_item_id metadata_id)
     * }
     */
    public static long heif_image_handle_get_metadata_size(MemorySegment handle, int metadata_id) {
        var mh$ = heif_image_handle_get_metadata_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_metadata_size", handle, metadata_id);
            }
            return (long)mh$.invokeExact(handle, metadata_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_metadata(const struct heif_image_handle *handle, heif_item_id metadata_id, void *out_data)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_metadata$descriptor() {
        return heif_image_handle_get_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_metadata(const struct heif_image_handle *handle, heif_item_id metadata_id, void *out_data)
     * }
     */
    public static MethodHandle heif_image_handle_get_metadata$handle() {
        return heif_image_handle_get_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_metadata(const struct heif_image_handle *handle, heif_item_id metadata_id, void *out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata$address() {
        return heif_image_handle_get_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_metadata(const struct heif_image_handle *handle, heif_item_id metadata_id, void *out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_metadata(SegmentAllocator allocator, MemorySegment handle, int metadata_id, MemorySegment out_data) {
        var mh$ = heif_image_handle_get_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_metadata", allocator, handle, metadata_id, out_data);
            }
            return (MemorySegment)mh$.invokeExact(allocator, handle, metadata_id, out_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_color_profile_type_not_present = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type.heif_color_profile_type_not_present = 0
     * }
     */
    public static int heif_color_profile_type_not_present() {
        return heif_color_profile_type_not_present;
    }
    private static final int heif_color_profile_type_nclx = (int)1852009592L;
    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type.heif_color_profile_type_nclx = 1852009592
     * }
     */
    public static int heif_color_profile_type_nclx() {
        return heif_color_profile_type_nclx;
    }
    private static final int heif_color_profile_type_rICC = (int)1917403971L;
    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type.heif_color_profile_type_rICC = 1917403971
     * }
     */
    public static int heif_color_profile_type_rICC() {
        return heif_color_profile_type_rICC;
    }
    private static final int heif_color_profile_type_prof = (int)1886547814L;
    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type.heif_color_profile_type_prof = 1886547814
     * }
     */
    public static int heif_color_profile_type_prof() {
        return heif_color_profile_type_prof;
    }

    private static class heif_image_handle_get_color_profile_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_color_profile_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_handle_get_color_profile_type(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_color_profile_type$descriptor() {
        return heif_image_handle_get_color_profile_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_handle_get_color_profile_type(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_color_profile_type$handle() {
        return heif_image_handle_get_color_profile_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_handle_get_color_profile_type(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_color_profile_type$address() {
        return heif_image_handle_get_color_profile_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_handle_get_color_profile_type(const struct heif_image_handle *handle)
     * }
     */
    public static int heif_image_handle_get_color_profile_type(MemorySegment handle) {
        var mh$ = heif_image_handle_get_color_profile_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_color_profile_type", handle);
            }
            return (int)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_raw_color_profile_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_LONG,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_raw_color_profile_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_raw_color_profile_size(const struct heif_image_handle *handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_raw_color_profile_size$descriptor() {
        return heif_image_handle_get_raw_color_profile_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_raw_color_profile_size(const struct heif_image_handle *handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_raw_color_profile_size$handle() {
        return heif_image_handle_get_raw_color_profile_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t heif_image_handle_get_raw_color_profile_size(const struct heif_image_handle *handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_raw_color_profile_size$address() {
        return heif_image_handle_get_raw_color_profile_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t heif_image_handle_get_raw_color_profile_size(const struct heif_image_handle *handle)
     * }
     */
    public static long heif_image_handle_get_raw_color_profile_size(MemorySegment handle) {
        var mh$ = heif_image_handle_get_raw_color_profile_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_raw_color_profile_size", handle);
            }
            return (long)mh$.invokeExact(handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_raw_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_raw_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_raw_color_profile(const struct heif_image_handle *handle, void *out_data)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_raw_color_profile$descriptor() {
        return heif_image_handle_get_raw_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_raw_color_profile(const struct heif_image_handle *handle, void *out_data)
     * }
     */
    public static MethodHandle heif_image_handle_get_raw_color_profile$handle() {
        return heif_image_handle_get_raw_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_raw_color_profile(const struct heif_image_handle *handle, void *out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_raw_color_profile$address() {
        return heif_image_handle_get_raw_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_raw_color_profile(const struct heif_image_handle *handle, void *out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_raw_color_profile(SegmentAllocator allocator, MemorySegment handle, MemorySegment out_data) {
        var mh$ = heif_image_handle_get_raw_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_raw_color_profile", allocator, handle, out_data);
            }
            return (MemorySegment)mh$.invokeExact(allocator, handle, out_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_color_primaries_ITU_R_BT_709_5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_ITU_R_BT_709_5 = 1
     * }
     */
    public static int heif_color_primaries_ITU_R_BT_709_5() {
        return heif_color_primaries_ITU_R_BT_709_5;
    }
    private static final int heif_color_primaries_unspecified = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_unspecified = 2
     * }
     */
    public static int heif_color_primaries_unspecified() {
        return heif_color_primaries_unspecified;
    }
    private static final int heif_color_primaries_ITU_R_BT_470_6_System_M = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_ITU_R_BT_470_6_System_M = 4
     * }
     */
    public static int heif_color_primaries_ITU_R_BT_470_6_System_M() {
        return heif_color_primaries_ITU_R_BT_470_6_System_M;
    }
    private static final int heif_color_primaries_ITU_R_BT_470_6_System_B_G = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_ITU_R_BT_470_6_System_B_G = 5
     * }
     */
    public static int heif_color_primaries_ITU_R_BT_470_6_System_B_G() {
        return heif_color_primaries_ITU_R_BT_470_6_System_B_G;
    }
    private static final int heif_color_primaries_ITU_R_BT_601_6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_ITU_R_BT_601_6 = 6
     * }
     */
    public static int heif_color_primaries_ITU_R_BT_601_6() {
        return heif_color_primaries_ITU_R_BT_601_6;
    }
    private static final int heif_color_primaries_SMPTE_240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_SMPTE_240M = 7
     * }
     */
    public static int heif_color_primaries_SMPTE_240M() {
        return heif_color_primaries_SMPTE_240M;
    }
    private static final int heif_color_primaries_generic_film = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_generic_film = 8
     * }
     */
    public static int heif_color_primaries_generic_film() {
        return heif_color_primaries_generic_film;
    }
    private static final int heif_color_primaries_ITU_R_BT_2020_2_and_2100_0 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_ITU_R_BT_2020_2_and_2100_0 = 9
     * }
     */
    public static int heif_color_primaries_ITU_R_BT_2020_2_and_2100_0() {
        return heif_color_primaries_ITU_R_BT_2020_2_and_2100_0;
    }
    private static final int heif_color_primaries_SMPTE_ST_428_1 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_SMPTE_ST_428_1 = 10
     * }
     */
    public static int heif_color_primaries_SMPTE_ST_428_1() {
        return heif_color_primaries_SMPTE_ST_428_1;
    }
    private static final int heif_color_primaries_SMPTE_RP_431_2 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_SMPTE_RP_431_2 = 11
     * }
     */
    public static int heif_color_primaries_SMPTE_RP_431_2() {
        return heif_color_primaries_SMPTE_RP_431_2;
    }
    private static final int heif_color_primaries_SMPTE_EG_432_1 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_SMPTE_EG_432_1 = 12
     * }
     */
    public static int heif_color_primaries_SMPTE_EG_432_1() {
        return heif_color_primaries_SMPTE_EG_432_1;
    }
    private static final int heif_color_primaries_EBU_Tech_3213_E = (int)22L;
    /**
     * {@snippet lang=c :
     * enum heif_color_primaries.heif_color_primaries_EBU_Tech_3213_E = 22
     * }
     */
    public static int heif_color_primaries_EBU_Tech_3213_E() {
        return heif_color_primaries_EBU_Tech_3213_E;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_709_5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_709_5 = 1
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_709_5() {
        return heif_transfer_characteristic_ITU_R_BT_709_5;
    }
    private static final int heif_transfer_characteristic_unspecified = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_unspecified = 2
     * }
     */
    public static int heif_transfer_characteristic_unspecified() {
        return heif_transfer_characteristic_unspecified;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_470_6_System_M = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_470_6_System_M = 4
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_470_6_System_M() {
        return heif_transfer_characteristic_ITU_R_BT_470_6_System_M;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G = 5
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G() {
        return heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_601_6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_601_6 = 6
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_601_6() {
        return heif_transfer_characteristic_ITU_R_BT_601_6;
    }
    private static final int heif_transfer_characteristic_SMPTE_240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_SMPTE_240M = 7
     * }
     */
    public static int heif_transfer_characteristic_SMPTE_240M() {
        return heif_transfer_characteristic_SMPTE_240M;
    }
    private static final int heif_transfer_characteristic_linear = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_linear = 8
     * }
     */
    public static int heif_transfer_characteristic_linear() {
        return heif_transfer_characteristic_linear;
    }
    private static final int heif_transfer_characteristic_logarithmic_100 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_logarithmic_100 = 9
     * }
     */
    public static int heif_transfer_characteristic_logarithmic_100() {
        return heif_transfer_characteristic_logarithmic_100;
    }
    private static final int heif_transfer_characteristic_logarithmic_100_sqrt10 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_logarithmic_100_sqrt10 = 10
     * }
     */
    public static int heif_transfer_characteristic_logarithmic_100_sqrt10() {
        return heif_transfer_characteristic_logarithmic_100_sqrt10;
    }
    private static final int heif_transfer_characteristic_IEC_61966_2_4 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_IEC_61966_2_4 = 11
     * }
     */
    public static int heif_transfer_characteristic_IEC_61966_2_4() {
        return heif_transfer_characteristic_IEC_61966_2_4;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_1361 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_1361 = 12
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_1361() {
        return heif_transfer_characteristic_ITU_R_BT_1361;
    }
    private static final int heif_transfer_characteristic_IEC_61966_2_1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_IEC_61966_2_1 = 13
     * }
     */
    public static int heif_transfer_characteristic_IEC_61966_2_1() {
        return heif_transfer_characteristic_IEC_61966_2_1;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_2020_2_10bit = (int)14L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_2020_2_10bit = 14
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_2020_2_10bit() {
        return heif_transfer_characteristic_ITU_R_BT_2020_2_10bit;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_2020_2_12bit = (int)15L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_2020_2_12bit = 15
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_2020_2_12bit() {
        return heif_transfer_characteristic_ITU_R_BT_2020_2_12bit;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_2100_0_PQ = (int)16L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_2100_0_PQ = 16
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_2100_0_PQ() {
        return heif_transfer_characteristic_ITU_R_BT_2100_0_PQ;
    }
    private static final int heif_transfer_characteristic_SMPTE_ST_428_1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_SMPTE_ST_428_1 = 17
     * }
     */
    public static int heif_transfer_characteristic_SMPTE_ST_428_1() {
        return heif_transfer_characteristic_SMPTE_ST_428_1;
    }
    private static final int heif_transfer_characteristic_ITU_R_BT_2100_0_HLG = (int)18L;
    /**
     * {@snippet lang=c :
     * enum heif_transfer_characteristics.heif_transfer_characteristic_ITU_R_BT_2100_0_HLG = 18
     * }
     */
    public static int heif_transfer_characteristic_ITU_R_BT_2100_0_HLG() {
        return heif_transfer_characteristic_ITU_R_BT_2100_0_HLG;
    }
    private static final int heif_matrix_coefficients_RGB_GBR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_RGB_GBR = 0
     * }
     */
    public static int heif_matrix_coefficients_RGB_GBR() {
        return heif_matrix_coefficients_RGB_GBR;
    }
    private static final int heif_matrix_coefficients_ITU_R_BT_709_5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ITU_R_BT_709_5 = 1
     * }
     */
    public static int heif_matrix_coefficients_ITU_R_BT_709_5() {
        return heif_matrix_coefficients_ITU_R_BT_709_5;
    }
    private static final int heif_matrix_coefficients_unspecified = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_unspecified = 2
     * }
     */
    public static int heif_matrix_coefficients_unspecified() {
        return heif_matrix_coefficients_unspecified;
    }
    private static final int heif_matrix_coefficients_US_FCC_T47 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_US_FCC_T47 = 4
     * }
     */
    public static int heif_matrix_coefficients_US_FCC_T47() {
        return heif_matrix_coefficients_US_FCC_T47;
    }
    private static final int heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G = 5
     * }
     */
    public static int heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G() {
        return heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G;
    }
    private static final int heif_matrix_coefficients_ITU_R_BT_601_6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ITU_R_BT_601_6 = 6
     * }
     */
    public static int heif_matrix_coefficients_ITU_R_BT_601_6() {
        return heif_matrix_coefficients_ITU_R_BT_601_6;
    }
    private static final int heif_matrix_coefficients_SMPTE_240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_SMPTE_240M = 7
     * }
     */
    public static int heif_matrix_coefficients_SMPTE_240M() {
        return heif_matrix_coefficients_SMPTE_240M;
    }
    private static final int heif_matrix_coefficients_YCgCo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_YCgCo = 8
     * }
     */
    public static int heif_matrix_coefficients_YCgCo() {
        return heif_matrix_coefficients_YCgCo;
    }
    private static final int heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance = (int)9L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance = 9
     * }
     */
    public static int heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance() {
        return heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance;
    }
    private static final int heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance = 10
     * }
     */
    public static int heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance() {
        return heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance;
    }
    private static final int heif_matrix_coefficients_SMPTE_ST_2085 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_SMPTE_ST_2085 = 11
     * }
     */
    public static int heif_matrix_coefficients_SMPTE_ST_2085() {
        return heif_matrix_coefficients_SMPTE_ST_2085;
    }
    private static final int heif_matrix_coefficients_chromaticity_derived_non_constant_luminance = (int)12L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_chromaticity_derived_non_constant_luminance = 12
     * }
     */
    public static int heif_matrix_coefficients_chromaticity_derived_non_constant_luminance() {
        return heif_matrix_coefficients_chromaticity_derived_non_constant_luminance;
    }
    private static final int heif_matrix_coefficients_chromaticity_derived_constant_luminance = (int)13L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_chromaticity_derived_constant_luminance = 13
     * }
     */
    public static int heif_matrix_coefficients_chromaticity_derived_constant_luminance() {
        return heif_matrix_coefficients_chromaticity_derived_constant_luminance;
    }
    private static final int heif_matrix_coefficients_ICtCp = (int)14L;
    /**
     * {@snippet lang=c :
     * enum heif_matrix_coefficients.heif_matrix_coefficients_ICtCp = 14
     * }
     */
    public static int heif_matrix_coefficients_ICtCp() {
        return heif_matrix_coefficients_ICtCp;
    }

    private static class heif_nclx_color_profile_set_color_primaries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_SHORT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_nclx_color_profile_set_color_primaries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_color_primaries(struct heif_color_profile_nclx *nclx, uint16_t cp)
     * }
     */
    public static FunctionDescriptor heif_nclx_color_profile_set_color_primaries$descriptor() {
        return heif_nclx_color_profile_set_color_primaries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_color_primaries(struct heif_color_profile_nclx *nclx, uint16_t cp)
     * }
     */
    public static MethodHandle heif_nclx_color_profile_set_color_primaries$handle() {
        return heif_nclx_color_profile_set_color_primaries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_color_primaries(struct heif_color_profile_nclx *nclx, uint16_t cp)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_color_primaries$address() {
        return heif_nclx_color_profile_set_color_primaries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_color_primaries(struct heif_color_profile_nclx *nclx, uint16_t cp)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_color_primaries(SegmentAllocator allocator, MemorySegment nclx, short cp) {
        var mh$ = heif_nclx_color_profile_set_color_primaries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_nclx_color_profile_set_color_primaries", allocator, nclx, cp);
            }
            return (MemorySegment)mh$.invokeExact(allocator, nclx, cp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_nclx_color_profile_set_transfer_characteristics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_SHORT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_nclx_color_profile_set_transfer_characteristics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_transfer_characteristics(struct heif_color_profile_nclx *nclx, uint16_t transfer_characteristics)
     * }
     */
    public static FunctionDescriptor heif_nclx_color_profile_set_transfer_characteristics$descriptor() {
        return heif_nclx_color_profile_set_transfer_characteristics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_transfer_characteristics(struct heif_color_profile_nclx *nclx, uint16_t transfer_characteristics)
     * }
     */
    public static MethodHandle heif_nclx_color_profile_set_transfer_characteristics$handle() {
        return heif_nclx_color_profile_set_transfer_characteristics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_transfer_characteristics(struct heif_color_profile_nclx *nclx, uint16_t transfer_characteristics)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_transfer_characteristics$address() {
        return heif_nclx_color_profile_set_transfer_characteristics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_transfer_characteristics(struct heif_color_profile_nclx *nclx, uint16_t transfer_characteristics)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_transfer_characteristics(SegmentAllocator allocator, MemorySegment nclx, short transfer_characteristics) {
        var mh$ = heif_nclx_color_profile_set_transfer_characteristics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_nclx_color_profile_set_transfer_characteristics", allocator, nclx, transfer_characteristics);
            }
            return (MemorySegment)mh$.invokeExact(allocator, nclx, transfer_characteristics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_nclx_color_profile_set_matrix_coefficients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_SHORT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_nclx_color_profile_set_matrix_coefficients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_matrix_coefficients(struct heif_color_profile_nclx *nclx, uint16_t matrix_coefficients)
     * }
     */
    public static FunctionDescriptor heif_nclx_color_profile_set_matrix_coefficients$descriptor() {
        return heif_nclx_color_profile_set_matrix_coefficients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_matrix_coefficients(struct heif_color_profile_nclx *nclx, uint16_t matrix_coefficients)
     * }
     */
    public static MethodHandle heif_nclx_color_profile_set_matrix_coefficients$handle() {
        return heif_nclx_color_profile_set_matrix_coefficients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_matrix_coefficients(struct heif_color_profile_nclx *nclx, uint16_t matrix_coefficients)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_matrix_coefficients$address() {
        return heif_nclx_color_profile_set_matrix_coefficients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_nclx_color_profile_set_matrix_coefficients(struct heif_color_profile_nclx *nclx, uint16_t matrix_coefficients)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_set_matrix_coefficients(SegmentAllocator allocator, MemorySegment nclx, short matrix_coefficients) {
        var mh$ = heif_nclx_color_profile_set_matrix_coefficients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_nclx_color_profile_set_matrix_coefficients", allocator, nclx, matrix_coefficients);
            }
            return (MemorySegment)mh$.invokeExact(allocator, nclx, matrix_coefficients);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_nclx_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_nclx_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_nclx_color_profile(const struct heif_image_handle *handle, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_nclx_color_profile$descriptor() {
        return heif_image_handle_get_nclx_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_nclx_color_profile(const struct heif_image_handle *handle, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MethodHandle heif_image_handle_get_nclx_color_profile$handle() {
        return heif_image_handle_get_nclx_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_nclx_color_profile(const struct heif_image_handle *handle, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_nclx_color_profile$address() {
        return heif_image_handle_get_nclx_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_get_nclx_color_profile(const struct heif_image_handle *handle, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MemorySegment heif_image_handle_get_nclx_color_profile(SegmentAllocator allocator, MemorySegment handle, MemorySegment out_data) {
        var mh$ = heif_image_handle_get_nclx_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_nclx_color_profile", allocator, handle, out_data);
            }
            return (MemorySegment)mh$.invokeExact(allocator, handle, out_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * struct heif_color_profile_nclx *heif_nclx_color_profile_alloc()
     * }
     */
    public static class heif_nclx_color_profile_alloc {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                heif_h.C_POINTER        );
        private static final MemorySegment ADDR = heif_h.findOrThrow("heif_nclx_color_profile_alloc");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private heif_nclx_color_profile_alloc(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * struct heif_color_profile_nclx *heif_nclx_color_profile_alloc()
         * }
         */
        public static heif_nclx_color_profile_alloc makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new heif_nclx_color_profile_alloc(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("heif_nclx_color_profile_alloc", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class heif_nclx_color_profile_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_nclx_color_profile_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_nclx_color_profile_free(struct heif_color_profile_nclx *nclx_profile)
     * }
     */
    public static FunctionDescriptor heif_nclx_color_profile_free$descriptor() {
        return heif_nclx_color_profile_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_nclx_color_profile_free(struct heif_color_profile_nclx *nclx_profile)
     * }
     */
    public static MethodHandle heif_nclx_color_profile_free$handle() {
        return heif_nclx_color_profile_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_nclx_color_profile_free(struct heif_color_profile_nclx *nclx_profile)
     * }
     */
    public static MemorySegment heif_nclx_color_profile_free$address() {
        return heif_nclx_color_profile_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_nclx_color_profile_free(struct heif_color_profile_nclx *nclx_profile)
     * }
     */
    public static void heif_nclx_color_profile_free(MemorySegment nclx_profile) {
        var mh$ = heif_nclx_color_profile_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_nclx_color_profile_free", nclx_profile);
            }
            mh$.invokeExact(nclx_profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_color_profile_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_color_profile_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_get_color_profile_type(const struct heif_image *image)
     * }
     */
    public static FunctionDescriptor heif_image_get_color_profile_type$descriptor() {
        return heif_image_get_color_profile_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_get_color_profile_type(const struct heif_image *image)
     * }
     */
    public static MethodHandle heif_image_get_color_profile_type$handle() {
        return heif_image_get_color_profile_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_get_color_profile_type(const struct heif_image *image)
     * }
     */
    public static MemorySegment heif_image_get_color_profile_type$address() {
        return heif_image_get_color_profile_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_color_profile_type heif_image_get_color_profile_type(const struct heif_image *image)
     * }
     */
    public static int heif_image_get_color_profile_type(MemorySegment image) {
        var mh$ = heif_image_get_color_profile_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_color_profile_type", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_raw_color_profile_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_LONG,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_raw_color_profile_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t heif_image_get_raw_color_profile_size(const struct heif_image *image)
     * }
     */
    public static FunctionDescriptor heif_image_get_raw_color_profile_size$descriptor() {
        return heif_image_get_raw_color_profile_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t heif_image_get_raw_color_profile_size(const struct heif_image *image)
     * }
     */
    public static MethodHandle heif_image_get_raw_color_profile_size$handle() {
        return heif_image_get_raw_color_profile_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t heif_image_get_raw_color_profile_size(const struct heif_image *image)
     * }
     */
    public static MemorySegment heif_image_get_raw_color_profile_size$address() {
        return heif_image_get_raw_color_profile_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t heif_image_get_raw_color_profile_size(const struct heif_image *image)
     * }
     */
    public static long heif_image_get_raw_color_profile_size(MemorySegment image) {
        var mh$ = heif_image_get_raw_color_profile_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_raw_color_profile_size", image);
            }
            return (long)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_raw_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_raw_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_raw_color_profile(const struct heif_image *image, void *out_data)
     * }
     */
    public static FunctionDescriptor heif_image_get_raw_color_profile$descriptor() {
        return heif_image_get_raw_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_raw_color_profile(const struct heif_image *image, void *out_data)
     * }
     */
    public static MethodHandle heif_image_get_raw_color_profile$handle() {
        return heif_image_get_raw_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_raw_color_profile(const struct heif_image *image, void *out_data)
     * }
     */
    public static MemorySegment heif_image_get_raw_color_profile$address() {
        return heif_image_get_raw_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_get_raw_color_profile(const struct heif_image *image, void *out_data)
     * }
     */
    public static MemorySegment heif_image_get_raw_color_profile(SegmentAllocator allocator, MemorySegment image, MemorySegment out_data) {
        var mh$ = heif_image_get_raw_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_raw_color_profile", allocator, image, out_data);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, out_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_nclx_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_nclx_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_nclx_color_profile(const struct heif_image *image, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static FunctionDescriptor heif_image_get_nclx_color_profile$descriptor() {
        return heif_image_get_nclx_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_nclx_color_profile(const struct heif_image *image, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MethodHandle heif_image_get_nclx_color_profile$handle() {
        return heif_image_get_nclx_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_get_nclx_color_profile(const struct heif_image *image, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MemorySegment heif_image_get_nclx_color_profile$address() {
        return heif_image_get_nclx_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_get_nclx_color_profile(const struct heif_image *image, struct heif_color_profile_nclx **out_data)
     * }
     */
    public static MemorySegment heif_image_get_nclx_color_profile(SegmentAllocator allocator, MemorySegment image, MemorySegment out_data) {
        var mh$ = heif_image_get_nclx_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_nclx_color_profile", allocator, image, out_data);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, out_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_item_property_type_invalid = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_invalid = 0
     * }
     */
    public static int heif_item_property_type_invalid() {
        return heif_item_property_type_invalid;
    }
    private static final int heif_item_property_type_user_description = (int)1969513843L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_user_description = 1969513843
     * }
     */
    public static int heif_item_property_type_user_description() {
        return heif_item_property_type_user_description;
    }
    private static final int heif_item_property_type_transform_mirror = (int)1768778098L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_transform_mirror = 1768778098
     * }
     */
    public static int heif_item_property_type_transform_mirror() {
        return heif_item_property_type_transform_mirror;
    }
    private static final int heif_item_property_type_transform_rotation = (int)1769107316L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_transform_rotation = 1769107316
     * }
     */
    public static int heif_item_property_type_transform_rotation() {
        return heif_item_property_type_transform_rotation;
    }
    private static final int heif_item_property_type_transform_crop = (int)1668047216L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_transform_crop = 1668047216
     * }
     */
    public static int heif_item_property_type_transform_crop() {
        return heif_item_property_type_transform_crop;
    }
    private static final int heif_item_property_type_image_size = (int)1769173093L;
    /**
     * {@snippet lang=c :
     * enum heif_item_property_type.heif_item_property_type_image_size = 1769173093
     * }
     */
    public static int heif_item_property_type_image_size() {
        return heif_item_property_type_image_size;
    }

    private static class heif_item_get_properties_of_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_properties_of_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_item_get_properties_of_type(const struct heif_context *context, heif_item_id id, enum heif_item_property_type type, heif_property_id *out_list, int count)
     * }
     */
    public static FunctionDescriptor heif_item_get_properties_of_type$descriptor() {
        return heif_item_get_properties_of_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_item_get_properties_of_type(const struct heif_context *context, heif_item_id id, enum heif_item_property_type type, heif_property_id *out_list, int count)
     * }
     */
    public static MethodHandle heif_item_get_properties_of_type$handle() {
        return heif_item_get_properties_of_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_item_get_properties_of_type(const struct heif_context *context, heif_item_id id, enum heif_item_property_type type, heif_property_id *out_list, int count)
     * }
     */
    public static MemorySegment heif_item_get_properties_of_type$address() {
        return heif_item_get_properties_of_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_item_get_properties_of_type(const struct heif_context *context, heif_item_id id, enum heif_item_property_type type, heif_property_id *out_list, int count)
     * }
     */
    public static int heif_item_get_properties_of_type(MemorySegment context, int id, int type, MemorySegment out_list, int count) {
        var mh$ = heif_item_get_properties_of_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_properties_of_type", context, id, type, out_list, count);
            }
            return (int)mh$.invokeExact(context, id, type, out_list, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_get_transformation_properties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_transformation_properties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_item_get_transformation_properties(const struct heif_context *context, heif_item_id id, heif_property_id *out_list, int count)
     * }
     */
    public static FunctionDescriptor heif_item_get_transformation_properties$descriptor() {
        return heif_item_get_transformation_properties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_item_get_transformation_properties(const struct heif_context *context, heif_item_id id, heif_property_id *out_list, int count)
     * }
     */
    public static MethodHandle heif_item_get_transformation_properties$handle() {
        return heif_item_get_transformation_properties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_item_get_transformation_properties(const struct heif_context *context, heif_item_id id, heif_property_id *out_list, int count)
     * }
     */
    public static MemorySegment heif_item_get_transformation_properties$address() {
        return heif_item_get_transformation_properties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_item_get_transformation_properties(const struct heif_context *context, heif_item_id id, heif_property_id *out_list, int count)
     * }
     */
    public static int heif_item_get_transformation_properties(MemorySegment context, int id, MemorySegment out_list, int count) {
        var mh$ = heif_item_get_transformation_properties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_transformation_properties", context, id, out_list, count);
            }
            return (int)mh$.invokeExact(context, id, out_list, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_get_property_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_property_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_item_property_type heif_item_get_property_type(const struct heif_context *context, heif_item_id id, heif_property_id property_id)
     * }
     */
    public static FunctionDescriptor heif_item_get_property_type$descriptor() {
        return heif_item_get_property_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_item_property_type heif_item_get_property_type(const struct heif_context *context, heif_item_id id, heif_property_id property_id)
     * }
     */
    public static MethodHandle heif_item_get_property_type$handle() {
        return heif_item_get_property_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_item_property_type heif_item_get_property_type(const struct heif_context *context, heif_item_id id, heif_property_id property_id)
     * }
     */
    public static MemorySegment heif_item_get_property_type$address() {
        return heif_item_get_property_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_item_property_type heif_item_get_property_type(const struct heif_context *context, heif_item_id id, heif_property_id property_id)
     * }
     */
    public static int heif_item_get_property_type(MemorySegment context, int id, int property_id) {
        var mh$ = heif_item_get_property_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_property_type", context, id, property_id);
            }
            return (int)mh$.invokeExact(context, id, property_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_get_property_user_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_property_user_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_item_get_property_user_description(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, struct heif_property_user_description **out)
     * }
     */
    public static FunctionDescriptor heif_item_get_property_user_description$descriptor() {
        return heif_item_get_property_user_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_item_get_property_user_description(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, struct heif_property_user_description **out)
     * }
     */
    public static MethodHandle heif_item_get_property_user_description$handle() {
        return heif_item_get_property_user_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_item_get_property_user_description(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, struct heif_property_user_description **out)
     * }
     */
    public static MemorySegment heif_item_get_property_user_description$address() {
        return heif_item_get_property_user_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_item_get_property_user_description(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, struct heif_property_user_description **out)
     * }
     */
    public static MemorySegment heif_item_get_property_user_description(SegmentAllocator allocator, MemorySegment context, int itemId, int propertyId, MemorySegment out) {
        var mh$ = heif_item_get_property_user_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_property_user_description", allocator, context, itemId, propertyId, out);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context, itemId, propertyId, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_add_property_user_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_add_property_user_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_item_add_property_user_description(const struct heif_context *context, heif_item_id itemId, const struct heif_property_user_description *description, heif_property_id *out_propertyId)
     * }
     */
    public static FunctionDescriptor heif_item_add_property_user_description$descriptor() {
        return heif_item_add_property_user_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_item_add_property_user_description(const struct heif_context *context, heif_item_id itemId, const struct heif_property_user_description *description, heif_property_id *out_propertyId)
     * }
     */
    public static MethodHandle heif_item_add_property_user_description$handle() {
        return heif_item_add_property_user_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_item_add_property_user_description(const struct heif_context *context, heif_item_id itemId, const struct heif_property_user_description *description, heif_property_id *out_propertyId)
     * }
     */
    public static MemorySegment heif_item_add_property_user_description$address() {
        return heif_item_add_property_user_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_item_add_property_user_description(const struct heif_context *context, heif_item_id itemId, const struct heif_property_user_description *description, heif_property_id *out_propertyId)
     * }
     */
    public static MemorySegment heif_item_add_property_user_description(SegmentAllocator allocator, MemorySegment context, int itemId, MemorySegment description, MemorySegment out_propertyId) {
        var mh$ = heif_item_add_property_user_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_add_property_user_description", allocator, context, itemId, description, out_propertyId);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context, itemId, description, out_propertyId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_property_user_description_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_property_user_description_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_property_user_description_release(struct heif_property_user_description *)
     * }
     */
    public static FunctionDescriptor heif_property_user_description_release$descriptor() {
        return heif_property_user_description_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_property_user_description_release(struct heif_property_user_description *)
     * }
     */
    public static MethodHandle heif_property_user_description_release$handle() {
        return heif_property_user_description_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_property_user_description_release(struct heif_property_user_description *)
     * }
     */
    public static MemorySegment heif_property_user_description_release$address() {
        return heif_property_user_description_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_property_user_description_release(struct heif_property_user_description *)
     * }
     */
    public static void heif_property_user_description_release(MemorySegment x0) {
        var mh$ = heif_property_user_description_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_property_user_description_release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_transform_mirror_direction_vertical = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction.heif_transform_mirror_direction_vertical = 0
     * }
     */
    public static int heif_transform_mirror_direction_vertical() {
        return heif_transform_mirror_direction_vertical;
    }
    private static final int heif_transform_mirror_direction_horizontal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction.heif_transform_mirror_direction_horizontal = 1
     * }
     */
    public static int heif_transform_mirror_direction_horizontal() {
        return heif_transform_mirror_direction_horizontal;
    }

    private static class heif_item_get_property_transform_mirror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_property_transform_mirror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction heif_item_get_property_transform_mirror(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static FunctionDescriptor heif_item_get_property_transform_mirror$descriptor() {
        return heif_item_get_property_transform_mirror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction heif_item_get_property_transform_mirror(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static MethodHandle heif_item_get_property_transform_mirror$handle() {
        return heif_item_get_property_transform_mirror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction heif_item_get_property_transform_mirror(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static MemorySegment heif_item_get_property_transform_mirror$address() {
        return heif_item_get_property_transform_mirror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_transform_mirror_direction heif_item_get_property_transform_mirror(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static int heif_item_get_property_transform_mirror(MemorySegment context, int itemId, int propertyId) {
        var mh$ = heif_item_get_property_transform_mirror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_property_transform_mirror", context, itemId, propertyId);
            }
            return (int)mh$.invokeExact(context, itemId, propertyId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_get_property_transform_rotation_ccw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_property_transform_rotation_ccw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_item_get_property_transform_rotation_ccw(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static FunctionDescriptor heif_item_get_property_transform_rotation_ccw$descriptor() {
        return heif_item_get_property_transform_rotation_ccw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_item_get_property_transform_rotation_ccw(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static MethodHandle heif_item_get_property_transform_rotation_ccw$handle() {
        return heif_item_get_property_transform_rotation_ccw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_item_get_property_transform_rotation_ccw(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static MemorySegment heif_item_get_property_transform_rotation_ccw$address() {
        return heif_item_get_property_transform_rotation_ccw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_item_get_property_transform_rotation_ccw(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId)
     * }
     */
    public static int heif_item_get_property_transform_rotation_ccw(MemorySegment context, int itemId, int propertyId) {
        var mh$ = heif_item_get_property_transform_rotation_ccw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_property_transform_rotation_ccw", context, itemId, propertyId);
            }
            return (int)mh$.invokeExact(context, itemId, propertyId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_item_get_property_transform_crop_borders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_item_get_property_transform_crop_borders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_item_get_property_transform_crop_borders(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, int image_width, int image_height, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static FunctionDescriptor heif_item_get_property_transform_crop_borders$descriptor() {
        return heif_item_get_property_transform_crop_borders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_item_get_property_transform_crop_borders(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, int image_width, int image_height, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static MethodHandle heif_item_get_property_transform_crop_borders$handle() {
        return heif_item_get_property_transform_crop_borders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_item_get_property_transform_crop_borders(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, int image_width, int image_height, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static MemorySegment heif_item_get_property_transform_crop_borders$address() {
        return heif_item_get_property_transform_crop_borders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_item_get_property_transform_crop_borders(const struct heif_context *context, heif_item_id itemId, heif_property_id propertyId, int image_width, int image_height, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static void heif_item_get_property_transform_crop_borders(MemorySegment context, int itemId, int propertyId, int image_width, int image_height, MemorySegment left, MemorySegment top, MemorySegment right, MemorySegment bottom) {
        var mh$ = heif_item_get_property_transform_crop_borders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_item_get_property_transform_crop_borders", context, itemId, propertyId, image_width, image_height, left, top, right, bottom);
            }
            mh$.invokeExact(context, itemId, propertyId, image_width, image_height, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_compression_undefined = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_undefined = 0
     * }
     */
    public static int heif_compression_undefined() {
        return heif_compression_undefined;
    }
    private static final int heif_compression_HEVC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_HEVC = 1
     * }
     */
    public static int heif_compression_HEVC() {
        return heif_compression_HEVC;
    }
    private static final int heif_compression_AVC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_AVC = 2
     * }
     */
    public static int heif_compression_AVC() {
        return heif_compression_AVC;
    }
    private static final int heif_compression_JPEG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_JPEG = 3
     * }
     */
    public static int heif_compression_JPEG() {
        return heif_compression_JPEG;
    }
    private static final int heif_compression_AV1 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_AV1 = 4
     * }
     */
    public static int heif_compression_AV1() {
        return heif_compression_AV1;
    }
    private static final int heif_compression_VVC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_VVC = 5
     * }
     */
    public static int heif_compression_VVC() {
        return heif_compression_VVC;
    }
    private static final int heif_compression_EVC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_EVC = 6
     * }
     */
    public static int heif_compression_EVC() {
        return heif_compression_EVC;
    }
    private static final int heif_compression_JPEG2000 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_JPEG2000 = 7
     * }
     */
    public static int heif_compression_JPEG2000() {
        return heif_compression_JPEG2000;
    }
    private static final int heif_compression_uncompressed = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_compression_format.heif_compression_uncompressed = 8
     * }
     */
    public static int heif_compression_uncompressed() {
        return heif_compression_uncompressed;
    }
    private static final int heif_chroma_undefined = (int)99L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_undefined = 99
     * }
     */
    public static int heif_chroma_undefined() {
        return heif_chroma_undefined;
    }
    private static final int heif_chroma_monochrome = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_monochrome = 0
     * }
     */
    public static int heif_chroma_monochrome() {
        return heif_chroma_monochrome;
    }
    private static final int heif_chroma_420 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_420 = 1
     * }
     */
    public static int heif_chroma_420() {
        return heif_chroma_420;
    }
    private static final int heif_chroma_422 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_422 = 2
     * }
     */
    public static int heif_chroma_422() {
        return heif_chroma_422;
    }
    private static final int heif_chroma_444 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_444 = 3
     * }
     */
    public static int heif_chroma_444() {
        return heif_chroma_444;
    }
    private static final int heif_chroma_interleaved_RGB = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RGB = 10
     * }
     */
    public static int heif_chroma_interleaved_RGB() {
        return heif_chroma_interleaved_RGB;
    }
    private static final int heif_chroma_interleaved_RGBA = (int)11L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RGBA = 11
     * }
     */
    public static int heif_chroma_interleaved_RGBA() {
        return heif_chroma_interleaved_RGBA;
    }
    private static final int heif_chroma_interleaved_RRGGBB_BE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RRGGBB_BE = 12
     * }
     */
    public static int heif_chroma_interleaved_RRGGBB_BE() {
        return heif_chroma_interleaved_RRGGBB_BE;
    }
    private static final int heif_chroma_interleaved_RRGGBBAA_BE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RRGGBBAA_BE = 13
     * }
     */
    public static int heif_chroma_interleaved_RRGGBBAA_BE() {
        return heif_chroma_interleaved_RRGGBBAA_BE;
    }
    private static final int heif_chroma_interleaved_RRGGBB_LE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RRGGBB_LE = 14
     * }
     */
    public static int heif_chroma_interleaved_RRGGBB_LE() {
        return heif_chroma_interleaved_RRGGBB_LE;
    }
    private static final int heif_chroma_interleaved_RRGGBBAA_LE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma.heif_chroma_interleaved_RRGGBBAA_LE = 15
     * }
     */
    public static int heif_chroma_interleaved_RRGGBBAA_LE() {
        return heif_chroma_interleaved_RRGGBBAA_LE;
    }
    private static final int heif_colorspace_undefined = (int)99L;
    /**
     * {@snippet lang=c :
     * enum heif_colorspace.heif_colorspace_undefined = 99
     * }
     */
    public static int heif_colorspace_undefined() {
        return heif_colorspace_undefined;
    }
    private static final int heif_colorspace_YCbCr = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_colorspace.heif_colorspace_YCbCr = 0
     * }
     */
    public static int heif_colorspace_YCbCr() {
        return heif_colorspace_YCbCr;
    }
    private static final int heif_colorspace_RGB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_colorspace.heif_colorspace_RGB = 1
     * }
     */
    public static int heif_colorspace_RGB() {
        return heif_colorspace_RGB;
    }
    private static final int heif_colorspace_monochrome = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_colorspace.heif_colorspace_monochrome = 2
     * }
     */
    public static int heif_colorspace_monochrome() {
        return heif_colorspace_monochrome;
    }
    private static final int heif_channel_Y = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_Y = 0
     * }
     */
    public static int heif_channel_Y() {
        return heif_channel_Y;
    }
    private static final int heif_channel_Cb = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_Cb = 1
     * }
     */
    public static int heif_channel_Cb() {
        return heif_channel_Cb;
    }
    private static final int heif_channel_Cr = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_Cr = 2
     * }
     */
    public static int heif_channel_Cr() {
        return heif_channel_Cr;
    }
    private static final int heif_channel_R = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_R = 3
     * }
     */
    public static int heif_channel_R() {
        return heif_channel_R;
    }
    private static final int heif_channel_G = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_G = 4
     * }
     */
    public static int heif_channel_G() {
        return heif_channel_G;
    }
    private static final int heif_channel_B = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_B = 5
     * }
     */
    public static int heif_channel_B() {
        return heif_channel_B;
    }
    private static final int heif_channel_Alpha = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_Alpha = 6
     * }
     */
    public static int heif_channel_Alpha() {
        return heif_channel_Alpha;
    }
    private static final int heif_channel_interleaved = (int)10L;
    /**
     * {@snippet lang=c :
     * enum heif_channel.heif_channel_interleaved = 10
     * }
     */
    public static int heif_channel_interleaved() {
        return heif_channel_interleaved;
    }
    private static final int heif_progress_step_total = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_progress_step.heif_progress_step_total = 0
     * }
     */
    public static int heif_progress_step_total() {
        return heif_progress_step_total;
    }
    private static final int heif_progress_step_load_tile = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_progress_step.heif_progress_step_load_tile = 1
     * }
     */
    public static int heif_progress_step_load_tile() {
        return heif_progress_step_load_tile;
    }
    private static final int heif_chroma_downsampling_nearest_neighbor = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma_downsampling_algorithm.heif_chroma_downsampling_nearest_neighbor = 1
     * }
     */
    public static int heif_chroma_downsampling_nearest_neighbor() {
        return heif_chroma_downsampling_nearest_neighbor;
    }
    private static final int heif_chroma_downsampling_average = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma_downsampling_algorithm.heif_chroma_downsampling_average = 2
     * }
     */
    public static int heif_chroma_downsampling_average() {
        return heif_chroma_downsampling_average;
    }
    private static final int heif_chroma_downsampling_sharp_yuv = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma_downsampling_algorithm.heif_chroma_downsampling_sharp_yuv = 3
     * }
     */
    public static int heif_chroma_downsampling_sharp_yuv() {
        return heif_chroma_downsampling_sharp_yuv;
    }
    private static final int heif_chroma_upsampling_nearest_neighbor = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma_upsampling_algorithm.heif_chroma_upsampling_nearest_neighbor = 1
     * }
     */
    public static int heif_chroma_upsampling_nearest_neighbor() {
        return heif_chroma_upsampling_nearest_neighbor;
    }
    private static final int heif_chroma_upsampling_bilinear = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_chroma_upsampling_algorithm.heif_chroma_upsampling_bilinear = 2
     * }
     */
    public static int heif_chroma_upsampling_bilinear() {
        return heif_chroma_upsampling_bilinear;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * struct heif_decoding_options *heif_decoding_options_alloc()
     * }
     */
    public static class heif_decoding_options_alloc {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                heif_h.C_POINTER        );
        private static final MemorySegment ADDR = heif_h.findOrThrow("heif_decoding_options_alloc");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private heif_decoding_options_alloc(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * struct heif_decoding_options *heif_decoding_options_alloc()
         * }
         */
        public static heif_decoding_options_alloc makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new heif_decoding_options_alloc(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("heif_decoding_options_alloc", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class heif_decoding_options_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_decoding_options_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_decoding_options_free(struct heif_decoding_options *)
     * }
     */
    public static FunctionDescriptor heif_decoding_options_free$descriptor() {
        return heif_decoding_options_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_decoding_options_free(struct heif_decoding_options *)
     * }
     */
    public static MethodHandle heif_decoding_options_free$handle() {
        return heif_decoding_options_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_decoding_options_free(struct heif_decoding_options *)
     * }
     */
    public static MemorySegment heif_decoding_options_free$address() {
        return heif_decoding_options_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_decoding_options_free(struct heif_decoding_options *)
     * }
     */
    public static void heif_decoding_options_free(MemorySegment x0) {
        var mh$ = heif_decoding_options_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_decoding_options_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_decode_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_decode_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_decode_image(const struct heif_image_handle *in_handle, struct heif_image **out_img, enum heif_colorspace colorspace, enum heif_chroma chroma, const struct heif_decoding_options *options)
     * }
     */
    public static FunctionDescriptor heif_decode_image$descriptor() {
        return heif_decode_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_decode_image(const struct heif_image_handle *in_handle, struct heif_image **out_img, enum heif_colorspace colorspace, enum heif_chroma chroma, const struct heif_decoding_options *options)
     * }
     */
    public static MethodHandle heif_decode_image$handle() {
        return heif_decode_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_decode_image(const struct heif_image_handle *in_handle, struct heif_image **out_img, enum heif_colorspace colorspace, enum heif_chroma chroma, const struct heif_decoding_options *options)
     * }
     */
    public static MemorySegment heif_decode_image$address() {
        return heif_decode_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_decode_image(const struct heif_image_handle *in_handle, struct heif_image **out_img, enum heif_colorspace colorspace, enum heif_chroma chroma, const struct heif_decoding_options *options)
     * }
     */
    public static MemorySegment heif_decode_image(SegmentAllocator allocator, MemorySegment in_handle, MemorySegment out_img, int colorspace, int chroma, MemorySegment options) {
        var mh$ = heif_decode_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_decode_image", allocator, in_handle, out_img, colorspace, chroma, options);
            }
            return (MemorySegment)mh$.invokeExact(allocator, in_handle, out_img, colorspace, chroma, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_colorspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_colorspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_colorspace heif_image_get_colorspace(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_get_colorspace$descriptor() {
        return heif_image_get_colorspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_colorspace heif_image_get_colorspace(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_get_colorspace$handle() {
        return heif_image_get_colorspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_colorspace heif_image_get_colorspace(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_get_colorspace$address() {
        return heif_image_get_colorspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_colorspace heif_image_get_colorspace(const struct heif_image *)
     * }
     */
    public static int heif_image_get_colorspace(MemorySegment x0) {
        var mh$ = heif_image_get_colorspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_colorspace", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_chroma_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_chroma_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_chroma heif_image_get_chroma_format(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_get_chroma_format$descriptor() {
        return heif_image_get_chroma_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_chroma heif_image_get_chroma_format(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_get_chroma_format$handle() {
        return heif_image_get_chroma_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_chroma heif_image_get_chroma_format(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_get_chroma_format$address() {
        return heif_image_get_chroma_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_chroma heif_image_get_chroma_format(const struct heif_image *)
     * }
     */
    public static int heif_image_get_chroma_format(MemorySegment x0) {
        var mh$ = heif_image_get_chroma_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_chroma_format", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_width(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static FunctionDescriptor heif_image_get_width$descriptor() {
        return heif_image_get_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_width(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MethodHandle heif_image_get_width$handle() {
        return heif_image_get_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_width(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MemorySegment heif_image_get_width$address() {
        return heif_image_get_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_width(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static int heif_image_get_width(MemorySegment x0, int channel) {
        var mh$ = heif_image_get_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_width", x0, channel);
            }
            return (int)mh$.invokeExact(x0, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_height(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static FunctionDescriptor heif_image_get_height$descriptor() {
        return heif_image_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_height(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MethodHandle heif_image_get_height$handle() {
        return heif_image_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_height(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MemorySegment heif_image_get_height$address() {
        return heif_image_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_height(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static int heif_image_get_height(MemorySegment x0, int channel) {
        var mh$ = heif_image_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_height", x0, channel);
            }
            return (int)mh$.invokeExact(x0, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_primary_width {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_primary_width");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_primary_width(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_get_primary_width$descriptor() {
        return heif_image_get_primary_width.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_primary_width(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_get_primary_width$handle() {
        return heif_image_get_primary_width.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_primary_width(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_get_primary_width$address() {
        return heif_image_get_primary_width.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_primary_width(const struct heif_image *)
     * }
     */
    public static int heif_image_get_primary_width(MemorySegment x0) {
        var mh$ = heif_image_get_primary_width.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_primary_width", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_primary_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_primary_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_primary_height(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_get_primary_height$descriptor() {
        return heif_image_get_primary_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_primary_height(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_get_primary_height$handle() {
        return heif_image_get_primary_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_primary_height(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_get_primary_height$address() {
        return heif_image_get_primary_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_primary_height(const struct heif_image *)
     * }
     */
    public static int heif_image_get_primary_height(MemorySegment x0) {
        var mh$ = heif_image_get_primary_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_primary_height", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_crop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_crop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_crop(struct heif_image *img, int left, int right, int top, int bottom)
     * }
     */
    public static FunctionDescriptor heif_image_crop$descriptor() {
        return heif_image_crop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_crop(struct heif_image *img, int left, int right, int top, int bottom)
     * }
     */
    public static MethodHandle heif_image_crop$handle() {
        return heif_image_crop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_crop(struct heif_image *img, int left, int right, int top, int bottom)
     * }
     */
    public static MemorySegment heif_image_crop$address() {
        return heif_image_crop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_crop(struct heif_image *img, int left, int right, int top, int bottom)
     * }
     */
    public static MemorySegment heif_image_crop(SegmentAllocator allocator, MemorySegment img, int left, int right, int top, int bottom) {
        var mh$ = heif_image_crop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_crop", allocator, img, left, right, top, bottom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, img, left, right, top, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static FunctionDescriptor heif_image_get_bits_per_pixel$descriptor() {
        return heif_image_get_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MethodHandle heif_image_get_bits_per_pixel$handle() {
        return heif_image_get_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MemorySegment heif_image_get_bits_per_pixel$address() {
        return heif_image_get_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static int heif_image_get_bits_per_pixel(MemorySegment x0, int channel) {
        var mh$ = heif_image_get_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_bits_per_pixel", x0, channel);
            }
            return (int)mh$.invokeExact(x0, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_bits_per_pixel_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_bits_per_pixel_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel_range(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static FunctionDescriptor heif_image_get_bits_per_pixel_range$descriptor() {
        return heif_image_get_bits_per_pixel_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel_range(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MethodHandle heif_image_get_bits_per_pixel_range$handle() {
        return heif_image_get_bits_per_pixel_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel_range(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MemorySegment heif_image_get_bits_per_pixel_range$address() {
        return heif_image_get_bits_per_pixel_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_bits_per_pixel_range(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static int heif_image_get_bits_per_pixel_range(MemorySegment x0, int channel) {
        var mh$ = heif_image_get_bits_per_pixel_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_bits_per_pixel_range", x0, channel);
            }
            return (int)mh$.invokeExact(x0, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_has_channel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_has_channel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_has_channel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static FunctionDescriptor heif_image_has_channel$descriptor() {
        return heif_image_has_channel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_has_channel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MethodHandle heif_image_has_channel$handle() {
        return heif_image_has_channel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_has_channel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static MemorySegment heif_image_has_channel$address() {
        return heif_image_has_channel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_has_channel(const struct heif_image *, enum heif_channel channel)
     * }
     */
    public static int heif_image_has_channel(MemorySegment x0, int channel) {
        var mh$ = heif_image_has_channel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_has_channel", x0, channel);
            }
            return (int)mh$.invokeExact(x0, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_plane_readonly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_plane_readonly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const uint8_t *heif_image_get_plane_readonly(const struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static FunctionDescriptor heif_image_get_plane_readonly$descriptor() {
        return heif_image_get_plane_readonly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const uint8_t *heif_image_get_plane_readonly(const struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MethodHandle heif_image_get_plane_readonly$handle() {
        return heif_image_get_plane_readonly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const uint8_t *heif_image_get_plane_readonly(const struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MemorySegment heif_image_get_plane_readonly$address() {
        return heif_image_get_plane_readonly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const uint8_t *heif_image_get_plane_readonly(const struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MemorySegment heif_image_get_plane_readonly(MemorySegment x0, int channel, MemorySegment out_stride) {
        var mh$ = heif_image_get_plane_readonly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_plane_readonly", x0, channel, out_stride);
            }
            return (MemorySegment)mh$.invokeExact(x0, channel, out_stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_plane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_plane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *heif_image_get_plane(struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static FunctionDescriptor heif_image_get_plane$descriptor() {
        return heif_image_get_plane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *heif_image_get_plane(struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MethodHandle heif_image_get_plane$handle() {
        return heif_image_get_plane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *heif_image_get_plane(struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MemorySegment heif_image_get_plane$address() {
        return heif_image_get_plane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *heif_image_get_plane(struct heif_image *, enum heif_channel channel, int *out_stride)
     * }
     */
    public static MemorySegment heif_image_get_plane(MemorySegment x0, int channel, MemorySegment out_stride) {
        var mh$ = heif_image_get_plane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_plane", x0, channel, out_stride);
            }
            return (MemorySegment)mh$.invokeExact(x0, channel, out_stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_scale_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_scale_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_scale_image(const struct heif_image *input, struct heif_image **output, int width, int height, const struct heif_scaling_options *options)
     * }
     */
    public static FunctionDescriptor heif_image_scale_image$descriptor() {
        return heif_image_scale_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_scale_image(const struct heif_image *input, struct heif_image **output, int width, int height, const struct heif_scaling_options *options)
     * }
     */
    public static MethodHandle heif_image_scale_image$handle() {
        return heif_image_scale_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_scale_image(const struct heif_image *input, struct heif_image **output, int width, int height, const struct heif_scaling_options *options)
     * }
     */
    public static MemorySegment heif_image_scale_image$address() {
        return heif_image_scale_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_scale_image(const struct heif_image *input, struct heif_image **output, int width, int height, const struct heif_scaling_options *options)
     * }
     */
    public static MemorySegment heif_image_scale_image(SegmentAllocator allocator, MemorySegment input, MemorySegment output, int width, int height, MemorySegment options) {
        var mh$ = heif_image_scale_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_scale_image", allocator, input, output, width, height, options);
            }
            return (MemorySegment)mh$.invokeExact(allocator, input, output, width, height, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_raw_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_LONG
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_raw_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_raw_color_profile(struct heif_image *image, const char *profile_type_fourcc_string, const void *profile_data, const size_t profile_size)
     * }
     */
    public static FunctionDescriptor heif_image_set_raw_color_profile$descriptor() {
        return heif_image_set_raw_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_raw_color_profile(struct heif_image *image, const char *profile_type_fourcc_string, const void *profile_data, const size_t profile_size)
     * }
     */
    public static MethodHandle heif_image_set_raw_color_profile$handle() {
        return heif_image_set_raw_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_raw_color_profile(struct heif_image *image, const char *profile_type_fourcc_string, const void *profile_data, const size_t profile_size)
     * }
     */
    public static MemorySegment heif_image_set_raw_color_profile$address() {
        return heif_image_set_raw_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_set_raw_color_profile(struct heif_image *image, const char *profile_type_fourcc_string, const void *profile_data, const size_t profile_size)
     * }
     */
    public static MemorySegment heif_image_set_raw_color_profile(SegmentAllocator allocator, MemorySegment image, MemorySegment profile_type_fourcc_string, MemorySegment profile_data, long profile_size) {
        var mh$ = heif_image_set_raw_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_raw_color_profile", allocator, image, profile_type_fourcc_string, profile_data, profile_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, profile_type_fourcc_string, profile_data, profile_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_nclx_color_profile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_nclx_color_profile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_nclx_color_profile(struct heif_image *image, const struct heif_color_profile_nclx *color_profile)
     * }
     */
    public static FunctionDescriptor heif_image_set_nclx_color_profile$descriptor() {
        return heif_image_set_nclx_color_profile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_nclx_color_profile(struct heif_image *image, const struct heif_color_profile_nclx *color_profile)
     * }
     */
    public static MethodHandle heif_image_set_nclx_color_profile$handle() {
        return heif_image_set_nclx_color_profile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_set_nclx_color_profile(struct heif_image *image, const struct heif_color_profile_nclx *color_profile)
     * }
     */
    public static MemorySegment heif_image_set_nclx_color_profile$address() {
        return heif_image_set_nclx_color_profile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_set_nclx_color_profile(struct heif_image *image, const struct heif_color_profile_nclx *color_profile)
     * }
     */
    public static MemorySegment heif_image_set_nclx_color_profile(SegmentAllocator allocator, MemorySegment image, MemorySegment color_profile) {
        var mh$ = heif_image_set_nclx_color_profile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_nclx_color_profile", allocator, image, color_profile);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, color_profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_decoding_warnings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_decoding_warnings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_get_decoding_warnings(struct heif_image *image, int first_warning_idx, struct heif_error *out_warnings, int max_output_buffer_entries)
     * }
     */
    public static FunctionDescriptor heif_image_get_decoding_warnings$descriptor() {
        return heif_image_get_decoding_warnings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_get_decoding_warnings(struct heif_image *image, int first_warning_idx, struct heif_error *out_warnings, int max_output_buffer_entries)
     * }
     */
    public static MethodHandle heif_image_get_decoding_warnings$handle() {
        return heif_image_get_decoding_warnings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_get_decoding_warnings(struct heif_image *image, int first_warning_idx, struct heif_error *out_warnings, int max_output_buffer_entries)
     * }
     */
    public static MemorySegment heif_image_get_decoding_warnings$address() {
        return heif_image_get_decoding_warnings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_get_decoding_warnings(struct heif_image *image, int first_warning_idx, struct heif_error *out_warnings, int max_output_buffer_entries)
     * }
     */
    public static int heif_image_get_decoding_warnings(MemorySegment image, int first_warning_idx, MemorySegment out_warnings, int max_output_buffer_entries) {
        var mh$ = heif_image_get_decoding_warnings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_decoding_warnings", image, first_warning_idx, out_warnings, max_output_buffer_entries);
            }
            return (int)mh$.invokeExact(image, first_warning_idx, out_warnings, max_output_buffer_entries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_add_decoding_warning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_error.layout()
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_add_decoding_warning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_add_decoding_warning(struct heif_image *image, struct heif_error err)
     * }
     */
    public static FunctionDescriptor heif_image_add_decoding_warning$descriptor() {
        return heif_image_add_decoding_warning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_add_decoding_warning(struct heif_image *image, struct heif_error err)
     * }
     */
    public static MethodHandle heif_image_add_decoding_warning$handle() {
        return heif_image_add_decoding_warning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_add_decoding_warning(struct heif_image *image, struct heif_error err)
     * }
     */
    public static MemorySegment heif_image_add_decoding_warning$address() {
        return heif_image_add_decoding_warning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_add_decoding_warning(struct heif_image *image, struct heif_error err)
     * }
     */
    public static void heif_image_add_decoding_warning(MemorySegment image, MemorySegment err) {
        var mh$ = heif_image_add_decoding_warning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_add_decoding_warning", image, err);
            }
            mh$.invokeExact(image, err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_release(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_release$descriptor() {
        return heif_image_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_release(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_release$handle() {
        return heif_image_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_release(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_release$address() {
        return heif_image_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_release(const struct heif_image *)
     * }
     */
    public static void heif_image_release(MemorySegment x0) {
        var mh$ = heif_image_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_has_content_light_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_has_content_light_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_has_content_light_level(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_has_content_light_level$descriptor() {
        return heif_image_has_content_light_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_has_content_light_level(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_has_content_light_level$handle() {
        return heif_image_has_content_light_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_has_content_light_level(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_has_content_light_level$address() {
        return heif_image_has_content_light_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_has_content_light_level(const struct heif_image *)
     * }
     */
    public static int heif_image_has_content_light_level(MemorySegment x0) {
        var mh$ = heif_image_has_content_light_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_has_content_light_level", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_content_light_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_content_light_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_get_content_light_level(const struct heif_image *, struct heif_content_light_level *out)
     * }
     */
    public static FunctionDescriptor heif_image_get_content_light_level$descriptor() {
        return heif_image_get_content_light_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_get_content_light_level(const struct heif_image *, struct heif_content_light_level *out)
     * }
     */
    public static MethodHandle heif_image_get_content_light_level$handle() {
        return heif_image_get_content_light_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_get_content_light_level(const struct heif_image *, struct heif_content_light_level *out)
     * }
     */
    public static MemorySegment heif_image_get_content_light_level$address() {
        return heif_image_get_content_light_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_get_content_light_level(const struct heif_image *, struct heif_content_light_level *out)
     * }
     */
    public static void heif_image_get_content_light_level(MemorySegment x0, MemorySegment out) {
        var mh$ = heif_image_get_content_light_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_content_light_level", x0, out);
            }
            mh$.invokeExact(x0, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_content_light_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_content_light_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_set_content_light_level(const struct heif_image *, const struct heif_content_light_level *in)
     * }
     */
    public static FunctionDescriptor heif_image_set_content_light_level$descriptor() {
        return heif_image_set_content_light_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_set_content_light_level(const struct heif_image *, const struct heif_content_light_level *in)
     * }
     */
    public static MethodHandle heif_image_set_content_light_level$handle() {
        return heif_image_set_content_light_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_set_content_light_level(const struct heif_image *, const struct heif_content_light_level *in)
     * }
     */
    public static MemorySegment heif_image_set_content_light_level$address() {
        return heif_image_set_content_light_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_set_content_light_level(const struct heif_image *, const struct heif_content_light_level *in)
     * }
     */
    public static void heif_image_set_content_light_level(MemorySegment x0, MemorySegment in) {
        var mh$ = heif_image_set_content_light_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_content_light_level", x0, in);
            }
            mh$.invokeExact(x0, in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_has_mastering_display_colour_volume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_has_mastering_display_colour_volume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_has_mastering_display_colour_volume(const struct heif_image *)
     * }
     */
    public static FunctionDescriptor heif_image_has_mastering_display_colour_volume$descriptor() {
        return heif_image_has_mastering_display_colour_volume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_has_mastering_display_colour_volume(const struct heif_image *)
     * }
     */
    public static MethodHandle heif_image_has_mastering_display_colour_volume$handle() {
        return heif_image_has_mastering_display_colour_volume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_has_mastering_display_colour_volume(const struct heif_image *)
     * }
     */
    public static MemorySegment heif_image_has_mastering_display_colour_volume$address() {
        return heif_image_has_mastering_display_colour_volume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_has_mastering_display_colour_volume(const struct heif_image *)
     * }
     */
    public static int heif_image_has_mastering_display_colour_volume(MemorySegment x0) {
        var mh$ = heif_image_has_mastering_display_colour_volume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_has_mastering_display_colour_volume", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_mastering_display_colour_volume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_mastering_display_colour_volume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_get_mastering_display_colour_volume(const struct heif_image *, struct heif_mastering_display_colour_volume *out)
     * }
     */
    public static FunctionDescriptor heif_image_get_mastering_display_colour_volume$descriptor() {
        return heif_image_get_mastering_display_colour_volume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_get_mastering_display_colour_volume(const struct heif_image *, struct heif_mastering_display_colour_volume *out)
     * }
     */
    public static MethodHandle heif_image_get_mastering_display_colour_volume$handle() {
        return heif_image_get_mastering_display_colour_volume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_get_mastering_display_colour_volume(const struct heif_image *, struct heif_mastering_display_colour_volume *out)
     * }
     */
    public static MemorySegment heif_image_get_mastering_display_colour_volume$address() {
        return heif_image_get_mastering_display_colour_volume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_get_mastering_display_colour_volume(const struct heif_image *, struct heif_mastering_display_colour_volume *out)
     * }
     */
    public static void heif_image_get_mastering_display_colour_volume(MemorySegment x0, MemorySegment out) {
        var mh$ = heif_image_get_mastering_display_colour_volume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_mastering_display_colour_volume", x0, out);
            }
            mh$.invokeExact(x0, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_mastering_display_colour_volume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_mastering_display_colour_volume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_set_mastering_display_colour_volume(const struct heif_image *, const struct heif_mastering_display_colour_volume *in)
     * }
     */
    public static FunctionDescriptor heif_image_set_mastering_display_colour_volume$descriptor() {
        return heif_image_set_mastering_display_colour_volume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_set_mastering_display_colour_volume(const struct heif_image *, const struct heif_mastering_display_colour_volume *in)
     * }
     */
    public static MethodHandle heif_image_set_mastering_display_colour_volume$handle() {
        return heif_image_set_mastering_display_colour_volume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_set_mastering_display_colour_volume(const struct heif_image *, const struct heif_mastering_display_colour_volume *in)
     * }
     */
    public static MemorySegment heif_image_set_mastering_display_colour_volume$address() {
        return heif_image_set_mastering_display_colour_volume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_set_mastering_display_colour_volume(const struct heif_image *, const struct heif_mastering_display_colour_volume *in)
     * }
     */
    public static void heif_image_set_mastering_display_colour_volume(MemorySegment x0, MemorySegment in) {
        var mh$ = heif_image_set_mastering_display_colour_volume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_mastering_display_colour_volume", x0, in);
            }
            mh$.invokeExact(x0, in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_mastering_display_colour_volume_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_mastering_display_colour_volume_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_mastering_display_colour_volume_decode(const struct heif_mastering_display_colour_volume *in, struct heif_decoded_mastering_display_colour_volume *out)
     * }
     */
    public static FunctionDescriptor heif_mastering_display_colour_volume_decode$descriptor() {
        return heif_mastering_display_colour_volume_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_mastering_display_colour_volume_decode(const struct heif_mastering_display_colour_volume *in, struct heif_decoded_mastering_display_colour_volume *out)
     * }
     */
    public static MethodHandle heif_mastering_display_colour_volume_decode$handle() {
        return heif_mastering_display_colour_volume_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_mastering_display_colour_volume_decode(const struct heif_mastering_display_colour_volume *in, struct heif_decoded_mastering_display_colour_volume *out)
     * }
     */
    public static MemorySegment heif_mastering_display_colour_volume_decode$address() {
        return heif_mastering_display_colour_volume_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_mastering_display_colour_volume_decode(const struct heif_mastering_display_colour_volume *in, struct heif_decoded_mastering_display_colour_volume *out)
     * }
     */
    public static MemorySegment heif_mastering_display_colour_volume_decode(SegmentAllocator allocator, MemorySegment in, MemorySegment out) {
        var mh$ = heif_mastering_display_colour_volume_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_mastering_display_colour_volume_decode", allocator, in, out);
            }
            return (MemorySegment)mh$.invokeExact(allocator, in, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_get_pixel_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_get_pixel_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_get_pixel_aspect_ratio(const struct heif_image *, uint32_t *aspect_h, uint32_t *aspect_v)
     * }
     */
    public static FunctionDescriptor heif_image_get_pixel_aspect_ratio$descriptor() {
        return heif_image_get_pixel_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_get_pixel_aspect_ratio(const struct heif_image *, uint32_t *aspect_h, uint32_t *aspect_v)
     * }
     */
    public static MethodHandle heif_image_get_pixel_aspect_ratio$handle() {
        return heif_image_get_pixel_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_get_pixel_aspect_ratio(const struct heif_image *, uint32_t *aspect_h, uint32_t *aspect_v)
     * }
     */
    public static MemorySegment heif_image_get_pixel_aspect_ratio$address() {
        return heif_image_get_pixel_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_get_pixel_aspect_ratio(const struct heif_image *, uint32_t *aspect_h, uint32_t *aspect_v)
     * }
     */
    public static void heif_image_get_pixel_aspect_ratio(MemorySegment x0, MemorySegment aspect_h, MemorySegment aspect_v) {
        var mh$ = heif_image_get_pixel_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_get_pixel_aspect_ratio", x0, aspect_h, aspect_v);
            }
            mh$.invokeExact(x0, aspect_h, aspect_v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_pixel_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_pixel_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_set_pixel_aspect_ratio(struct heif_image *, uint32_t aspect_h, uint32_t aspect_v)
     * }
     */
    public static FunctionDescriptor heif_image_set_pixel_aspect_ratio$descriptor() {
        return heif_image_set_pixel_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_set_pixel_aspect_ratio(struct heif_image *, uint32_t aspect_h, uint32_t aspect_v)
     * }
     */
    public static MethodHandle heif_image_set_pixel_aspect_ratio$handle() {
        return heif_image_set_pixel_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_set_pixel_aspect_ratio(struct heif_image *, uint32_t aspect_h, uint32_t aspect_v)
     * }
     */
    public static MemorySegment heif_image_set_pixel_aspect_ratio$address() {
        return heif_image_set_pixel_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_set_pixel_aspect_ratio(struct heif_image *, uint32_t aspect_h, uint32_t aspect_v)
     * }
     */
    public static void heif_image_set_pixel_aspect_ratio(MemorySegment x0, int aspect_h, int aspect_v) {
        var mh$ = heif_image_set_pixel_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_pixel_aspect_ratio", x0, aspect_h, aspect_v);
            }
            mh$.invokeExact(x0, aspect_h, aspect_v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_write_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_write_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write_to_file(struct heif_context *, const char *filename)
     * }
     */
    public static FunctionDescriptor heif_context_write_to_file$descriptor() {
        return heif_context_write_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write_to_file(struct heif_context *, const char *filename)
     * }
     */
    public static MethodHandle heif_context_write_to_file$handle() {
        return heif_context_write_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write_to_file(struct heif_context *, const char *filename)
     * }
     */
    public static MemorySegment heif_context_write_to_file$address() {
        return heif_context_write_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_write_to_file(struct heif_context *, const char *filename)
     * }
     */
    public static MemorySegment heif_context_write_to_file(SegmentAllocator allocator, MemorySegment x0, MemorySegment filename) {
        var mh$ = heif_context_write_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_write_to_file", allocator, x0, filename);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write(struct heif_context *, struct heif_writer *writer, void *userdata)
     * }
     */
    public static FunctionDescriptor heif_context_write$descriptor() {
        return heif_context_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write(struct heif_context *, struct heif_writer *writer, void *userdata)
     * }
     */
    public static MethodHandle heif_context_write$handle() {
        return heif_context_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_write(struct heif_context *, struct heif_writer *writer, void *userdata)
     * }
     */
    public static MemorySegment heif_context_write$address() {
        return heif_context_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_write(struct heif_context *, struct heif_writer *writer, void *userdata)
     * }
     */
    public static MemorySegment heif_context_write(SegmentAllocator allocator, MemorySegment x0, MemorySegment writer, MemorySegment userdata) {
        var mh$ = heif_context_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_write", allocator, x0, writer, userdata);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, writer, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_decoder_descriptors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_decoder_descriptors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_get_decoder_descriptors(enum heif_compression_format format_filter, const struct heif_decoder_descriptor **out_decoders, int count)
     * }
     */
    public static FunctionDescriptor heif_get_decoder_descriptors$descriptor() {
        return heif_get_decoder_descriptors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_get_decoder_descriptors(enum heif_compression_format format_filter, const struct heif_decoder_descriptor **out_decoders, int count)
     * }
     */
    public static MethodHandle heif_get_decoder_descriptors$handle() {
        return heif_get_decoder_descriptors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_get_decoder_descriptors(enum heif_compression_format format_filter, const struct heif_decoder_descriptor **out_decoders, int count)
     * }
     */
    public static MemorySegment heif_get_decoder_descriptors$address() {
        return heif_get_decoder_descriptors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_get_decoder_descriptors(enum heif_compression_format format_filter, const struct heif_decoder_descriptor **out_decoders, int count)
     * }
     */
    public static int heif_get_decoder_descriptors(int format_filter, MemorySegment out_decoders, int count) {
        var mh$ = heif_get_decoder_descriptors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_decoder_descriptors", format_filter, out_decoders, count);
            }
            return (int)mh$.invokeExact(format_filter, out_decoders, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_decoder_descriptor_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_decoder_descriptor_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_decoder_descriptor_get_name$descriptor() {
        return heif_decoder_descriptor_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MethodHandle heif_decoder_descriptor_get_name$handle() {
        return heif_decoder_descriptor_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MemorySegment heif_decoder_descriptor_get_name$address() {
        return heif_decoder_descriptor_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MemorySegment heif_decoder_descriptor_get_name(MemorySegment x0) {
        var mh$ = heif_decoder_descriptor_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_decoder_descriptor_get_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_decoder_descriptor_get_id_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_decoder_descriptor_get_id_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_id_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_decoder_descriptor_get_id_name$descriptor() {
        return heif_decoder_descriptor_get_id_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_id_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MethodHandle heif_decoder_descriptor_get_id_name$handle() {
        return heif_decoder_descriptor_get_id_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_id_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MemorySegment heif_decoder_descriptor_get_id_name$address() {
        return heif_decoder_descriptor_get_id_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_decoder_descriptor_get_id_name(const struct heif_decoder_descriptor *)
     * }
     */
    public static MemorySegment heif_decoder_descriptor_get_id_name(MemorySegment x0) {
        var mh$ = heif_decoder_descriptor_get_id_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_decoder_descriptor_get_id_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_encoder_descriptors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_encoder_descriptors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_context_get_encoder_descriptors(struct heif_context *, enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static FunctionDescriptor heif_context_get_encoder_descriptors$descriptor() {
        return heif_context_get_encoder_descriptors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_context_get_encoder_descriptors(struct heif_context *, enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static MethodHandle heif_context_get_encoder_descriptors$handle() {
        return heif_context_get_encoder_descriptors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_context_get_encoder_descriptors(struct heif_context *, enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static MemorySegment heif_context_get_encoder_descriptors$address() {
        return heif_context_get_encoder_descriptors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_context_get_encoder_descriptors(struct heif_context *, enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static int heif_context_get_encoder_descriptors(MemorySegment x0, int format_filter, MemorySegment name_filter, MemorySegment out_encoders, int count) {
        var mh$ = heif_context_get_encoder_descriptors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_encoder_descriptors", x0, format_filter, name_filter, out_encoders, count);
            }
            return (int)mh$.invokeExact(x0, format_filter, name_filter, out_encoders, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_get_encoder_descriptors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_get_encoder_descriptors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_get_encoder_descriptors(enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static FunctionDescriptor heif_get_encoder_descriptors$descriptor() {
        return heif_get_encoder_descriptors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_get_encoder_descriptors(enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static MethodHandle heif_get_encoder_descriptors$handle() {
        return heif_get_encoder_descriptors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_get_encoder_descriptors(enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static MemorySegment heif_get_encoder_descriptors$address() {
        return heif_get_encoder_descriptors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_get_encoder_descriptors(enum heif_compression_format format_filter, const char *name_filter, const struct heif_encoder_descriptor **out_encoders, int count)
     * }
     */
    public static int heif_get_encoder_descriptors(int format_filter, MemorySegment name_filter, MemorySegment out_encoders, int count) {
        var mh$ = heif_get_encoder_descriptors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_get_encoder_descriptors", format_filter, name_filter, out_encoders, count);
            }
            return (int)mh$.invokeExact(format_filter, name_filter, out_encoders, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_get_name$descriptor() {
        return heif_encoder_descriptor_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_get_name$handle() {
        return heif_encoder_descriptor_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_get_name$address() {
        return heif_encoder_descriptor_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_get_name(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_get_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_get_id_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_get_id_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_id_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_get_id_name$descriptor() {
        return heif_encoder_descriptor_get_id_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_id_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_get_id_name$handle() {
        return heif_encoder_descriptor_get_id_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_id_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_get_id_name$address() {
        return heif_encoder_descriptor_get_id_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_encoder_descriptor_get_id_name(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_get_id_name(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_get_id_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_get_id_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_get_compression_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_get_compression_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_compression_format heif_encoder_descriptor_get_compression_format(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_get_compression_format$descriptor() {
        return heif_encoder_descriptor_get_compression_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_compression_format heif_encoder_descriptor_get_compression_format(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_get_compression_format$handle() {
        return heif_encoder_descriptor_get_compression_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_compression_format heif_encoder_descriptor_get_compression_format(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_get_compression_format$address() {
        return heif_encoder_descriptor_get_compression_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_compression_format heif_encoder_descriptor_get_compression_format(const struct heif_encoder_descriptor *)
     * }
     */
    public static int heif_encoder_descriptor_get_compression_format(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_get_compression_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_get_compression_format", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_supports_lossy_compression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_supports_lossy_compression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_supports_lossy_compression$descriptor() {
        return heif_encoder_descriptor_supports_lossy_compression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_supports_lossy_compression$handle() {
        return heif_encoder_descriptor_supports_lossy_compression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_supports_lossy_compression$address() {
        return heif_encoder_descriptor_supports_lossy_compression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static int heif_encoder_descriptor_supports_lossy_compression(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_supports_lossy_compression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_supports_lossy_compression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_supports_lossless_compression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_supports_lossless_compression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_supports_lossless_compression$descriptor() {
        return heif_encoder_descriptor_supports_lossless_compression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_supports_lossless_compression$handle() {
        return heif_encoder_descriptor_supports_lossless_compression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_supports_lossless_compression$address() {
        return heif_encoder_descriptor_supports_lossless_compression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supports_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static int heif_encoder_descriptor_supports_lossless_compression(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_supports_lossless_compression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_supports_lossless_compression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder(struct heif_context *context, const struct heif_encoder_descriptor *, struct heif_encoder **out_encoder)
     * }
     */
    public static FunctionDescriptor heif_context_get_encoder$descriptor() {
        return heif_context_get_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder(struct heif_context *context, const struct heif_encoder_descriptor *, struct heif_encoder **out_encoder)
     * }
     */
    public static MethodHandle heif_context_get_encoder$handle() {
        return heif_context_get_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder(struct heif_context *context, const struct heif_encoder_descriptor *, struct heif_encoder **out_encoder)
     * }
     */
    public static MemorySegment heif_context_get_encoder$address() {
        return heif_context_get_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder(struct heif_context *context, const struct heif_encoder_descriptor *, struct heif_encoder **out_encoder)
     * }
     */
    public static MemorySegment heif_context_get_encoder(SegmentAllocator allocator, MemorySegment context, MemorySegment x1, MemorySegment out_encoder) {
        var mh$ = heif_context_get_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_encoder", allocator, context, x1, out_encoder);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context, x1, out_encoder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_have_decoder_for_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_have_decoder_for_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_have_decoder_for_format(enum heif_compression_format format)
     * }
     */
    public static FunctionDescriptor heif_have_decoder_for_format$descriptor() {
        return heif_have_decoder_for_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_have_decoder_for_format(enum heif_compression_format format)
     * }
     */
    public static MethodHandle heif_have_decoder_for_format$handle() {
        return heif_have_decoder_for_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_have_decoder_for_format(enum heif_compression_format format)
     * }
     */
    public static MemorySegment heif_have_decoder_for_format$address() {
        return heif_have_decoder_for_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_have_decoder_for_format(enum heif_compression_format format)
     * }
     */
    public static int heif_have_decoder_for_format(int format) {
        var mh$ = heif_have_decoder_for_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_have_decoder_for_format", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_have_encoder_for_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_have_encoder_for_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_have_encoder_for_format(enum heif_compression_format format)
     * }
     */
    public static FunctionDescriptor heif_have_encoder_for_format$descriptor() {
        return heif_have_encoder_for_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_have_encoder_for_format(enum heif_compression_format format)
     * }
     */
    public static MethodHandle heif_have_encoder_for_format$handle() {
        return heif_have_encoder_for_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_have_encoder_for_format(enum heif_compression_format format)
     * }
     */
    public static MemorySegment heif_have_encoder_for_format$address() {
        return heif_have_encoder_for_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_have_encoder_for_format(enum heif_compression_format format)
     * }
     */
    public static int heif_have_encoder_for_format(int format) {
        var mh$ = heif_have_encoder_for_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_have_encoder_for_format", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_encoder_for_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_encoder_for_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder_for_format(struct heif_context *context, enum heif_compression_format format, struct heif_encoder **)
     * }
     */
    public static FunctionDescriptor heif_context_get_encoder_for_format$descriptor() {
        return heif_context_get_encoder_for_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder_for_format(struct heif_context *context, enum heif_compression_format format, struct heif_encoder **)
     * }
     */
    public static MethodHandle heif_context_get_encoder_for_format$handle() {
        return heif_context_get_encoder_for_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder_for_format(struct heif_context *context, enum heif_compression_format format, struct heif_encoder **)
     * }
     */
    public static MemorySegment heif_context_get_encoder_for_format$address() {
        return heif_context_get_encoder_for_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_encoder_for_format(struct heif_context *context, enum heif_compression_format format, struct heif_encoder **)
     * }
     */
    public static MemorySegment heif_context_get_encoder_for_format(SegmentAllocator allocator, MemorySegment context, int format, MemorySegment x2) {
        var mh$ = heif_context_get_encoder_for_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_encoder_for_format", allocator, context, format, x2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context, format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_encoder_release(struct heif_encoder *)
     * }
     */
    public static FunctionDescriptor heif_encoder_release$descriptor() {
        return heif_encoder_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_encoder_release(struct heif_encoder *)
     * }
     */
    public static MethodHandle heif_encoder_release$handle() {
        return heif_encoder_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_encoder_release(struct heif_encoder *)
     * }
     */
    public static MemorySegment heif_encoder_release$address() {
        return heif_encoder_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_encoder_release(struct heif_encoder *)
     * }
     */
    public static void heif_encoder_release(MemorySegment x0) {
        var mh$ = heif_encoder_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_encoder_get_name(const struct heif_encoder *)
     * }
     */
    public static FunctionDescriptor heif_encoder_get_name$descriptor() {
        return heif_encoder_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_encoder_get_name(const struct heif_encoder *)
     * }
     */
    public static MethodHandle heif_encoder_get_name$handle() {
        return heif_encoder_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_encoder_get_name(const struct heif_encoder *)
     * }
     */
    public static MemorySegment heif_encoder_get_name$address() {
        return heif_encoder_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_encoder_get_name(const struct heif_encoder *)
     * }
     */
    public static MemorySegment heif_encoder_get_name(MemorySegment x0) {
        var mh$ = heif_encoder_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_get_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_lossy_quality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_lossy_quality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossy_quality(struct heif_encoder *, int quality)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_lossy_quality$descriptor() {
        return heif_encoder_set_lossy_quality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossy_quality(struct heif_encoder *, int quality)
     * }
     */
    public static MethodHandle heif_encoder_set_lossy_quality$handle() {
        return heif_encoder_set_lossy_quality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossy_quality(struct heif_encoder *, int quality)
     * }
     */
    public static MemorySegment heif_encoder_set_lossy_quality$address() {
        return heif_encoder_set_lossy_quality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossy_quality(struct heif_encoder *, int quality)
     * }
     */
    public static MemorySegment heif_encoder_set_lossy_quality(SegmentAllocator allocator, MemorySegment x0, int quality) {
        var mh$ = heif_encoder_set_lossy_quality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_lossy_quality", allocator, x0, quality);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, quality);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_lossless {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_lossless");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossless(struct heif_encoder *, int enable)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_lossless$descriptor() {
        return heif_encoder_set_lossless.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossless(struct heif_encoder *, int enable)
     * }
     */
    public static MethodHandle heif_encoder_set_lossless$handle() {
        return heif_encoder_set_lossless.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossless(struct heif_encoder *, int enable)
     * }
     */
    public static MemorySegment heif_encoder_set_lossless$address() {
        return heif_encoder_set_lossless.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_lossless(struct heif_encoder *, int enable)
     * }
     */
    public static MemorySegment heif_encoder_set_lossless(SegmentAllocator allocator, MemorySegment x0, int enable) {
        var mh$ = heif_encoder_set_lossless.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_lossless", allocator, x0, enable);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_logging_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_logging_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_logging_level(struct heif_encoder *, int level)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_logging_level$descriptor() {
        return heif_encoder_set_logging_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_logging_level(struct heif_encoder *, int level)
     * }
     */
    public static MethodHandle heif_encoder_set_logging_level$handle() {
        return heif_encoder_set_logging_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_logging_level(struct heif_encoder *, int level)
     * }
     */
    public static MemorySegment heif_encoder_set_logging_level$address() {
        return heif_encoder_set_logging_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_logging_level(struct heif_encoder *, int level)
     * }
     */
    public static MemorySegment heif_encoder_set_logging_level(SegmentAllocator allocator, MemorySegment x0, int level) {
        var mh$ = heif_encoder_set_logging_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_logging_level", allocator, x0, level);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_list_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_list_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct heif_encoder_parameter *const *heif_encoder_list_parameters(struct heif_encoder *)
     * }
     */
    public static FunctionDescriptor heif_encoder_list_parameters$descriptor() {
        return heif_encoder_list_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct heif_encoder_parameter *const *heif_encoder_list_parameters(struct heif_encoder *)
     * }
     */
    public static MethodHandle heif_encoder_list_parameters$handle() {
        return heif_encoder_list_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct heif_encoder_parameter *const *heif_encoder_list_parameters(struct heif_encoder *)
     * }
     */
    public static MemorySegment heif_encoder_list_parameters$address() {
        return heif_encoder_list_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct heif_encoder_parameter *const *heif_encoder_list_parameters(struct heif_encoder *)
     * }
     */
    public static MemorySegment heif_encoder_list_parameters(MemorySegment x0) {
        var mh$ = heif_encoder_list_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_list_parameters", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *heif_encoder_parameter_get_name(const struct heif_encoder_parameter *)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_get_name$descriptor() {
        return heif_encoder_parameter_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *heif_encoder_parameter_get_name(const struct heif_encoder_parameter *)
     * }
     */
    public static MethodHandle heif_encoder_parameter_get_name$handle() {
        return heif_encoder_parameter_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *heif_encoder_parameter_get_name(const struct heif_encoder_parameter *)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_name$address() {
        return heif_encoder_parameter_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *heif_encoder_parameter_get_name(const struct heif_encoder_parameter *)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_name(MemorySegment x0) {
        var mh$ = heif_encoder_parameter_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_get_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_encoder_parameter_type_integer = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type.heif_encoder_parameter_type_integer = 1
     * }
     */
    public static int heif_encoder_parameter_type_integer() {
        return heif_encoder_parameter_type_integer;
    }
    private static final int heif_encoder_parameter_type_boolean = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type.heif_encoder_parameter_type_boolean = 2
     * }
     */
    public static int heif_encoder_parameter_type_boolean() {
        return heif_encoder_parameter_type_boolean;
    }
    private static final int heif_encoder_parameter_type_string = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type.heif_encoder_parameter_type_string = 3
     * }
     */
    public static int heif_encoder_parameter_type_string() {
        return heif_encoder_parameter_type_string;
    }

    private static class heif_encoder_parameter_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type heif_encoder_parameter_get_type(const struct heif_encoder_parameter *)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_get_type$descriptor() {
        return heif_encoder_parameter_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type heif_encoder_parameter_get_type(const struct heif_encoder_parameter *)
     * }
     */
    public static MethodHandle heif_encoder_parameter_get_type$handle() {
        return heif_encoder_parameter_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type heif_encoder_parameter_get_type(const struct heif_encoder_parameter *)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_type$address() {
        return heif_encoder_parameter_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_encoder_parameter_type heif_encoder_parameter_get_type(const struct heif_encoder_parameter *)
     * }
     */
    public static int heif_encoder_parameter_get_type(MemorySegment x0) {
        var mh$ = heif_encoder_parameter_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_get_type", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_get_valid_integer_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_get_valid_integer_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_range(const struct heif_encoder_parameter *, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_get_valid_integer_range$descriptor() {
        return heif_encoder_parameter_get_valid_integer_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_range(const struct heif_encoder_parameter *, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MethodHandle heif_encoder_parameter_get_valid_integer_range$handle() {
        return heif_encoder_parameter_get_valid_integer_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_range(const struct heif_encoder_parameter *, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_integer_range$address() {
        return heif_encoder_parameter_get_valid_integer_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_range(const struct heif_encoder_parameter *, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_integer_range(SegmentAllocator allocator, MemorySegment x0, MemorySegment have_minimum_maximum, MemorySegment minimum, MemorySegment maximum) {
        var mh$ = heif_encoder_parameter_get_valid_integer_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_get_valid_integer_range", allocator, x0, have_minimum_maximum, minimum, maximum);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, have_minimum_maximum, minimum, maximum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_get_valid_integer_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_get_valid_integer_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_values(const struct heif_encoder_parameter *, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_get_valid_integer_values$descriptor() {
        return heif_encoder_parameter_get_valid_integer_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_values(const struct heif_encoder_parameter *, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MethodHandle heif_encoder_parameter_get_valid_integer_values$handle() {
        return heif_encoder_parameter_get_valid_integer_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_values(const struct heif_encoder_parameter *, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_integer_values$address() {
        return heif_encoder_parameter_get_valid_integer_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_integer_values(const struct heif_encoder_parameter *, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_integer_values(SegmentAllocator allocator, MemorySegment x0, MemorySegment have_minimum, MemorySegment have_maximum, MemorySegment minimum, MemorySegment maximum, MemorySegment num_valid_values, MemorySegment out_integer_array) {
        var mh$ = heif_encoder_parameter_get_valid_integer_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_get_valid_integer_values", allocator, x0, have_minimum, have_maximum, minimum, maximum, num_valid_values, out_integer_array);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, have_minimum, have_maximum, minimum, maximum, num_valid_values, out_integer_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_get_valid_string_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_get_valid_string_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_string_values(const struct heif_encoder_parameter *, const char *const **out_stringarray)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_get_valid_string_values$descriptor() {
        return heif_encoder_parameter_get_valid_string_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_string_values(const struct heif_encoder_parameter *, const char *const **out_stringarray)
     * }
     */
    public static MethodHandle heif_encoder_parameter_get_valid_string_values$handle() {
        return heif_encoder_parameter_get_valid_string_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_string_values(const struct heif_encoder_parameter *, const char *const **out_stringarray)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_string_values$address() {
        return heif_encoder_parameter_get_valid_string_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_get_valid_string_values(const struct heif_encoder_parameter *, const char *const **out_stringarray)
     * }
     */
    public static MemorySegment heif_encoder_parameter_get_valid_string_values(SegmentAllocator allocator, MemorySegment x0, MemorySegment out_stringarray) {
        var mh$ = heif_encoder_parameter_get_valid_string_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_get_valid_string_values", allocator, x0, out_stringarray);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, out_stringarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_parameter_integer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_parameter_integer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_integer(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_parameter_integer$descriptor() {
        return heif_encoder_set_parameter_integer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_integer(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MethodHandle heif_encoder_set_parameter_integer$handle() {
        return heif_encoder_set_parameter_integer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_integer(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_integer$address() {
        return heif_encoder_set_parameter_integer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_integer(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_integer(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, int value) {
        var mh$ = heif_encoder_set_parameter_integer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_parameter_integer", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_get_parameter_integer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_get_parameter_integer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_integer(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static FunctionDescriptor heif_encoder_get_parameter_integer$descriptor() {
        return heif_encoder_get_parameter_integer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_integer(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MethodHandle heif_encoder_get_parameter_integer$handle() {
        return heif_encoder_get_parameter_integer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_integer(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_integer$address() {
        return heif_encoder_get_parameter_integer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_integer(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_integer(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value) {
        var mh$ = heif_encoder_get_parameter_integer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_get_parameter_integer", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_integer_valid_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_integer_valid_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_range(struct heif_encoder *, const char *parameter_name, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_integer_valid_range$descriptor() {
        return heif_encoder_parameter_integer_valid_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_range(struct heif_encoder *, const char *parameter_name, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MethodHandle heif_encoder_parameter_integer_valid_range$handle() {
        return heif_encoder_parameter_integer_valid_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_range(struct heif_encoder *, const char *parameter_name, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MemorySegment heif_encoder_parameter_integer_valid_range$address() {
        return heif_encoder_parameter_integer_valid_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_range(struct heif_encoder *, const char *parameter_name, int *have_minimum_maximum, int *minimum, int *maximum)
     * }
     */
    public static MemorySegment heif_encoder_parameter_integer_valid_range(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment have_minimum_maximum, MemorySegment minimum, MemorySegment maximum) {
        var mh$ = heif_encoder_parameter_integer_valid_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_integer_valid_range", allocator, x0, parameter_name, have_minimum_maximum, minimum, maximum);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, have_minimum_maximum, minimum, maximum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_parameter_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_parameter_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_boolean(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_parameter_boolean$descriptor() {
        return heif_encoder_set_parameter_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_boolean(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MethodHandle heif_encoder_set_parameter_boolean$handle() {
        return heif_encoder_set_parameter_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_boolean(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_boolean$address() {
        return heif_encoder_set_parameter_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_boolean(struct heif_encoder *, const char *parameter_name, int value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_boolean(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, int value) {
        var mh$ = heif_encoder_set_parameter_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_parameter_boolean", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_get_parameter_boolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_get_parameter_boolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_boolean(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static FunctionDescriptor heif_encoder_get_parameter_boolean$descriptor() {
        return heif_encoder_get_parameter_boolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_boolean(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MethodHandle heif_encoder_get_parameter_boolean$handle() {
        return heif_encoder_get_parameter_boolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_boolean(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_boolean$address() {
        return heif_encoder_get_parameter_boolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_boolean(struct heif_encoder *, const char *parameter_name, int *value)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_boolean(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value) {
        var mh$ = heif_encoder_get_parameter_boolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_get_parameter_boolean", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_parameter_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_parameter_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_string(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_parameter_string$descriptor() {
        return heif_encoder_set_parameter_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_string(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MethodHandle heif_encoder_set_parameter_string$handle() {
        return heif_encoder_set_parameter_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_string(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_string$address() {
        return heif_encoder_set_parameter_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter_string(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter_string(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value) {
        var mh$ = heif_encoder_set_parameter_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_parameter_string", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_get_parameter_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_get_parameter_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_string(struct heif_encoder *, const char *parameter_name, char *value, int value_size)
     * }
     */
    public static FunctionDescriptor heif_encoder_get_parameter_string$descriptor() {
        return heif_encoder_get_parameter_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_string(struct heif_encoder *, const char *parameter_name, char *value, int value_size)
     * }
     */
    public static MethodHandle heif_encoder_get_parameter_string$handle() {
        return heif_encoder_get_parameter_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_string(struct heif_encoder *, const char *parameter_name, char *value, int value_size)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_string$address() {
        return heif_encoder_get_parameter_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter_string(struct heif_encoder *, const char *parameter_name, char *value, int value_size)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter_string(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value, int value_size) {
        var mh$ = heif_encoder_get_parameter_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_get_parameter_string", allocator, x0, parameter_name, value, value_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_string_valid_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_string_valid_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_string_valid_values(struct heif_encoder *, const char *parameter_name, const char *const **out_stringarray)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_string_valid_values$descriptor() {
        return heif_encoder_parameter_string_valid_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_string_valid_values(struct heif_encoder *, const char *parameter_name, const char *const **out_stringarray)
     * }
     */
    public static MethodHandle heif_encoder_parameter_string_valid_values$handle() {
        return heif_encoder_parameter_string_valid_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_string_valid_values(struct heif_encoder *, const char *parameter_name, const char *const **out_stringarray)
     * }
     */
    public static MemorySegment heif_encoder_parameter_string_valid_values$address() {
        return heif_encoder_parameter_string_valid_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_string_valid_values(struct heif_encoder *, const char *parameter_name, const char *const **out_stringarray)
     * }
     */
    public static MemorySegment heif_encoder_parameter_string_valid_values(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment out_stringarray) {
        var mh$ = heif_encoder_parameter_string_valid_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_string_valid_values", allocator, x0, parameter_name, out_stringarray);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, out_stringarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_parameter_integer_valid_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_parameter_integer_valid_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_values(struct heif_encoder *, const char *parameter_name, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static FunctionDescriptor heif_encoder_parameter_integer_valid_values$descriptor() {
        return heif_encoder_parameter_integer_valid_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_values(struct heif_encoder *, const char *parameter_name, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MethodHandle heif_encoder_parameter_integer_valid_values$handle() {
        return heif_encoder_parameter_integer_valid_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_values(struct heif_encoder *, const char *parameter_name, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MemorySegment heif_encoder_parameter_integer_valid_values$address() {
        return heif_encoder_parameter_integer_valid_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_parameter_integer_valid_values(struct heif_encoder *, const char *parameter_name, int *have_minimum, int *have_maximum, int *minimum, int *maximum, int *num_valid_values, const int **out_integer_array)
     * }
     */
    public static MemorySegment heif_encoder_parameter_integer_valid_values(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment have_minimum, MemorySegment have_maximum, MemorySegment minimum, MemorySegment maximum, MemorySegment num_valid_values, MemorySegment out_integer_array) {
        var mh$ = heif_encoder_parameter_integer_valid_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_parameter_integer_valid_values", allocator, x0, parameter_name, have_minimum, have_maximum, minimum, maximum, num_valid_values, out_integer_array);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, have_minimum, have_maximum, minimum, maximum, num_valid_values, out_integer_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_set_parameter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_set_parameter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static FunctionDescriptor heif_encoder_set_parameter$descriptor() {
        return heif_encoder_set_parameter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MethodHandle heif_encoder_set_parameter$handle() {
        return heif_encoder_set_parameter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter$address() {
        return heif_encoder_set_parameter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_set_parameter(struct heif_encoder *, const char *parameter_name, const char *value)
     * }
     */
    public static MemorySegment heif_encoder_set_parameter(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value) {
        var mh$ = heif_encoder_set_parameter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_set_parameter", allocator, x0, parameter_name, value);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_get_parameter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_get_parameter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter(struct heif_encoder *, const char *parameter_name, char *value_ptr, int value_size)
     * }
     */
    public static FunctionDescriptor heif_encoder_get_parameter$descriptor() {
        return heif_encoder_get_parameter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter(struct heif_encoder *, const char *parameter_name, char *value_ptr, int value_size)
     * }
     */
    public static MethodHandle heif_encoder_get_parameter$handle() {
        return heif_encoder_get_parameter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter(struct heif_encoder *, const char *parameter_name, char *value_ptr, int value_size)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter$address() {
        return heif_encoder_get_parameter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_encoder_get_parameter(struct heif_encoder *, const char *parameter_name, char *value_ptr, int value_size)
     * }
     */
    public static MemorySegment heif_encoder_get_parameter(SegmentAllocator allocator, MemorySegment x0, MemorySegment parameter_name, MemorySegment value_ptr, int value_size) {
        var mh$ = heif_encoder_get_parameter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_get_parameter", allocator, x0, parameter_name, value_ptr, value_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, parameter_name, value_ptr, value_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_has_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_has_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_encoder_has_default(struct heif_encoder *, const char *parameter_name)
     * }
     */
    public static FunctionDescriptor heif_encoder_has_default$descriptor() {
        return heif_encoder_has_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_encoder_has_default(struct heif_encoder *, const char *parameter_name)
     * }
     */
    public static MethodHandle heif_encoder_has_default$handle() {
        return heif_encoder_has_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_encoder_has_default(struct heif_encoder *, const char *parameter_name)
     * }
     */
    public static MemorySegment heif_encoder_has_default$address() {
        return heif_encoder_has_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_encoder_has_default(struct heif_encoder *, const char *parameter_name)
     * }
     */
    public static int heif_encoder_has_default(MemorySegment x0, MemorySegment parameter_name) {
        var mh$ = heif_encoder_has_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_has_default", x0, parameter_name);
            }
            return (int)mh$.invokeExact(x0, parameter_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_orientation_normal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_normal = 1
     * }
     */
    public static int heif_orientation_normal() {
        return heif_orientation_normal;
    }
    private static final int heif_orientation_flip_horizontally = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_flip_horizontally = 2
     * }
     */
    public static int heif_orientation_flip_horizontally() {
        return heif_orientation_flip_horizontally;
    }
    private static final int heif_orientation_rotate_180 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_rotate_180 = 3
     * }
     */
    public static int heif_orientation_rotate_180() {
        return heif_orientation_rotate_180;
    }
    private static final int heif_orientation_flip_vertically = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_flip_vertically = 4
     * }
     */
    public static int heif_orientation_flip_vertically() {
        return heif_orientation_flip_vertically;
    }
    private static final int heif_orientation_rotate_90_cw_then_flip_horizontally = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_rotate_90_cw_then_flip_horizontally = 5
     * }
     */
    public static int heif_orientation_rotate_90_cw_then_flip_horizontally() {
        return heif_orientation_rotate_90_cw_then_flip_horizontally;
    }
    private static final int heif_orientation_rotate_90_cw = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_rotate_90_cw = 6
     * }
     */
    public static int heif_orientation_rotate_90_cw() {
        return heif_orientation_rotate_90_cw;
    }
    private static final int heif_orientation_rotate_90_cw_then_flip_vertically = (int)7L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_rotate_90_cw_then_flip_vertically = 7
     * }
     */
    public static int heif_orientation_rotate_90_cw_then_flip_vertically() {
        return heif_orientation_rotate_90_cw_then_flip_vertically;
    }
    private static final int heif_orientation_rotate_270_cw = (int)8L;
    /**
     * {@snippet lang=c :
     * enum heif_orientation.heif_orientation_rotate_270_cw = 8
     * }
     */
    public static int heif_orientation_rotate_270_cw() {
        return heif_orientation_rotate_270_cw;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * struct heif_encoding_options *heif_encoding_options_alloc()
     * }
     */
    public static class heif_encoding_options_alloc {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                heif_h.C_POINTER        );
        private static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoding_options_alloc");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private heif_encoding_options_alloc(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * struct heif_encoding_options *heif_encoding_options_alloc()
         * }
         */
        public static heif_encoding_options_alloc makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new heif_encoding_options_alloc(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("heif_encoding_options_alloc", x0);
                }
                return (MemorySegment)spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class heif_encoding_options_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoding_options_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_encoding_options_free(struct heif_encoding_options *)
     * }
     */
    public static FunctionDescriptor heif_encoding_options_free$descriptor() {
        return heif_encoding_options_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_encoding_options_free(struct heif_encoding_options *)
     * }
     */
    public static MethodHandle heif_encoding_options_free$handle() {
        return heif_encoding_options_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_encoding_options_free(struct heif_encoding_options *)
     * }
     */
    public static MemorySegment heif_encoding_options_free$address() {
        return heif_encoding_options_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_encoding_options_free(struct heif_encoding_options *)
     * }
     */
    public static void heif_encoding_options_free(MemorySegment x0) {
        var mh$ = heif_encoding_options_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoding_options_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_encode_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_encode_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_image(struct heif_context *, const struct heif_image *image, struct heif_encoder *encoder, const struct heif_encoding_options *options, struct heif_image_handle **out_image_handle)
     * }
     */
    public static FunctionDescriptor heif_context_encode_image$descriptor() {
        return heif_context_encode_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_image(struct heif_context *, const struct heif_image *image, struct heif_encoder *encoder, const struct heif_encoding_options *options, struct heif_image_handle **out_image_handle)
     * }
     */
    public static MethodHandle heif_context_encode_image$handle() {
        return heif_context_encode_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_image(struct heif_context *, const struct heif_image *image, struct heif_encoder *encoder, const struct heif_encoding_options *options, struct heif_image_handle **out_image_handle)
     * }
     */
    public static MemorySegment heif_context_encode_image$address() {
        return heif_context_encode_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_image(struct heif_context *, const struct heif_image *image, struct heif_encoder *encoder, const struct heif_encoding_options *options, struct heif_image_handle **out_image_handle)
     * }
     */
    public static MemorySegment heif_context_encode_image(SegmentAllocator allocator, MemorySegment x0, MemorySegment image, MemorySegment encoder, MemorySegment options, MemorySegment out_image_handle) {
        var mh$ = heif_context_encode_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_encode_image", allocator, x0, image, encoder, options, out_image_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image, encoder, options, out_image_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_set_primary_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_set_primary_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_set_primary_image(struct heif_context *, struct heif_image_handle *image_handle)
     * }
     */
    public static FunctionDescriptor heif_context_set_primary_image$descriptor() {
        return heif_context_set_primary_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_set_primary_image(struct heif_context *, struct heif_image_handle *image_handle)
     * }
     */
    public static MethodHandle heif_context_set_primary_image$handle() {
        return heif_context_set_primary_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_set_primary_image(struct heif_context *, struct heif_image_handle *image_handle)
     * }
     */
    public static MemorySegment heif_context_set_primary_image$address() {
        return heif_context_set_primary_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_set_primary_image(struct heif_context *, struct heif_image_handle *image_handle)
     * }
     */
    public static MemorySegment heif_context_set_primary_image(SegmentAllocator allocator, MemorySegment x0, MemorySegment image_handle) {
        var mh$ = heif_context_set_primary_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_set_primary_image", allocator, x0, image_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_encode_thumbnail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_encode_thumbnail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_thumbnail(struct heif_context *, const struct heif_image *image, const struct heif_image_handle *master_image_handle, struct heif_encoder *encoder, const struct heif_encoding_options *options, int bbox_size, struct heif_image_handle **out_thumb_image_handle)
     * }
     */
    public static FunctionDescriptor heif_context_encode_thumbnail$descriptor() {
        return heif_context_encode_thumbnail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_thumbnail(struct heif_context *, const struct heif_image *image, const struct heif_image_handle *master_image_handle, struct heif_encoder *encoder, const struct heif_encoding_options *options, int bbox_size, struct heif_image_handle **out_thumb_image_handle)
     * }
     */
    public static MethodHandle heif_context_encode_thumbnail$handle() {
        return heif_context_encode_thumbnail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_thumbnail(struct heif_context *, const struct heif_image *image, const struct heif_image_handle *master_image_handle, struct heif_encoder *encoder, const struct heif_encoding_options *options, int bbox_size, struct heif_image_handle **out_thumb_image_handle)
     * }
     */
    public static MemorySegment heif_context_encode_thumbnail$address() {
        return heif_context_encode_thumbnail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_encode_thumbnail(struct heif_context *, const struct heif_image *image, const struct heif_image_handle *master_image_handle, struct heif_encoder *encoder, const struct heif_encoding_options *options, int bbox_size, struct heif_image_handle **out_thumb_image_handle)
     * }
     */
    public static MemorySegment heif_context_encode_thumbnail(SegmentAllocator allocator, MemorySegment x0, MemorySegment image, MemorySegment master_image_handle, MemorySegment encoder, MemorySegment options, int bbox_size, MemorySegment out_thumb_image_handle) {
        var mh$ = heif_context_encode_thumbnail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_encode_thumbnail", allocator, x0, image, master_image_handle, encoder, options, bbox_size, out_thumb_image_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image, master_image_handle, encoder, options, bbox_size, out_thumb_image_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_metadata_compression_off = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_metadata_compression.heif_metadata_compression_off = 0
     * }
     */
    public static int heif_metadata_compression_off() {
        return heif_metadata_compression_off;
    }
    private static final int heif_metadata_compression_auto = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_metadata_compression.heif_metadata_compression_auto = 1
     * }
     */
    public static int heif_metadata_compression_auto() {
        return heif_metadata_compression_auto;
    }
    private static final int heif_metadata_compression_deflate = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_metadata_compression.heif_metadata_compression_deflate = 2
     * }
     */
    public static int heif_metadata_compression_deflate() {
        return heif_metadata_compression_deflate;
    }

    private static class heif_context_assign_thumbnail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_assign_thumbnail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_assign_thumbnail(struct heif_context *, const struct heif_image_handle *master_image, const struct heif_image_handle *thumbnail_image)
     * }
     */
    public static FunctionDescriptor heif_context_assign_thumbnail$descriptor() {
        return heif_context_assign_thumbnail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_assign_thumbnail(struct heif_context *, const struct heif_image_handle *master_image, const struct heif_image_handle *thumbnail_image)
     * }
     */
    public static MethodHandle heif_context_assign_thumbnail$handle() {
        return heif_context_assign_thumbnail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_assign_thumbnail(struct heif_context *, const struct heif_image_handle *master_image, const struct heif_image_handle *thumbnail_image)
     * }
     */
    public static MemorySegment heif_context_assign_thumbnail$address() {
        return heif_context_assign_thumbnail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_assign_thumbnail(struct heif_context *, const struct heif_image_handle *master_image, const struct heif_image_handle *thumbnail_image)
     * }
     */
    public static MemorySegment heif_context_assign_thumbnail(SegmentAllocator allocator, MemorySegment x0, MemorySegment master_image, MemorySegment thumbnail_image) {
        var mh$ = heif_context_assign_thumbnail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_assign_thumbnail", allocator, x0, master_image, thumbnail_image);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, master_image, thumbnail_image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_add_exif_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_add_exif_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_exif_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static FunctionDescriptor heif_context_add_exif_metadata$descriptor() {
        return heif_context_add_exif_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_exif_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MethodHandle heif_context_add_exif_metadata$handle() {
        return heif_context_add_exif_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_exif_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MemorySegment heif_context_add_exif_metadata$address() {
        return heif_context_add_exif_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_add_exif_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MemorySegment heif_context_add_exif_metadata(SegmentAllocator allocator, MemorySegment x0, MemorySegment image_handle, MemorySegment data, int size) {
        var mh$ = heif_context_add_exif_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_add_exif_metadata", allocator, x0, image_handle, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image_handle, data, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_add_XMP_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_add_XMP_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static FunctionDescriptor heif_context_add_XMP_metadata$descriptor() {
        return heif_context_add_XMP_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MethodHandle heif_context_add_XMP_metadata$handle() {
        return heif_context_add_XMP_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MemorySegment heif_context_add_XMP_metadata$address() {
        return heif_context_add_XMP_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size)
     * }
     */
    public static MemorySegment heif_context_add_XMP_metadata(SegmentAllocator allocator, MemorySegment x0, MemorySegment image_handle, MemorySegment data, int size) {
        var mh$ = heif_context_add_XMP_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_add_XMP_metadata", allocator, x0, image_handle, data, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image_handle, data, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_add_XMP_metadata2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_add_XMP_metadata2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata2(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size, enum heif_metadata_compression compression)
     * }
     */
    public static FunctionDescriptor heif_context_add_XMP_metadata2$descriptor() {
        return heif_context_add_XMP_metadata2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata2(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size, enum heif_metadata_compression compression)
     * }
     */
    public static MethodHandle heif_context_add_XMP_metadata2$handle() {
        return heif_context_add_XMP_metadata2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata2(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size, enum heif_metadata_compression compression)
     * }
     */
    public static MemorySegment heif_context_add_XMP_metadata2$address() {
        return heif_context_add_XMP_metadata2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_add_XMP_metadata2(struct heif_context *, const struct heif_image_handle *image_handle, const void *data, int size, enum heif_metadata_compression compression)
     * }
     */
    public static MemorySegment heif_context_add_XMP_metadata2(SegmentAllocator allocator, MemorySegment x0, MemorySegment image_handle, MemorySegment data, int size, int compression) {
        var mh$ = heif_context_add_XMP_metadata2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_add_XMP_metadata2", allocator, x0, image_handle, data, size, compression);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, image_handle, data, size, compression);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_add_generic_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_add_generic_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_generic_metadata(struct heif_context *ctx, const struct heif_image_handle *image_handle, const void *data, int size, const char *item_type, const char *content_type)
     * }
     */
    public static FunctionDescriptor heif_context_add_generic_metadata$descriptor() {
        return heif_context_add_generic_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_generic_metadata(struct heif_context *ctx, const struct heif_image_handle *image_handle, const void *data, int size, const char *item_type, const char *content_type)
     * }
     */
    public static MethodHandle heif_context_add_generic_metadata$handle() {
        return heif_context_add_generic_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_add_generic_metadata(struct heif_context *ctx, const struct heif_image_handle *image_handle, const void *data, int size, const char *item_type, const char *content_type)
     * }
     */
    public static MemorySegment heif_context_add_generic_metadata$address() {
        return heif_context_add_generic_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_add_generic_metadata(struct heif_context *ctx, const struct heif_image_handle *image_handle, const void *data, int size, const char *item_type, const char *content_type)
     * }
     */
    public static MemorySegment heif_context_add_generic_metadata(SegmentAllocator allocator, MemorySegment ctx, MemorySegment image_handle, MemorySegment data, int size, MemorySegment item_type, MemorySegment content_type) {
        var mh$ = heif_context_add_generic_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_add_generic_metadata", allocator, ctx, image_handle, data, size, item_type, content_type);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, image_handle, data, size, item_type, content_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_create(int width, int height, enum heif_colorspace colorspace, enum heif_chroma chroma, struct heif_image **out_image)
     * }
     */
    public static FunctionDescriptor heif_image_create$descriptor() {
        return heif_image_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_create(int width, int height, enum heif_colorspace colorspace, enum heif_chroma chroma, struct heif_image **out_image)
     * }
     */
    public static MethodHandle heif_image_create$handle() {
        return heif_image_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_create(int width, int height, enum heif_colorspace colorspace, enum heif_chroma chroma, struct heif_image **out_image)
     * }
     */
    public static MemorySegment heif_image_create$address() {
        return heif_image_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_create(int width, int height, enum heif_colorspace colorspace, enum heif_chroma chroma, struct heif_image **out_image)
     * }
     */
    public static MemorySegment heif_image_create(SegmentAllocator allocator, int width, int height, int colorspace, int chroma, MemorySegment out_image) {
        var mh$ = heif_image_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_create", allocator, width, height, colorspace, chroma, out_image);
            }
            return (MemorySegment)mh$.invokeExact(allocator, width, height, colorspace, chroma, out_image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_add_plane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_add_plane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_add_plane(struct heif_image *image, enum heif_channel channel, int width, int height, int bit_depth)
     * }
     */
    public static FunctionDescriptor heif_image_add_plane$descriptor() {
        return heif_image_add_plane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_add_plane(struct heif_image *image, enum heif_channel channel, int width, int height, int bit_depth)
     * }
     */
    public static MethodHandle heif_image_add_plane$handle() {
        return heif_image_add_plane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_add_plane(struct heif_image *image, enum heif_channel channel, int width, int height, int bit_depth)
     * }
     */
    public static MemorySegment heif_image_add_plane$address() {
        return heif_image_add_plane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_add_plane(struct heif_image *image, enum heif_channel channel, int width, int height, int bit_depth)
     * }
     */
    public static MemorySegment heif_image_add_plane(SegmentAllocator allocator, MemorySegment image, int channel, int width, int height, int bit_depth) {
        var mh$ = heif_image_add_plane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_add_plane", allocator, image, channel, width, height, bit_depth);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, channel, width, height, bit_depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_set_premultiplied_alpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_set_premultiplied_alpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_image_set_premultiplied_alpha(struct heif_image *image, int is_premultiplied_alpha)
     * }
     */
    public static FunctionDescriptor heif_image_set_premultiplied_alpha$descriptor() {
        return heif_image_set_premultiplied_alpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_image_set_premultiplied_alpha(struct heif_image *image, int is_premultiplied_alpha)
     * }
     */
    public static MethodHandle heif_image_set_premultiplied_alpha$handle() {
        return heif_image_set_premultiplied_alpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_image_set_premultiplied_alpha(struct heif_image *image, int is_premultiplied_alpha)
     * }
     */
    public static MemorySegment heif_image_set_premultiplied_alpha$address() {
        return heif_image_set_premultiplied_alpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_image_set_premultiplied_alpha(struct heif_image *image, int is_premultiplied_alpha)
     * }
     */
    public static void heif_image_set_premultiplied_alpha(MemorySegment image, int is_premultiplied_alpha) {
        var mh$ = heif_image_set_premultiplied_alpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_set_premultiplied_alpha", image, is_premultiplied_alpha);
            }
            mh$.invokeExact(image, is_premultiplied_alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_is_premultiplied_alpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_is_premultiplied_alpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_is_premultiplied_alpha(struct heif_image *image)
     * }
     */
    public static FunctionDescriptor heif_image_is_premultiplied_alpha$descriptor() {
        return heif_image_is_premultiplied_alpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_is_premultiplied_alpha(struct heif_image *image)
     * }
     */
    public static MethodHandle heif_image_is_premultiplied_alpha$handle() {
        return heif_image_is_premultiplied_alpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_is_premultiplied_alpha(struct heif_image *image)
     * }
     */
    public static MemorySegment heif_image_is_premultiplied_alpha$address() {
        return heif_image_is_premultiplied_alpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_is_premultiplied_alpha(struct heif_image *image)
     * }
     */
    public static int heif_image_is_premultiplied_alpha(MemorySegment image) {
        var mh$ = heif_image_is_premultiplied_alpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_is_premultiplied_alpha", image);
            }
            return (int)mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_extend_padding_to_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_extend_padding_to_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_extend_padding_to_size(struct heif_image *image, int min_physical_width, int min_physical_height)
     * }
     */
    public static FunctionDescriptor heif_image_extend_padding_to_size$descriptor() {
        return heif_image_extend_padding_to_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_extend_padding_to_size(struct heif_image *image, int min_physical_width, int min_physical_height)
     * }
     */
    public static MethodHandle heif_image_extend_padding_to_size$handle() {
        return heif_image_extend_padding_to_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_extend_padding_to_size(struct heif_image *image, int min_physical_width, int min_physical_height)
     * }
     */
    public static MemorySegment heif_image_extend_padding_to_size$address() {
        return heif_image_extend_padding_to_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_extend_padding_to_size(struct heif_image *image, int min_physical_width, int min_physical_height)
     * }
     */
    public static MemorySegment heif_image_extend_padding_to_size(SegmentAllocator allocator, MemorySegment image, int min_physical_width, int min_physical_height) {
        var mh$ = heif_image_extend_padding_to_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_extend_padding_to_size", allocator, image, min_physical_width, min_physical_height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image, min_physical_width, min_physical_height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_register_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_register_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder(struct heif_context *heif, const struct heif_decoder_plugin *)
     * }
     */
    public static FunctionDescriptor heif_register_decoder$descriptor() {
        return heif_register_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder(struct heif_context *heif, const struct heif_decoder_plugin *)
     * }
     */
    public static MethodHandle heif_register_decoder$handle() {
        return heif_register_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder(struct heif_context *heif, const struct heif_decoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_decoder$address() {
        return heif_register_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder(struct heif_context *heif, const struct heif_decoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_decoder(SegmentAllocator allocator, MemorySegment heif, MemorySegment x1) {
        var mh$ = heif_register_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_register_decoder", allocator, heif, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, heif, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_register_decoder_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_register_decoder_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder_plugin(const struct heif_decoder_plugin *)
     * }
     */
    public static FunctionDescriptor heif_register_decoder_plugin$descriptor() {
        return heif_register_decoder_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder_plugin(const struct heif_decoder_plugin *)
     * }
     */
    public static MethodHandle heif_register_decoder_plugin$handle() {
        return heif_register_decoder_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder_plugin(const struct heif_decoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_decoder_plugin$address() {
        return heif_register_decoder_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_register_decoder_plugin(const struct heif_decoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_decoder_plugin(SegmentAllocator allocator, MemorySegment x0) {
        var mh$ = heif_register_decoder_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_register_decoder_plugin", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_register_encoder_plugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_register_encoder_plugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_register_encoder_plugin(const struct heif_encoder_plugin *)
     * }
     */
    public static FunctionDescriptor heif_register_encoder_plugin$descriptor() {
        return heif_register_encoder_plugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_register_encoder_plugin(const struct heif_encoder_plugin *)
     * }
     */
    public static MethodHandle heif_register_encoder_plugin$handle() {
        return heif_register_encoder_plugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_register_encoder_plugin(const struct heif_encoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_encoder_plugin$address() {
        return heif_register_encoder_plugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_register_encoder_plugin(const struct heif_encoder_plugin *)
     * }
     */
    public static MemorySegment heif_register_encoder_plugin(SegmentAllocator allocator, MemorySegment x0) {
        var mh$ = heif_register_encoder_plugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_register_encoder_plugin", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_supportes_lossy_compression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_supportes_lossy_compression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_supportes_lossy_compression$descriptor() {
        return heif_encoder_descriptor_supportes_lossy_compression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_supportes_lossy_compression$handle() {
        return heif_encoder_descriptor_supportes_lossy_compression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_supportes_lossy_compression$address() {
        return heif_encoder_descriptor_supportes_lossy_compression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossy_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static int heif_encoder_descriptor_supportes_lossy_compression(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_supportes_lossy_compression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_supportes_lossy_compression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_encoder_descriptor_supportes_lossless_compression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_encoder_descriptor_supportes_lossless_compression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static FunctionDescriptor heif_encoder_descriptor_supportes_lossless_compression$descriptor() {
        return heif_encoder_descriptor_supportes_lossless_compression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MethodHandle heif_encoder_descriptor_supportes_lossless_compression$handle() {
        return heif_encoder_descriptor_supportes_lossless_compression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static MemorySegment heif_encoder_descriptor_supportes_lossless_compression$address() {
        return heif_encoder_descriptor_supportes_lossless_compression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_encoder_descriptor_supportes_lossless_compression(const struct heif_encoder_descriptor *)
     * }
     */
    public static int heif_encoder_descriptor_supportes_lossless_compression(MemorySegment x0) {
        var mh$ = heif_encoder_descriptor_supportes_lossless_compression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_encoder_descriptor_supportes_lossless_compression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int heif_region_type_point = (int)0L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_point = 0
     * }
     */
    public static int heif_region_type_point() {
        return heif_region_type_point;
    }
    private static final int heif_region_type_rectangle = (int)1L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_rectangle = 1
     * }
     */
    public static int heif_region_type_rectangle() {
        return heif_region_type_rectangle;
    }
    private static final int heif_region_type_ellipse = (int)2L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_ellipse = 2
     * }
     */
    public static int heif_region_type_ellipse() {
        return heif_region_type_ellipse;
    }
    private static final int heif_region_type_polygon = (int)3L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_polygon = 3
     * }
     */
    public static int heif_region_type_polygon() {
        return heif_region_type_polygon;
    }
    private static final int heif_region_type_referenced_mask = (int)4L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_referenced_mask = 4
     * }
     */
    public static int heif_region_type_referenced_mask() {
        return heif_region_type_referenced_mask;
    }
    private static final int heif_region_type_inline_mask = (int)5L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_inline_mask = 5
     * }
     */
    public static int heif_region_type_inline_mask() {
        return heif_region_type_inline_mask;
    }
    private static final int heif_region_type_polyline = (int)6L;
    /**
     * {@snippet lang=c :
     * enum heif_region_type.heif_region_type_polyline = 6
     * }
     */
    public static int heif_region_type_polyline() {
        return heif_region_type_polyline;
    }

    private static class heif_image_handle_get_number_of_region_items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_number_of_region_items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_region_items(const struct heif_image_handle *image_handle)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_number_of_region_items$descriptor() {
        return heif_image_handle_get_number_of_region_items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_region_items(const struct heif_image_handle *image_handle)
     * }
     */
    public static MethodHandle heif_image_handle_get_number_of_region_items$handle() {
        return heif_image_handle_get_number_of_region_items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_region_items(const struct heif_image_handle *image_handle)
     * }
     */
    public static MemorySegment heif_image_handle_get_number_of_region_items$address() {
        return heif_image_handle_get_number_of_region_items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_number_of_region_items(const struct heif_image_handle *image_handle)
     * }
     */
    public static int heif_image_handle_get_number_of_region_items(MemorySegment image_handle) {
        var mh$ = heif_image_handle_get_number_of_region_items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_number_of_region_items", image_handle);
            }
            return (int)mh$.invokeExact(image_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_get_list_of_region_item_ids {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_get_list_of_region_item_ids");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_region_item_ids(const struct heif_image_handle *image_handle, heif_item_id *region_item_ids_array, int max_count)
     * }
     */
    public static FunctionDescriptor heif_image_handle_get_list_of_region_item_ids$descriptor() {
        return heif_image_handle_get_list_of_region_item_ids.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_region_item_ids(const struct heif_image_handle *image_handle, heif_item_id *region_item_ids_array, int max_count)
     * }
     */
    public static MethodHandle heif_image_handle_get_list_of_region_item_ids$handle() {
        return heif_image_handle_get_list_of_region_item_ids.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_region_item_ids(const struct heif_image_handle *image_handle, heif_item_id *region_item_ids_array, int max_count)
     * }
     */
    public static MemorySegment heif_image_handle_get_list_of_region_item_ids$address() {
        return heif_image_handle_get_list_of_region_item_ids.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_image_handle_get_list_of_region_item_ids(const struct heif_image_handle *image_handle, heif_item_id *region_item_ids_array, int max_count)
     * }
     */
    public static int heif_image_handle_get_list_of_region_item_ids(MemorySegment image_handle, MemorySegment region_item_ids_array, int max_count) {
        var mh$ = heif_image_handle_get_list_of_region_item_ids.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_get_list_of_region_item_ids", image_handle, region_item_ids_array, max_count);
            }
            return (int)mh$.invokeExact(image_handle, region_item_ids_array, max_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_context_get_region_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_context_get_region_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_region_item(const struct heif_context *context, heif_item_id region_item_id, struct heif_region_item **out)
     * }
     */
    public static FunctionDescriptor heif_context_get_region_item$descriptor() {
        return heif_context_get_region_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_region_item(const struct heif_context *context, heif_item_id region_item_id, struct heif_region_item **out)
     * }
     */
    public static MethodHandle heif_context_get_region_item$handle() {
        return heif_context_get_region_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_context_get_region_item(const struct heif_context *context, heif_item_id region_item_id, struct heif_region_item **out)
     * }
     */
    public static MemorySegment heif_context_get_region_item$address() {
        return heif_context_get_region_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_context_get_region_item(const struct heif_context *context, heif_item_id region_item_id, struct heif_region_item **out)
     * }
     */
    public static MemorySegment heif_context_get_region_item(SegmentAllocator allocator, MemorySegment context, int region_item_id, MemorySegment out) {
        var mh$ = heif_context_get_region_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_context_get_region_item", allocator, context, region_item_id, out);
            }
            return (MemorySegment)mh$.invokeExact(allocator, context, region_item_id, out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * heif_item_id heif_region_item_get_id(struct heif_region_item *)
     * }
     */
    public static FunctionDescriptor heif_region_item_get_id$descriptor() {
        return heif_region_item_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * heif_item_id heif_region_item_get_id(struct heif_region_item *)
     * }
     */
    public static MethodHandle heif_region_item_get_id$handle() {
        return heif_region_item_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * heif_item_id heif_region_item_get_id(struct heif_region_item *)
     * }
     */
    public static MemorySegment heif_region_item_get_id$address() {
        return heif_region_item_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * heif_item_id heif_region_item_get_id(struct heif_region_item *)
     * }
     */
    public static int heif_region_item_get_id(MemorySegment x0) {
        var mh$ = heif_region_item_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_get_id", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_region_item_release(struct heif_region_item *)
     * }
     */
    public static FunctionDescriptor heif_region_item_release$descriptor() {
        return heif_region_item_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_region_item_release(struct heif_region_item *)
     * }
     */
    public static MethodHandle heif_region_item_release$handle() {
        return heif_region_item_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_region_item_release(struct heif_region_item *)
     * }
     */
    public static MemorySegment heif_region_item_release$address() {
        return heif_region_item_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_region_item_release(struct heif_region_item *)
     * }
     */
    public static void heif_region_item_release(MemorySegment x0) {
        var mh$ = heif_region_item_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_get_reference_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_get_reference_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_region_item_get_reference_size(struct heif_region_item *, uint32_t *width, uint32_t *height)
     * }
     */
    public static FunctionDescriptor heif_region_item_get_reference_size$descriptor() {
        return heif_region_item_get_reference_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_region_item_get_reference_size(struct heif_region_item *, uint32_t *width, uint32_t *height)
     * }
     */
    public static MethodHandle heif_region_item_get_reference_size$handle() {
        return heif_region_item_get_reference_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_region_item_get_reference_size(struct heif_region_item *, uint32_t *width, uint32_t *height)
     * }
     */
    public static MemorySegment heif_region_item_get_reference_size$address() {
        return heif_region_item_get_reference_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_region_item_get_reference_size(struct heif_region_item *, uint32_t *width, uint32_t *height)
     * }
     */
    public static void heif_region_item_get_reference_size(MemorySegment x0, MemorySegment width, MemorySegment height) {
        var mh$ = heif_region_item_get_reference_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_get_reference_size", x0, width, height);
            }
            mh$.invokeExact(x0, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_get_number_of_regions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_get_number_of_regions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_region_item_get_number_of_regions(const struct heif_region_item *region_item)
     * }
     */
    public static FunctionDescriptor heif_region_item_get_number_of_regions$descriptor() {
        return heif_region_item_get_number_of_regions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_region_item_get_number_of_regions(const struct heif_region_item *region_item)
     * }
     */
    public static MethodHandle heif_region_item_get_number_of_regions$handle() {
        return heif_region_item_get_number_of_regions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_region_item_get_number_of_regions(const struct heif_region_item *region_item)
     * }
     */
    public static MemorySegment heif_region_item_get_number_of_regions$address() {
        return heif_region_item_get_number_of_regions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_region_item_get_number_of_regions(const struct heif_region_item *region_item)
     * }
     */
    public static int heif_region_item_get_number_of_regions(MemorySegment region_item) {
        var mh$ = heif_region_item_get_number_of_regions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_get_number_of_regions", region_item);
            }
            return (int)mh$.invokeExact(region_item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_get_list_of_regions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_get_list_of_regions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_region_item_get_list_of_regions(const struct heif_region_item *region_item, struct heif_region **out_regions_array, int max_count)
     * }
     */
    public static FunctionDescriptor heif_region_item_get_list_of_regions$descriptor() {
        return heif_region_item_get_list_of_regions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_region_item_get_list_of_regions(const struct heif_region_item *region_item, struct heif_region **out_regions_array, int max_count)
     * }
     */
    public static MethodHandle heif_region_item_get_list_of_regions$handle() {
        return heif_region_item_get_list_of_regions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_region_item_get_list_of_regions(const struct heif_region_item *region_item, struct heif_region **out_regions_array, int max_count)
     * }
     */
    public static MemorySegment heif_region_item_get_list_of_regions$address() {
        return heif_region_item_get_list_of_regions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_region_item_get_list_of_regions(const struct heif_region_item *region_item, struct heif_region **out_regions_array, int max_count)
     * }
     */
    public static int heif_region_item_get_list_of_regions(MemorySegment region_item, MemorySegment out_regions_array, int max_count) {
        var mh$ = heif_region_item_get_list_of_regions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_get_list_of_regions", region_item, out_regions_array, max_count);
            }
            return (int)mh$.invokeExact(region_item, out_regions_array, max_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_region_release(const struct heif_region *region)
     * }
     */
    public static FunctionDescriptor heif_region_release$descriptor() {
        return heif_region_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_region_release(const struct heif_region *region)
     * }
     */
    public static MethodHandle heif_region_release$handle() {
        return heif_region_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_region_release(const struct heif_region *region)
     * }
     */
    public static MemorySegment heif_region_release$address() {
        return heif_region_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_region_release(const struct heif_region *region)
     * }
     */
    public static void heif_region_release(MemorySegment region) {
        var mh$ = heif_region_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_release", region);
            }
            mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_release_many {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_release_many");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void heif_region_release_many(const struct heif_region *const *regions_array, int num)
     * }
     */
    public static FunctionDescriptor heif_region_release_many$descriptor() {
        return heif_region_release_many.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void heif_region_release_many(const struct heif_region *const *regions_array, int num)
     * }
     */
    public static MethodHandle heif_region_release_many$handle() {
        return heif_region_release_many.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void heif_region_release_many(const struct heif_region *const *regions_array, int num)
     * }
     */
    public static MemorySegment heif_region_release_many$address() {
        return heif_region_release_many.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void heif_region_release_many(const struct heif_region *const *regions_array, int num)
     * }
     */
    public static void heif_region_release_many(MemorySegment regions_array, int num) {
        var mh$ = heif_region_release_many.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_release_many", regions_array, num);
            }
            mh$.invokeExact(regions_array, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum heif_region_type heif_region_get_type(const struct heif_region *region)
     * }
     */
    public static FunctionDescriptor heif_region_get_type$descriptor() {
        return heif_region_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum heif_region_type heif_region_get_type(const struct heif_region *region)
     * }
     */
    public static MethodHandle heif_region_get_type$handle() {
        return heif_region_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum heif_region_type heif_region_get_type(const struct heif_region *region)
     * }
     */
    public static MemorySegment heif_region_get_type$address() {
        return heif_region_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum heif_region_type heif_region_get_type(const struct heif_region *region)
     * }
     */
    public static int heif_region_get_type(MemorySegment region) {
        var mh$ = heif_region_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_type", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point(const struct heif_region *region, int32_t *x, int32_t *y)
     * }
     */
    public static FunctionDescriptor heif_region_get_point$descriptor() {
        return heif_region_get_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point(const struct heif_region *region, int32_t *x, int32_t *y)
     * }
     */
    public static MethodHandle heif_region_get_point$handle() {
        return heif_region_get_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point(const struct heif_region *region, int32_t *x, int32_t *y)
     * }
     */
    public static MemorySegment heif_region_get_point$address() {
        return heif_region_get_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point(const struct heif_region *region, int32_t *x, int32_t *y)
     * }
     */
    public static MemorySegment heif_region_get_point(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y) {
        var mh$ = heif_region_get_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_point", allocator, region, x, y);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_point_transformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_point_transformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point_transformed(const struct heif_region *region, double *x, double *y, heif_item_id image_id)
     * }
     */
    public static FunctionDescriptor heif_region_get_point_transformed$descriptor() {
        return heif_region_get_point_transformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point_transformed(const struct heif_region *region, double *x, double *y, heif_item_id image_id)
     * }
     */
    public static MethodHandle heif_region_get_point_transformed$handle() {
        return heif_region_get_point_transformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point_transformed(const struct heif_region *region, double *x, double *y, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_point_transformed$address() {
        return heif_region_get_point_transformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_point_transformed(const struct heif_region *region, double *x, double *y, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_point_transformed(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y, int image_id) {
        var mh$ = heif_region_get_point_transformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_point_transformed", allocator, region, x, y, image_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y, image_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height)
     * }
     */
    public static FunctionDescriptor heif_region_get_rectangle$descriptor() {
        return heif_region_get_rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height)
     * }
     */
    public static MethodHandle heif_region_get_rectangle$handle() {
        return heif_region_get_rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height)
     * }
     */
    public static MemorySegment heif_region_get_rectangle$address() {
        return heif_region_get_rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height)
     * }
     */
    public static MemorySegment heif_region_get_rectangle(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y, MemorySegment width, MemorySegment height) {
        var mh$ = heif_region_get_rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_rectangle", allocator, region, x, y, width, height);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_rectangle_transformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_rectangle_transformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle_transformed(const struct heif_region *region, double *x, double *y, double *width, double *height, heif_item_id image_id)
     * }
     */
    public static FunctionDescriptor heif_region_get_rectangle_transformed$descriptor() {
        return heif_region_get_rectangle_transformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle_transformed(const struct heif_region *region, double *x, double *y, double *width, double *height, heif_item_id image_id)
     * }
     */
    public static MethodHandle heif_region_get_rectangle_transformed$handle() {
        return heif_region_get_rectangle_transformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle_transformed(const struct heif_region *region, double *x, double *y, double *width, double *height, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_rectangle_transformed$address() {
        return heif_region_get_rectangle_transformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_rectangle_transformed(const struct heif_region *region, double *x, double *y, double *width, double *height, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_rectangle_transformed(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y, MemorySegment width, MemorySegment height, int image_id) {
        var mh$ = heif_region_get_rectangle_transformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_rectangle_transformed", allocator, region, x, y, width, height, image_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y, width, height, image_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_ellipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *radius_x, uint32_t *radius_y)
     * }
     */
    public static FunctionDescriptor heif_region_get_ellipse$descriptor() {
        return heif_region_get_ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *radius_x, uint32_t *radius_y)
     * }
     */
    public static MethodHandle heif_region_get_ellipse$handle() {
        return heif_region_get_ellipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *radius_x, uint32_t *radius_y)
     * }
     */
    public static MemorySegment heif_region_get_ellipse$address() {
        return heif_region_get_ellipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse(const struct heif_region *region, int32_t *x, int32_t *y, uint32_t *radius_x, uint32_t *radius_y)
     * }
     */
    public static MemorySegment heif_region_get_ellipse(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y, MemorySegment radius_x, MemorySegment radius_y) {
        var mh$ = heif_region_get_ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_ellipse", allocator, region, x, y, radius_x, radius_y);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y, radius_x, radius_y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_ellipse_transformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_ellipse_transformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse_transformed(const struct heif_region *region, double *x, double *y, double *radius_x, double *radius_y, heif_item_id image_id)
     * }
     */
    public static FunctionDescriptor heif_region_get_ellipse_transformed$descriptor() {
        return heif_region_get_ellipse_transformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse_transformed(const struct heif_region *region, double *x, double *y, double *radius_x, double *radius_y, heif_item_id image_id)
     * }
     */
    public static MethodHandle heif_region_get_ellipse_transformed$handle() {
        return heif_region_get_ellipse_transformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse_transformed(const struct heif_region *region, double *x, double *y, double *radius_x, double *radius_y, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_ellipse_transformed$address() {
        return heif_region_get_ellipse_transformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_ellipse_transformed(const struct heif_region *region, double *x, double *y, double *radius_x, double *radius_y, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_ellipse_transformed(SegmentAllocator allocator, MemorySegment region, MemorySegment x, MemorySegment y, MemorySegment radius_x, MemorySegment radius_y, int image_id) {
        var mh$ = heif_region_get_ellipse_transformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_ellipse_transformed", allocator, region, x, y, radius_x, radius_y, image_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, x, y, radius_x, radius_y, image_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polygon_num_points {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polygon_num_points");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_region_get_polygon_num_points(const struct heif_region *region)
     * }
     */
    public static FunctionDescriptor heif_region_get_polygon_num_points$descriptor() {
        return heif_region_get_polygon_num_points.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_region_get_polygon_num_points(const struct heif_region *region)
     * }
     */
    public static MethodHandle heif_region_get_polygon_num_points$handle() {
        return heif_region_get_polygon_num_points.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_region_get_polygon_num_points(const struct heif_region *region)
     * }
     */
    public static MemorySegment heif_region_get_polygon_num_points$address() {
        return heif_region_get_polygon_num_points.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_region_get_polygon_num_points(const struct heif_region *region)
     * }
     */
    public static int heif_region_get_polygon_num_points(MemorySegment region) {
        var mh$ = heif_region_get_polygon_num_points.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polygon_num_points", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polygon_points {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polygon_points");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static FunctionDescriptor heif_region_get_polygon_points$descriptor() {
        return heif_region_get_polygon_points.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MethodHandle heif_region_get_polygon_points$handle() {
        return heif_region_get_polygon_points.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MemorySegment heif_region_get_polygon_points$address() {
        return heif_region_get_polygon_points.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MemorySegment heif_region_get_polygon_points(SegmentAllocator allocator, MemorySegment region, MemorySegment out_pts_array) {
        var mh$ = heif_region_get_polygon_points.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polygon_points", allocator, region, out_pts_array);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, out_pts_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polygon_points_transformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polygon_points_transformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static FunctionDescriptor heif_region_get_polygon_points_transformed$descriptor() {
        return heif_region_get_polygon_points_transformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MethodHandle heif_region_get_polygon_points_transformed$handle() {
        return heif_region_get_polygon_points_transformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_polygon_points_transformed$address() {
        return heif_region_get_polygon_points_transformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polygon_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_polygon_points_transformed(SegmentAllocator allocator, MemorySegment region, MemorySegment out_pts_array, int image_id) {
        var mh$ = heif_region_get_polygon_points_transformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polygon_points_transformed", allocator, region, out_pts_array, image_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, out_pts_array, image_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polyline_num_points {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polyline_num_points");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heif_region_get_polyline_num_points(const struct heif_region *region)
     * }
     */
    public static FunctionDescriptor heif_region_get_polyline_num_points$descriptor() {
        return heif_region_get_polyline_num_points.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heif_region_get_polyline_num_points(const struct heif_region *region)
     * }
     */
    public static MethodHandle heif_region_get_polyline_num_points$handle() {
        return heif_region_get_polyline_num_points.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heif_region_get_polyline_num_points(const struct heif_region *region)
     * }
     */
    public static MemorySegment heif_region_get_polyline_num_points$address() {
        return heif_region_get_polyline_num_points.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heif_region_get_polyline_num_points(const struct heif_region *region)
     * }
     */
    public static int heif_region_get_polyline_num_points(MemorySegment region) {
        var mh$ = heif_region_get_polyline_num_points.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polyline_num_points", region);
            }
            return (int)mh$.invokeExact(region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polyline_points {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polyline_points");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static FunctionDescriptor heif_region_get_polyline_points$descriptor() {
        return heif_region_get_polyline_points.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MethodHandle heif_region_get_polyline_points$handle() {
        return heif_region_get_polyline_points.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MemorySegment heif_region_get_polyline_points$address() {
        return heif_region_get_polyline_points.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points(const struct heif_region *region, int32_t *out_pts_array)
     * }
     */
    public static MemorySegment heif_region_get_polyline_points(SegmentAllocator allocator, MemorySegment region, MemorySegment out_pts_array) {
        var mh$ = heif_region_get_polyline_points.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polyline_points", allocator, region, out_pts_array);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, out_pts_array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_get_polyline_points_transformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_get_polyline_points_transformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static FunctionDescriptor heif_region_get_polyline_points_transformed$descriptor() {
        return heif_region_get_polyline_points_transformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MethodHandle heif_region_get_polyline_points_transformed$handle() {
        return heif_region_get_polyline_points_transformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_polyline_points_transformed$address() {
        return heif_region_get_polyline_points_transformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_get_polyline_points_transformed(const struct heif_region *region, double *out_pts_array, heif_item_id image_id)
     * }
     */
    public static MemorySegment heif_region_get_polyline_points_transformed(SegmentAllocator allocator, MemorySegment region, MemorySegment out_pts_array, int image_id) {
        var mh$ = heif_region_get_polyline_points_transformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_get_polyline_points_transformed", allocator, region, out_pts_array, image_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, region, out_pts_array, image_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_image_handle_add_region_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_image_handle_add_region_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_add_region_item(struct heif_image_handle *image_handle, uint32_t reference_width, uint32_t reference_height, struct heif_region_item **out_region_item)
     * }
     */
    public static FunctionDescriptor heif_image_handle_add_region_item$descriptor() {
        return heif_image_handle_add_region_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_add_region_item(struct heif_image_handle *image_handle, uint32_t reference_width, uint32_t reference_height, struct heif_region_item **out_region_item)
     * }
     */
    public static MethodHandle heif_image_handle_add_region_item$handle() {
        return heif_image_handle_add_region_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_add_region_item(struct heif_image_handle *image_handle, uint32_t reference_width, uint32_t reference_height, struct heif_region_item **out_region_item)
     * }
     */
    public static MemorySegment heif_image_handle_add_region_item$address() {
        return heif_image_handle_add_region_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_image_handle_add_region_item(struct heif_image_handle *image_handle, uint32_t reference_width, uint32_t reference_height, struct heif_region_item **out_region_item)
     * }
     */
    public static MemorySegment heif_image_handle_add_region_item(SegmentAllocator allocator, MemorySegment image_handle, int reference_width, int reference_height, MemorySegment out_region_item) {
        var mh$ = heif_image_handle_add_region_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_image_handle_add_region_item", allocator, image_handle, reference_width, reference_height, out_region_item);
            }
            return (MemorySegment)mh$.invokeExact(allocator, image_handle, reference_width, reference_height, out_region_item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_add_region_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_add_region_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_point(struct heif_region_item *, int32_t x, int32_t y, struct heif_region **out_region)
     * }
     */
    public static FunctionDescriptor heif_region_item_add_region_point$descriptor() {
        return heif_region_item_add_region_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_point(struct heif_region_item *, int32_t x, int32_t y, struct heif_region **out_region)
     * }
     */
    public static MethodHandle heif_region_item_add_region_point$handle() {
        return heif_region_item_add_region_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_point(struct heif_region_item *, int32_t x, int32_t y, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_point$address() {
        return heif_region_item_add_region_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_point(struct heif_region_item *, int32_t x, int32_t y, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_point(SegmentAllocator allocator, MemorySegment x0, int x, int y, MemorySegment out_region) {
        var mh$ = heif_region_item_add_region_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_add_region_point", allocator, x0, x, y, out_region);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x, y, out_region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_add_region_rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_add_region_rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_rectangle(struct heif_region_item *, int32_t x, int32_t y, uint32_t width, uint32_t height, struct heif_region **out_region)
     * }
     */
    public static FunctionDescriptor heif_region_item_add_region_rectangle$descriptor() {
        return heif_region_item_add_region_rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_rectangle(struct heif_region_item *, int32_t x, int32_t y, uint32_t width, uint32_t height, struct heif_region **out_region)
     * }
     */
    public static MethodHandle heif_region_item_add_region_rectangle$handle() {
        return heif_region_item_add_region_rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_rectangle(struct heif_region_item *, int32_t x, int32_t y, uint32_t width, uint32_t height, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_rectangle$address() {
        return heif_region_item_add_region_rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_rectangle(struct heif_region_item *, int32_t x, int32_t y, uint32_t width, uint32_t height, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_rectangle(SegmentAllocator allocator, MemorySegment x0, int x, int y, int width, int height, MemorySegment out_region) {
        var mh$ = heif_region_item_add_region_rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_add_region_rectangle", allocator, x0, x, y, width, height, out_region);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x, y, width, height, out_region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_add_region_ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_add_region_ellipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_ellipse(struct heif_region_item *, int32_t x, int32_t y, uint32_t radius_x, uint32_t radius_y, struct heif_region **out_region)
     * }
     */
    public static FunctionDescriptor heif_region_item_add_region_ellipse$descriptor() {
        return heif_region_item_add_region_ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_ellipse(struct heif_region_item *, int32_t x, int32_t y, uint32_t radius_x, uint32_t radius_y, struct heif_region **out_region)
     * }
     */
    public static MethodHandle heif_region_item_add_region_ellipse$handle() {
        return heif_region_item_add_region_ellipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_ellipse(struct heif_region_item *, int32_t x, int32_t y, uint32_t radius_x, uint32_t radius_y, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_ellipse$address() {
        return heif_region_item_add_region_ellipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_ellipse(struct heif_region_item *, int32_t x, int32_t y, uint32_t radius_x, uint32_t radius_y, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_ellipse(SegmentAllocator allocator, MemorySegment x0, int x, int y, int radius_x, int radius_y, MemorySegment out_region) {
        var mh$ = heif_region_item_add_region_ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_add_region_ellipse", allocator, x0, x, y, radius_x, radius_y, out_region);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x, y, radius_x, radius_y, out_region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_add_region_polygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_add_region_polygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polygon(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static FunctionDescriptor heif_region_item_add_region_polygon$descriptor() {
        return heif_region_item_add_region_polygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polygon(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MethodHandle heif_region_item_add_region_polygon$handle() {
        return heif_region_item_add_region_polygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polygon(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_polygon$address() {
        return heif_region_item_add_region_polygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polygon(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_polygon(SegmentAllocator allocator, MemorySegment x0, MemorySegment pts_array, int nPoints, MemorySegment out_region) {
        var mh$ = heif_region_item_add_region_polygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_add_region_polygon", allocator, x0, pts_array, nPoints, out_region);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, pts_array, nPoints, out_region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heif_region_item_add_region_polyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            heif_error.layout(),
            heif_h.C_POINTER,
            heif_h.C_POINTER,
            heif_h.C_INT,
            heif_h.C_POINTER
        );

        public static final MemorySegment ADDR = heif_h.findOrThrow("heif_region_item_add_region_polyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polyline(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static FunctionDescriptor heif_region_item_add_region_polyline$descriptor() {
        return heif_region_item_add_region_polyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polyline(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MethodHandle heif_region_item_add_region_polyline$handle() {
        return heif_region_item_add_region_polyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polyline(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_polyline$address() {
        return heif_region_item_add_region_polyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct heif_error heif_region_item_add_region_polyline(struct heif_region_item *, const int32_t *pts_array, int nPoints, struct heif_region **out_region)
     * }
     */
    public static MemorySegment heif_region_item_add_region_polyline(SegmentAllocator allocator, MemorySegment x0, MemorySegment pts_array, int nPoints, MemorySegment out_region) {
        var mh$ = heif_region_item_add_region_polyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heif_region_item_add_region_polyline", allocator, x0, pts_array, nPoints, out_region);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, pts_array, nPoints, out_region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = heif_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int LIBHEIF_NUMERIC_VERSION = (int)17825792L;
    /**
     * {@snippet lang=c :
     * #define LIBHEIF_NUMERIC_VERSION 17825792
     * }
     */
    public static int LIBHEIF_NUMERIC_VERSION() {
        return LIBHEIF_NUMERIC_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define LIBHEIF_VERSION "1.16.0"
     * }
     */
    public static MemorySegment LIBHEIF_VERSION() {
        class Holder {
            static final MemorySegment LIBHEIF_VERSION
                = heif_h.LIBRARY_ARENA.allocateFrom("1.16.0");
        }
        return Holder.LIBHEIF_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define LIBHEIF_PLUGIN_DIRECTORY "/usr/local/lib/libheif"
     * }
     */
    public static MemorySegment LIBHEIF_PLUGIN_DIRECTORY() {
        class Holder {
            static final MemorySegment LIBHEIF_PLUGIN_DIRECTORY
                = heif_h.LIBRARY_ARENA.allocateFrom("/usr/local/lib/libheif");
        }
        return Holder.LIBHEIF_PLUGIN_DIRECTORY;
    }
    private static final int heif_brand2_heic = (int)1751476579L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_heic 1751476579
     * }
     */
    public static int heif_brand2_heic() {
        return heif_brand2_heic;
    }
    private static final int heif_brand2_heix = (int)1751476600L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_heix 1751476600
     * }
     */
    public static int heif_brand2_heix() {
        return heif_brand2_heix;
    }
    private static final int heif_brand2_hevc = (int)1751479907L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_hevc 1751479907
     * }
     */
    public static int heif_brand2_hevc() {
        return heif_brand2_hevc;
    }
    private static final int heif_brand2_hevx = (int)1751479928L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_hevx 1751479928
     * }
     */
    public static int heif_brand2_hevx() {
        return heif_brand2_hevx;
    }
    private static final int heif_brand2_heim = (int)1751476589L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_heim 1751476589
     * }
     */
    public static int heif_brand2_heim() {
        return heif_brand2_heim;
    }
    private static final int heif_brand2_heis = (int)1751476595L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_heis 1751476595
     * }
     */
    public static int heif_brand2_heis() {
        return heif_brand2_heis;
    }
    private static final int heif_brand2_hevm = (int)1751479917L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_hevm 1751479917
     * }
     */
    public static int heif_brand2_hevm() {
        return heif_brand2_hevm;
    }
    private static final int heif_brand2_hevs = (int)1751479923L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_hevs 1751479923
     * }
     */
    public static int heif_brand2_hevs() {
        return heif_brand2_hevs;
    }
    private static final int heif_brand2_avif = (int)1635150182L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_avif 1635150182
     * }
     */
    public static int heif_brand2_avif() {
        return heif_brand2_avif;
    }
    private static final int heif_brand2_avis = (int)1635150195L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_avis 1635150195
     * }
     */
    public static int heif_brand2_avis() {
        return heif_brand2_avis;
    }
    private static final int heif_brand2_mif1 = (int)1835623985L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_mif1 1835623985
     * }
     */
    public static int heif_brand2_mif1() {
        return heif_brand2_mif1;
    }
    private static final int heif_brand2_msf1 = (int)1836279345L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_msf1 1836279345
     * }
     */
    public static int heif_brand2_msf1() {
        return heif_brand2_msf1;
    }
    private static final int heif_brand2_vvic = (int)1987471715L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_vvic 1987471715
     * }
     */
    public static int heif_brand2_vvic() {
        return heif_brand2_vvic;
    }
    private static final int heif_brand2_vvis = (int)1987471731L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_vvis 1987471731
     * }
     */
    public static int heif_brand2_vvis() {
        return heif_brand2_vvis;
    }
    private static final int heif_brand2_evbi = (int)1702257257L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_evbi 1702257257
     * }
     */
    public static int heif_brand2_evbi() {
        return heif_brand2_evbi;
    }
    private static final int heif_brand2_evbs = (int)1702257267L;
    /**
     * {@snippet lang=c :
     * #define heif_brand2_evbs 1702257267
     * }
     */
    public static int heif_brand2_evbs() {
        return heif_brand2_evbs;
    }
    private static final long LIBHEIF_AUX_IMAGE_FILTER_OMIT_ALPHA = 2L;
    /**
     * {@snippet lang=c :
     * #define LIBHEIF_AUX_IMAGE_FILTER_OMIT_ALPHA 2
     * }
     */
    public static long LIBHEIF_AUX_IMAGE_FILTER_OMIT_ALPHA() {
        return LIBHEIF_AUX_IMAGE_FILTER_OMIT_ALPHA;
    }
    private static final long LIBHEIF_AUX_IMAGE_FILTER_OMIT_DEPTH = 4L;
    /**
     * {@snippet lang=c :
     * #define LIBHEIF_AUX_IMAGE_FILTER_OMIT_DEPTH 4
     * }
     */
    public static long LIBHEIF_AUX_IMAGE_FILTER_OMIT_DEPTH() {
        return LIBHEIF_AUX_IMAGE_FILTER_OMIT_DEPTH;
    }
    private static final int heif_chroma_interleaved_24bit = (int)10L;
    /**
     * {@snippet lang=c :
     * #define heif_chroma_interleaved_24bit 10
     * }
     */
    public static int heif_chroma_interleaved_24bit() {
        return heif_chroma_interleaved_24bit;
    }
    private static final int heif_chroma_interleaved_32bit = (int)11L;
    /**
     * {@snippet lang=c :
     * #define heif_chroma_interleaved_32bit 11
     * }
     */
    public static int heif_chroma_interleaved_32bit() {
        return heif_chroma_interleaved_32bit;
    }
}


// Generated by jextract

package com.github.gotson.nightmonkeys.jxl.lib.panama;

import jdk.incubator.foreign.GroupLayout;
import jdk.incubator.foreign.MemoryAddress;
import jdk.incubator.foreign.MemoryLayout;
import jdk.incubator.foreign.MemorySegment;
import jdk.incubator.foreign.ResourceScope;
import jdk.incubator.foreign.SegmentAllocator;

import java.lang.invoke.VarHandle;

public class JxlBasicInfo {

    static final GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_INT$LAYOUT.withName("have_container"),
        Constants$root.C_INT$LAYOUT.withName("xsize"),
        Constants$root.C_INT$LAYOUT.withName("ysize"),
        Constants$root.C_INT$LAYOUT.withName("bits_per_sample"),
        Constants$root.C_INT$LAYOUT.withName("exponent_bits_per_sample"),
        Constants$root.C_FLOAT$LAYOUT.withName("intensity_target"),
        Constants$root.C_FLOAT$LAYOUT.withName("min_nits"),
        Constants$root.C_INT$LAYOUT.withName("relative_to_max_display"),
        Constants$root.C_FLOAT$LAYOUT.withName("linear_below"),
        Constants$root.C_INT$LAYOUT.withName("uses_original_profile"),
        Constants$root.C_INT$LAYOUT.withName("have_preview"),
        Constants$root.C_INT$LAYOUT.withName("have_animation"),
        Constants$root.C_INT$LAYOUT.withName("orientation"),
        Constants$root.C_INT$LAYOUT.withName("num_color_channels"),
        Constants$root.C_INT$LAYOUT.withName("num_extra_channels"),
        Constants$root.C_INT$LAYOUT.withName("alpha_bits"),
        Constants$root.C_INT$LAYOUT.withName("alpha_exponent_bits"),
        Constants$root.C_INT$LAYOUT.withName("alpha_premultiplied"),
        MemoryLayout.structLayout(
            Constants$root.C_INT$LAYOUT.withName("xsize"),
            Constants$root.C_INT$LAYOUT.withName("ysize")
        ).withName("preview"),
        MemoryLayout.structLayout(
            Constants$root.C_INT$LAYOUT.withName("tps_numerator"),
            Constants$root.C_INT$LAYOUT.withName("tps_denominator"),
            Constants$root.C_INT$LAYOUT.withName("num_loops"),
            Constants$root.C_INT$LAYOUT.withName("have_timecodes")
        ).withName("animation"),
        MemoryLayout.sequenceLayout(108, Constants$root.C_CHAR$LAYOUT).withName("padding")
    ).withName("JxlBasicInfo");

    public static MemoryLayout $LAYOUT() {
        return JxlBasicInfo.$struct$LAYOUT;
    }

    static final VarHandle have_container$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("have_container"));

    public static VarHandle have_container$VH() {
        return JxlBasicInfo.have_container$VH;
    }

    /**
     * Whether the codestream is embedded in the container format. If true,
     * metadata information and extensions may be available in addition to the
     * codestream.
     */
    public static int have_container$get(MemorySegment seg) {
        return (int) JxlBasicInfo.have_container$VH.get(seg);
    }

    /**
     * Whether the codestream is embedded in the container format. If true,
     * metadata information and extensions may be available in addition to the
     * codestream.
     */
    public static void have_container$set(MemorySegment seg, int x) {
        JxlBasicInfo.have_container$VH.set(seg, x);
    }

    /**
     * Whether the codestream is embedded in the container format. If true,
     * metadata information and extensions may be available in addition to the
     * codestream.
     */
    public static int have_container$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.have_container$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Whether the codestream is embedded in the container format. If true,
     * metadata information and extensions may be available in addition to the
     * codestream.
     */
    public static void have_container$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.have_container$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle xsize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("xsize"));

    public static VarHandle xsize$VH() {
        return JxlBasicInfo.xsize$VH;
    }

    /**
     * Width of the image in pixels, before applying orientation.
     */
    public static int xsize$get(MemorySegment seg) {
        return (int) JxlBasicInfo.xsize$VH.get(seg);
    }

    /**
     * Width of the image in pixels, before applying orientation.
     */
    public static void xsize$set(MemorySegment seg, int x) {
        JxlBasicInfo.xsize$VH.set(seg, x);
    }

    /**
     * Width of the image in pixels, before applying orientation.
     */
    public static int xsize$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.xsize$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Width of the image in pixels, before applying orientation.
     */
    public static void xsize$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.xsize$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle ysize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ysize"));

    public static VarHandle ysize$VH() {
        return JxlBasicInfo.ysize$VH;
    }

    /**
     * Height of the image in pixels, before applying orientation.
     */
    public static int ysize$get(MemorySegment seg) {
        return (int) JxlBasicInfo.ysize$VH.get(seg);
    }

    /**
     * Height of the image in pixels, before applying orientation.
     */
    public static void ysize$set(MemorySegment seg, int x) {
        JxlBasicInfo.ysize$VH.set(seg, x);
    }

    /**
     * Height of the image in pixels, before applying orientation.
     */
    public static int ysize$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.ysize$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Height of the image in pixels, before applying orientation.
     */
    public static void ysize$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.ysize$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle bits_per_sample$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bits_per_sample"));

    public static VarHandle bits_per_sample$VH() {
        return JxlBasicInfo.bits_per_sample$VH;
    }

    /**
     * Original image color channel bit depth.
     */
    public static int bits_per_sample$get(MemorySegment seg) {
        return (int) JxlBasicInfo.bits_per_sample$VH.get(seg);
    }

    /**
     * Original image color channel bit depth.
     */
    public static void bits_per_sample$set(MemorySegment seg, int x) {
        JxlBasicInfo.bits_per_sample$VH.set(seg, x);
    }

    /**
     * Original image color channel bit depth.
     */
    public static int bits_per_sample$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.bits_per_sample$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Original image color channel bit depth.
     */
    public static void bits_per_sample$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.bits_per_sample$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle exponent_bits_per_sample$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("exponent_bits_per_sample"));

    public static VarHandle exponent_bits_per_sample$VH() {
        return JxlBasicInfo.exponent_bits_per_sample$VH;
    }

    /**
     * Original image color channel floating point exponent bits, or 0 if they
     * are unsigned integer. For example, if the original data is half-precision
     * (binary16) floating point, bits_per_sample is 16 and
     * exponent_bits_per_sample is 5, and so on for other floating point
     * precisions.
     */
    public static int exponent_bits_per_sample$get(MemorySegment seg) {
        return (int) JxlBasicInfo.exponent_bits_per_sample$VH.get(seg);
    }

    /**
     * Original image color channel floating point exponent bits, or 0 if they
     * are unsigned integer. For example, if the original data is half-precision
     * (binary16) floating point, bits_per_sample is 16 and
     * exponent_bits_per_sample is 5, and so on for other floating point
     * precisions.
     */
    public static void exponent_bits_per_sample$set(MemorySegment seg, int x) {
        JxlBasicInfo.exponent_bits_per_sample$VH.set(seg, x);
    }

    /**
     * Original image color channel floating point exponent bits, or 0 if they
     * are unsigned integer. For example, if the original data is half-precision
     * (binary16) floating point, bits_per_sample is 16 and
     * exponent_bits_per_sample is 5, and so on for other floating point
     * precisions.
     */
    public static int exponent_bits_per_sample$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.exponent_bits_per_sample$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Original image color channel floating point exponent bits, or 0 if they
     * are unsigned integer. For example, if the original data is half-precision
     * (binary16) floating point, bits_per_sample is 16 and
     * exponent_bits_per_sample is 5, and so on for other floating point
     * precisions.
     */
    public static void exponent_bits_per_sample$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.exponent_bits_per_sample$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle intensity_target$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("intensity_target"));

    public static VarHandle intensity_target$VH() {
        return JxlBasicInfo.intensity_target$VH;
    }

    /**
     * Upper bound on the intensity level present in the image in nits. For
     * unsigned integer pixel encodings, this is the brightness of the largest
     * representable value. The image does not necessarily contain a pixel
     * actually this bright. An encoder is allowed to set 255 for SDR images
     * without computing a histogram.
     * Leaving this set to its default of 0 lets libjxl choose a sensible default
     * value based on the color encoding.
     */
    public static float intensity_target$get(MemorySegment seg) {
        return (float) JxlBasicInfo.intensity_target$VH.get(seg);
    }

    /**
     * Upper bound on the intensity level present in the image in nits. For
     * unsigned integer pixel encodings, this is the brightness of the largest
     * representable value. The image does not necessarily contain a pixel
     * actually this bright. An encoder is allowed to set 255 for SDR images
     * without computing a histogram.
     * Leaving this set to its default of 0 lets libjxl choose a sensible default
     * value based on the color encoding.
     */
    public static void intensity_target$set(MemorySegment seg, float x) {
        JxlBasicInfo.intensity_target$VH.set(seg, x);
    }

    /**
     * Upper bound on the intensity level present in the image in nits. For
     * unsigned integer pixel encodings, this is the brightness of the largest
     * representable value. The image does not necessarily contain a pixel
     * actually this bright. An encoder is allowed to set 255 for SDR images
     * without computing a histogram.
     * Leaving this set to its default of 0 lets libjxl choose a sensible default
     * value based on the color encoding.
     */
    public static float intensity_target$get(MemorySegment seg, long index) {
        return (float) JxlBasicInfo.intensity_target$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Upper bound on the intensity level present in the image in nits. For
     * unsigned integer pixel encodings, this is the brightness of the largest
     * representable value. The image does not necessarily contain a pixel
     * actually this bright. An encoder is allowed to set 255 for SDR images
     * without computing a histogram.
     * Leaving this set to its default of 0 lets libjxl choose a sensible default
     * value based on the color encoding.
     */
    public static void intensity_target$set(MemorySegment seg, long index, float x) {
        JxlBasicInfo.intensity_target$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle min_nits$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("min_nits"));

    public static VarHandle min_nits$VH() {
        return JxlBasicInfo.min_nits$VH;
    }

    /**
     * Lower bound on the intensity level present in the image. This may be
     * loose, i.e. lower than the actual darkest pixel. When tone mapping, a
     * decoder will map [min_nits, intensity_target] to the display range.
     */
    public static float min_nits$get(MemorySegment seg) {
        return (float) JxlBasicInfo.min_nits$VH.get(seg);
    }

    /**
     * Lower bound on the intensity level present in the image. This may be
     * loose, i.e. lower than the actual darkest pixel. When tone mapping, a
     * decoder will map [min_nits, intensity_target] to the display range.
     */
    public static void min_nits$set(MemorySegment seg, float x) {
        JxlBasicInfo.min_nits$VH.set(seg, x);
    }

    /**
     * Lower bound on the intensity level present in the image. This may be
     * loose, i.e. lower than the actual darkest pixel. When tone mapping, a
     * decoder will map [min_nits, intensity_target] to the display range.
     */
    public static float min_nits$get(MemorySegment seg, long index) {
        return (float) JxlBasicInfo.min_nits$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Lower bound on the intensity level present in the image. This may be
     * loose, i.e. lower than the actual darkest pixel. When tone mapping, a
     * decoder will map [min_nits, intensity_target] to the display range.
     */
    public static void min_nits$set(MemorySegment seg, long index, float x) {
        JxlBasicInfo.min_nits$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle relative_to_max_display$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("relative_to_max_display"));

    public static VarHandle relative_to_max_display$VH() {
        return JxlBasicInfo.relative_to_max_display$VH;
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static int relative_to_max_display$get(MemorySegment seg) {
        return (int) JxlBasicInfo.relative_to_max_display$VH.get(seg);
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static void relative_to_max_display$set(MemorySegment seg, int x) {
        JxlBasicInfo.relative_to_max_display$VH.set(seg, x);
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static int relative_to_max_display$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.relative_to_max_display$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static void relative_to_max_display$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.relative_to_max_display$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle linear_below$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("linear_below"));

    public static VarHandle linear_below$VH() {
        return JxlBasicInfo.linear_below$VH;
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static float linear_below$get(MemorySegment seg) {
        return (float) JxlBasicInfo.linear_below$VH.get(seg);
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static void linear_below$set(MemorySegment seg, float x) {
        JxlBasicInfo.linear_below$VH.set(seg, x);
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static float linear_below$get(MemorySegment seg, long index) {
        return (float) JxlBasicInfo.linear_below$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * The tone mapping will leave unchanged (linear mapping) any pixels whose
     * brightness is strictly below this. The interpretation depends on
     * relative_to_max_display. If true, this is a ratio [0, 1] of the maximum
     * display brightness [nits], otherwise an absolute brightness [nits].
     */
    public static void linear_below$set(MemorySegment seg, long index, float x) {
        JxlBasicInfo.linear_below$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle uses_original_profile$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("uses_original_profile"));

    public static VarHandle uses_original_profile$VH() {
        return JxlBasicInfo.uses_original_profile$VH;
    }

    /**
     * Whether the data in the codestream is encoded in the original color
     * profile that is attached to the codestream metadata header, or is
     * encoded in an internally supported absolute color space (which the decoder
     * can always convert to linear or non-linear sRGB or to XYB). If the original
     * profile is used, the decoder outputs pixel data in the color space matching
     * that profile, but doesn't convert it to any other color space. If the
     * original profile is not used, the decoder only outputs the data as sRGB
     * (linear if outputting to floating point, nonlinear with standard sRGB
     * transfer function if outputting to unsigned integers) but will not convert
     * it to to the original color profile. The decoder also does not convert to
     * the target display color profile, but instead will always indicate which
     * color profile the returned pixel data is encoded in when using @see
     * JXL_COLOR_PROFILE_TARGET_DATA so that a CMS can be used to convert the
     * data.
     */
    public static int uses_original_profile$get(MemorySegment seg) {
        return (int) JxlBasicInfo.uses_original_profile$VH.get(seg);
    }

    /**
     * Whether the data in the codestream is encoded in the original color
     * profile that is attached to the codestream metadata header, or is
     * encoded in an internally supported absolute color space (which the decoder
     * can always convert to linear or non-linear sRGB or to XYB). If the original
     * profile is used, the decoder outputs pixel data in the color space matching
     * that profile, but doesn't convert it to any other color space. If the
     * original profile is not used, the decoder only outputs the data as sRGB
     * (linear if outputting to floating point, nonlinear with standard sRGB
     * transfer function if outputting to unsigned integers) but will not convert
     * it to to the original color profile. The decoder also does not convert to
     * the target display color profile, but instead will always indicate which
     * color profile the returned pixel data is encoded in when using @see
     * JXL_COLOR_PROFILE_TARGET_DATA so that a CMS can be used to convert the
     * data.
     */
    public static void uses_original_profile$set(MemorySegment seg, int x) {
        JxlBasicInfo.uses_original_profile$VH.set(seg, x);
    }

    /**
     * Whether the data in the codestream is encoded in the original color
     * profile that is attached to the codestream metadata header, or is
     * encoded in an internally supported absolute color space (which the decoder
     * can always convert to linear or non-linear sRGB or to XYB). If the original
     * profile is used, the decoder outputs pixel data in the color space matching
     * that profile, but doesn't convert it to any other color space. If the
     * original profile is not used, the decoder only outputs the data as sRGB
     * (linear if outputting to floating point, nonlinear with standard sRGB
     * transfer function if outputting to unsigned integers) but will not convert
     * it to to the original color profile. The decoder also does not convert to
     * the target display color profile, but instead will always indicate which
     * color profile the returned pixel data is encoded in when using @see
     * JXL_COLOR_PROFILE_TARGET_DATA so that a CMS can be used to convert the
     * data.
     */
    public static int uses_original_profile$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.uses_original_profile$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Whether the data in the codestream is encoded in the original color
     * profile that is attached to the codestream metadata header, or is
     * encoded in an internally supported absolute color space (which the decoder
     * can always convert to linear or non-linear sRGB or to XYB). If the original
     * profile is used, the decoder outputs pixel data in the color space matching
     * that profile, but doesn't convert it to any other color space. If the
     * original profile is not used, the decoder only outputs the data as sRGB
     * (linear if outputting to floating point, nonlinear with standard sRGB
     * transfer function if outputting to unsigned integers) but will not convert
     * it to to the original color profile. The decoder also does not convert to
     * the target display color profile, but instead will always indicate which
     * color profile the returned pixel data is encoded in when using @see
     * JXL_COLOR_PROFILE_TARGET_DATA so that a CMS can be used to convert the
     * data.
     */
    public static void uses_original_profile$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.uses_original_profile$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle have_preview$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("have_preview"));

    public static VarHandle have_preview$VH() {
        return JxlBasicInfo.have_preview$VH;
    }

    /**
     * Indicates a preview image exists near the beginning of the codestream.
     * The preview itself or its dimensions are not included in the basic info.
     */
    public static int have_preview$get(MemorySegment seg) {
        return (int) JxlBasicInfo.have_preview$VH.get(seg);
    }

    /**
     * Indicates a preview image exists near the beginning of the codestream.
     * The preview itself or its dimensions are not included in the basic info.
     */
    public static void have_preview$set(MemorySegment seg, int x) {
        JxlBasicInfo.have_preview$VH.set(seg, x);
    }

    /**
     * Indicates a preview image exists near the beginning of the codestream.
     * The preview itself or its dimensions are not included in the basic info.
     */
    public static int have_preview$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.have_preview$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Indicates a preview image exists near the beginning of the codestream.
     * The preview itself or its dimensions are not included in the basic info.
     */
    public static void have_preview$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.have_preview$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle have_animation$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("have_animation"));

    public static VarHandle have_animation$VH() {
        return JxlBasicInfo.have_animation$VH;
    }

    /**
     * Indicates animation frames exist in the codestream. The animation
     * information is not included in the basic info.
     */
    public static int have_animation$get(MemorySegment seg) {
        return (int) JxlBasicInfo.have_animation$VH.get(seg);
    }

    /**
     * Indicates animation frames exist in the codestream. The animation
     * information is not included in the basic info.
     */
    public static void have_animation$set(MemorySegment seg, int x) {
        JxlBasicInfo.have_animation$VH.set(seg, x);
    }

    /**
     * Indicates animation frames exist in the codestream. The animation
     * information is not included in the basic info.
     */
    public static int have_animation$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.have_animation$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Indicates animation frames exist in the codestream. The animation
     * information is not included in the basic info.
     */
    public static void have_animation$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.have_animation$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle orientation$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("orientation"));

    public static VarHandle orientation$VH() {
        return JxlBasicInfo.orientation$VH;
    }

    /**
     * Image orientation, value 1-8 matching the values used by JEITA CP-3451C
     * (Exif version 2.3).
     */
    public static int orientation$get(MemorySegment seg) {
        return (int) JxlBasicInfo.orientation$VH.get(seg);
    }

    /**
     * Image orientation, value 1-8 matching the values used by JEITA CP-3451C
     * (Exif version 2.3).
     */
    public static void orientation$set(MemorySegment seg, int x) {
        JxlBasicInfo.orientation$VH.set(seg, x);
    }

    /**
     * Image orientation, value 1-8 matching the values used by JEITA CP-3451C
     * (Exif version 2.3).
     */
    public static int orientation$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.orientation$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Image orientation, value 1-8 matching the values used by JEITA CP-3451C
     * (Exif version 2.3).
     */
    public static void orientation$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.orientation$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle num_color_channels$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("num_color_channels"));

    public static VarHandle num_color_channels$VH() {
        return JxlBasicInfo.num_color_channels$VH;
    }

    /**
     * Number of color channels encoded in the image, this is either 1 for
     * grayscale data, or 3 for colored data. This count does not include
     * the alpha channel or other extra channels. To check presence of an alpha
     * channel, such as in the case of RGBA color, check alpha_bits != 0.
     * If and only if this is 1, the JxlColorSpace in the JxlColorEncoding is
     * JXL_COLOR_SPACE_GRAY.
     */
    public static int num_color_channels$get(MemorySegment seg) {
        return (int) JxlBasicInfo.num_color_channels$VH.get(seg);
    }

    /**
     * Number of color channels encoded in the image, this is either 1 for
     * grayscale data, or 3 for colored data. This count does not include
     * the alpha channel or other extra channels. To check presence of an alpha
     * channel, such as in the case of RGBA color, check alpha_bits != 0.
     * If and only if this is 1, the JxlColorSpace in the JxlColorEncoding is
     * JXL_COLOR_SPACE_GRAY.
     */
    public static void num_color_channels$set(MemorySegment seg, int x) {
        JxlBasicInfo.num_color_channels$VH.set(seg, x);
    }

    /**
     * Number of color channels encoded in the image, this is either 1 for
     * grayscale data, or 3 for colored data. This count does not include
     * the alpha channel or other extra channels. To check presence of an alpha
     * channel, such as in the case of RGBA color, check alpha_bits != 0.
     * If and only if this is 1, the JxlColorSpace in the JxlColorEncoding is
     * JXL_COLOR_SPACE_GRAY.
     */
    public static int num_color_channels$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.num_color_channels$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Number of color channels encoded in the image, this is either 1 for
     * grayscale data, or 3 for colored data. This count does not include
     * the alpha channel or other extra channels. To check presence of an alpha
     * channel, such as in the case of RGBA color, check alpha_bits != 0.
     * If and only if this is 1, the JxlColorSpace in the JxlColorEncoding is
     * JXL_COLOR_SPACE_GRAY.
     */
    public static void num_color_channels$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.num_color_channels$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle num_extra_channels$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("num_extra_channels"));

    public static VarHandle num_extra_channels$VH() {
        return JxlBasicInfo.num_extra_channels$VH;
    }

    /**
     * Number of additional image channels. This includes the main alpha channel,
     * but can also include additional channels such as depth, additional alpha
     * channels, spot colors, and so on. Information about the extra channels
     * can be queried with JxlDecoderGetExtraChannelInfo. The main alpha channel,
     * if it exists, also has its information available in the alpha_bits,
     * alpha_exponent_bits and alpha_premultiplied fields in this JxlBasicInfo.
     */
    public static int num_extra_channels$get(MemorySegment seg) {
        return (int) JxlBasicInfo.num_extra_channels$VH.get(seg);
    }

    /**
     * Number of additional image channels. This includes the main alpha channel,
     * but can also include additional channels such as depth, additional alpha
     * channels, spot colors, and so on. Information about the extra channels
     * can be queried with JxlDecoderGetExtraChannelInfo. The main alpha channel,
     * if it exists, also has its information available in the alpha_bits,
     * alpha_exponent_bits and alpha_premultiplied fields in this JxlBasicInfo.
     */
    public static void num_extra_channels$set(MemorySegment seg, int x) {
        JxlBasicInfo.num_extra_channels$VH.set(seg, x);
    }

    /**
     * Number of additional image channels. This includes the main alpha channel,
     * but can also include additional channels such as depth, additional alpha
     * channels, spot colors, and so on. Information about the extra channels
     * can be queried with JxlDecoderGetExtraChannelInfo. The main alpha channel,
     * if it exists, also has its information available in the alpha_bits,
     * alpha_exponent_bits and alpha_premultiplied fields in this JxlBasicInfo.
     */
    public static int num_extra_channels$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.num_extra_channels$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Number of additional image channels. This includes the main alpha channel,
     * but can also include additional channels such as depth, additional alpha
     * channels, spot colors, and so on. Information about the extra channels
     * can be queried with JxlDecoderGetExtraChannelInfo. The main alpha channel,
     * if it exists, also has its information available in the alpha_bits,
     * alpha_exponent_bits and alpha_premultiplied fields in this JxlBasicInfo.
     */
    public static void num_extra_channels$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.num_extra_channels$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle alpha_bits$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("alpha_bits"));

    public static VarHandle alpha_bits$VH() {
        return JxlBasicInfo.alpha_bits$VH;
    }

    /**
     * Bit depth of the encoded alpha channel, or 0 if there is no alpha channel.
     * If present, matches the alpha_bits value of the JxlExtraChannelInfo
     * associated with this alpha channel.
     */
    public static int alpha_bits$get(MemorySegment seg) {
        return (int) JxlBasicInfo.alpha_bits$VH.get(seg);
    }

    /**
     * Bit depth of the encoded alpha channel, or 0 if there is no alpha channel.
     * If present, matches the alpha_bits value of the JxlExtraChannelInfo
     * associated with this alpha channel.
     */
    public static void alpha_bits$set(MemorySegment seg, int x) {
        JxlBasicInfo.alpha_bits$VH.set(seg, x);
    }

    /**
     * Bit depth of the encoded alpha channel, or 0 if there is no alpha channel.
     * If present, matches the alpha_bits value of the JxlExtraChannelInfo
     * associated with this alpha channel.
     */
    public static int alpha_bits$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.alpha_bits$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Bit depth of the encoded alpha channel, or 0 if there is no alpha channel.
     * If present, matches the alpha_bits value of the JxlExtraChannelInfo
     * associated with this alpha channel.
     */
    public static void alpha_bits$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.alpha_bits$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle alpha_exponent_bits$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("alpha_exponent_bits"));

    public static VarHandle alpha_exponent_bits$VH() {
        return JxlBasicInfo.alpha_exponent_bits$VH;
    }

    /**
     * Alpha channel floating point exponent bits, or 0 if they are unsigned. If
     * present, matches the alpha_bits value of the JxlExtraChannelInfo associated
     * with this alpha channel. integer.
     */
    public static int alpha_exponent_bits$get(MemorySegment seg) {
        return (int) JxlBasicInfo.alpha_exponent_bits$VH.get(seg);
    }

    /**
     * Alpha channel floating point exponent bits, or 0 if they are unsigned. If
     * present, matches the alpha_bits value of the JxlExtraChannelInfo associated
     * with this alpha channel. integer.
     */
    public static void alpha_exponent_bits$set(MemorySegment seg, int x) {
        JxlBasicInfo.alpha_exponent_bits$VH.set(seg, x);
    }

    /**
     * Alpha channel floating point exponent bits, or 0 if they are unsigned. If
     * present, matches the alpha_bits value of the JxlExtraChannelInfo associated
     * with this alpha channel. integer.
     */
    public static int alpha_exponent_bits$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.alpha_exponent_bits$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Alpha channel floating point exponent bits, or 0 if they are unsigned. If
     * present, matches the alpha_bits value of the JxlExtraChannelInfo associated
     * with this alpha channel. integer.
     */
    public static void alpha_exponent_bits$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.alpha_exponent_bits$VH.set(seg.asSlice(index * sizeof()), x);
    }

    static final VarHandle alpha_premultiplied$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("alpha_premultiplied"));

    public static VarHandle alpha_premultiplied$VH() {
        return JxlBasicInfo.alpha_premultiplied$VH;
    }

    /**
     * Whether the alpha channel is premultiplied. Only used if there is a main
     * alpha channel. Matches the alpha_premultiplied value of the
     * JxlExtraChannelInfo associated with this alpha channel.
     */
    public static int alpha_premultiplied$get(MemorySegment seg) {
        return (int) JxlBasicInfo.alpha_premultiplied$VH.get(seg);
    }

    /**
     * Whether the alpha channel is premultiplied. Only used if there is a main
     * alpha channel. Matches the alpha_premultiplied value of the
     * JxlExtraChannelInfo associated with this alpha channel.
     */
    public static void alpha_premultiplied$set(MemorySegment seg, int x) {
        JxlBasicInfo.alpha_premultiplied$VH.set(seg, x);
    }

    /**
     * Whether the alpha channel is premultiplied. Only used if there is a main
     * alpha channel. Matches the alpha_premultiplied value of the
     * JxlExtraChannelInfo associated with this alpha channel.
     */
    public static int alpha_premultiplied$get(MemorySegment seg, long index) {
        return (int) JxlBasicInfo.alpha_premultiplied$VH.get(seg.asSlice(index * sizeof()));
    }

    /**
     * Whether the alpha channel is premultiplied. Only used if there is a main
     * alpha channel. Matches the alpha_premultiplied value of the
     * JxlExtraChannelInfo associated with this alpha channel.
     */
    public static void alpha_premultiplied$set(MemorySegment seg, long index, int x) {
        JxlBasicInfo.alpha_premultiplied$VH.set(seg.asSlice(index * sizeof()), x);
    }

    /**
     * Dimensions of encoded preview image, only used if have_preview is
     * JXL_TRUE.
     */
    public static MemorySegment preview$slice(MemorySegment seg) {
        return seg.asSlice(72, 8);
    }

    /**
     * Animation header with global animation properties for all frames, only
     * used if have_animation is JXL_TRUE.
     */
    public static MemorySegment animation$slice(MemorySegment seg) {
        return seg.asSlice(80, 16);
    }

    /**
     * Padding for forwards-compatibility, in case more fields are exposed
     * in a future version of the library.
     */
    public static MemorySegment padding$slice(MemorySegment seg) {
        return seg.asSlice(96, 108);
    }

    public static long sizeof() {
        return $LAYOUT().byteSize();
    }

    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate($LAYOUT());
    }

    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }

    public static MemorySegment allocate(ResourceScope scope) {
        return allocate(SegmentAllocator.nativeAllocator(scope));
    }

    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }

    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) {
        return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope);
    }
}



// Generated by jextract

package com.github.gotson.nightmonkeys.jxl.lib.panama;

import jdk.incubator.foreign.Addressable;
import jdk.incubator.foreign.MemoryAddress;

import java.lang.invoke.MethodHandle;

import static jdk.incubator.foreign.ValueLayout.OfAddress;
import static jdk.incubator.foreign.ValueLayout.OfByte;
import static jdk.incubator.foreign.ValueLayout.OfDouble;
import static jdk.incubator.foreign.ValueLayout.OfFloat;
import static jdk.incubator.foreign.ValueLayout.OfInt;
import static jdk.incubator.foreign.ValueLayout.OfLong;
import static jdk.incubator.foreign.ValueLayout.OfShort;

/**
 * Extracted by jextract from libjxl 0.6.1
 */
public class decode_h {

    /* package-private */ decode_h() {
    }

    public static OfByte C_CHAR = Constants$root.C_CHAR$LAYOUT;
    public static OfShort C_SHORT = Constants$root.C_SHORT$LAYOUT;
    public static OfInt C_INT = Constants$root.C_INT$LAYOUT;
    public static OfLong C_LONG = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong C_LONG_LONG = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfFloat C_FLOAT = Constants$root.C_FLOAT$LAYOUT;
    public static OfDouble C_DOUBLE = Constants$root.C_DOUBLE$LAYOUT;
    public static OfAddress C_POINTER = Constants$root.C_POINTER$LAYOUT;

    public static int JXL_TRUE() {
        return (int) 1L;
    }

    public static int JXL_FALSE() {
        return (int) 0L;
    }

    public static OfLong ptrdiff_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt wchar_t = Constants$root.C_INT$LAYOUT;
    public static OfLong int64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong int_least64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong int_fast64_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfInt int32_t = Constants$root.C_INT$LAYOUT;
    public static OfInt int_least32_t = Constants$root.C_INT$LAYOUT;
    public static OfInt int_fast32_t = Constants$root.C_INT$LAYOUT;
    public static OfShort int16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfShort int_least16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfShort int_fast16_t = Constants$root.C_SHORT$LAYOUT;
    public static OfLong intptr_t = Constants$root.C_LONG_LONG$LAYOUT;
    public static OfLong intmax_t = Constants$root.C_LONG_LONG$LAYOUT;

    /**
     * Use 32-bit single-precision floating point values, with range 0.0-1.0
     * (within gamut, may go outside this range for wide color gamut). Floating
     * point output, either JXL_TYPE_FLOAT or JXL_TYPE_FLOAT16, is recommended
     * for HDR and wide gamut images when color profile conversion is required.
     */
    public static int JXL_TYPE_FLOAT() {
        return (int) 0L;
    }

    /**
     * Use 1-bit packed in uint8_t, first pixel in LSB, padded to uint8_t per
     * row.
     */
    public static int JXL_TYPE_BOOLEAN() {
        return (int) 1L;
    }

    /**
     * Use type uint8_t. May clip wide color gamut data.
     */
    public static int JXL_TYPE_UINT8() {
        return (int) 2L;
    }

    /**
     * Use type uint16_t. May clip wide color gamut data.
     */
    public static int JXL_TYPE_UINT16() {
        return (int) 3L;
    }

    /**
     * Use type uint32_t. May clip wide color gamut data.
     */
    public static int JXL_TYPE_UINT32() {
        return (int) 4L;
    }

    /**
     * Use 16-bit IEEE 754 half-precision floating point values
     */
    public static int JXL_TYPE_FLOAT16() {
        return (int) 5L;
    }

    /**
     * Use the endianness of the system, either little endian or big endian,
     * without forcing either specific endianness. Do not use if pixel data
     * should be exported to a well defined format.
     */
    public static int JXL_NATIVE_ENDIAN() {
        return (int) 0L;
    }

    /**
     * Force little endian
     */
    public static int JXL_LITTLE_ENDIAN() {
        return (int) 1L;
    }

    /**
     * Force big endian
     */
    public static int JXL_BIG_ENDIAN() {
        return (int) 2L;
    }

    public static int JXL_COLOR_SPACE_RGB() {
        return (int) 0L;
    }

    public static int JXL_COLOR_SPACE_GRAY() {
        return (int) 1L;
    }

    public static int JXL_COLOR_SPACE_XYB() {
        return (int) 2L;
    }

    public static int JXL_COLOR_SPACE_UNKNOWN() {
        return (int) 3L;
    }

    public static int JXL_WHITE_POINT_D65() {
        return (int) 1L;
    }

    public static int JXL_WHITE_POINT_CUSTOM() {
        return (int) 2L;
    }

    public static int JXL_WHITE_POINT_E() {
        return (int) 10L;
    }

    public static int JXL_WHITE_POINT_DCI() {
        return (int) 11L;
    }

    public static int JXL_PRIMARIES_SRGB() {
        return (int) 1L;
    }

    public static int JXL_PRIMARIES_CUSTOM() {
        return (int) 2L;
    }

    public static int JXL_PRIMARIES_2100() {
        return (int) 9L;
    }

    public static int JXL_PRIMARIES_P3() {
        return (int) 11L;
    }

    public static int JXL_TRANSFER_FUNCTION_709() {
        return (int) 1L;
    }

    public static int JXL_TRANSFER_FUNCTION_UNKNOWN() {
        return (int) 2L;
    }

    public static int JXL_TRANSFER_FUNCTION_LINEAR() {
        return (int) 8L;
    }

    public static int JXL_TRANSFER_FUNCTION_SRGB() {
        return (int) 13L;
    }

    public static int JXL_TRANSFER_FUNCTION_PQ() {
        return (int) 16L;
    }

    public static int JXL_TRANSFER_FUNCTION_DCI() {
        return (int) 17L;
    }

    public static int JXL_TRANSFER_FUNCTION_HLG() {
        return (int) 18L;
    }

    public static int JXL_TRANSFER_FUNCTION_GAMMA() {
        return (int) 65535L;
    }

    public static int JXL_RENDERING_INTENT_PERCEPTUAL() {
        return (int) 0L;
    }

    public static int JXL_RENDERING_INTENT_RELATIVE() {
        return (int) 1L;
    }

    public static int JXL_RENDERING_INTENT_SATURATION() {
        return (int) 2L;
    }

    public static int JXL_RENDERING_INTENT_ABSOLUTE() {
        return (int) 3L;
    }

    public static int JXL_ORIENT_IDENTITY() {
        return (int) 1L;
    }

    public static int JXL_ORIENT_FLIP_HORIZONTAL() {
        return (int) 2L;
    }

    public static int JXL_ORIENT_ROTATE_180() {
        return (int) 3L;
    }

    public static int JXL_ORIENT_FLIP_VERTICAL() {
        return (int) 4L;
    }

    public static int JXL_ORIENT_TRANSPOSE() {
        return (int) 5L;
    }

    public static int JXL_ORIENT_ROTATE_90_CW() {
        return (int) 6L;
    }

    public static int JXL_ORIENT_ANTI_TRANSPOSE() {
        return (int) 7L;
    }

    public static int JXL_ORIENT_ROTATE_90_CCW() {
        return (int) 8L;
    }

    public static int JXL_CHANNEL_ALPHA() {
        return (int) 0L;
    }

    public static int JXL_CHANNEL_DEPTH() {
        return (int) 1L;
    }

    public static int JXL_CHANNEL_SPOT_COLOR() {
        return (int) 2L;
    }

    public static int JXL_CHANNEL_SELECTION_MASK() {
        return (int) 3L;
    }

    public static int JXL_CHANNEL_BLACK() {
        return (int) 4L;
    }

    public static int JXL_CHANNEL_CFA() {
        return (int) 5L;
    }

    public static int JXL_CHANNEL_THERMAL() {
        return (int) 6L;
    }

    public static int JXL_CHANNEL_RESERVED0() {
        return (int) 7L;
    }

    public static int JXL_CHANNEL_RESERVED1() {
        return (int) 8L;
    }

    public static int JXL_CHANNEL_RESERVED2() {
        return (int) 9L;
    }

    public static int JXL_CHANNEL_RESERVED3() {
        return (int) 10L;
    }

    public static int JXL_CHANNEL_RESERVED4() {
        return (int) 11L;
    }

    public static int JXL_CHANNEL_RESERVED5() {
        return (int) 12L;
    }

    public static int JXL_CHANNEL_RESERVED6() {
        return (int) 13L;
    }

    public static int JXL_CHANNEL_RESERVED7() {
        return (int) 14L;
    }

    public static int JXL_CHANNEL_UNKNOWN() {
        return (int) 15L;
    }

    public static int JXL_CHANNEL_OPTIONAL() {
        return (int) 16L;
    }

    public static OfInt JxlParallelRetCode = Constants$root.C_INT$LAYOUT;

    public static MethodHandle JxlDecoderVersion$MH() {
        return RuntimeHelper.requireNonNull(constants$1.JxlDecoderVersion$MH, "JxlDecoderVersion");
    }

    /**
     * Decoder library version.
     *
     * @return the decoder library version as an integer:
     * MAJOR_VERSION * 1000000 + MINOR_VERSION * 1000 + PATCH_VERSION. For example,
     * version 1.2.3 would return 1002003.
     */
    public static int JxlDecoderVersion() {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.JxlDecoderVersion$MH, "JxlDecoderVersion");
        try {
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Not enough bytes were passed to determine if a valid signature was found.
     */
    public static int JXL_SIG_NOT_ENOUGH_BYTES() {
        return (int) 0L;
    }

    /**
     * No valid JPEGXL header was found.
     */
    public static int JXL_SIG_INVALID() {
        return (int) 1L;
    }

    /**
     * A valid JPEG XL codestream signature was found, that is a JPEG XL image
     * without container.
     */
    public static int JXL_SIG_CODESTREAM() {
        return (int) 2L;
    }

    /**
     * A valid container signature was found, that is a JPEG XL image embedded
     * in a box format container.
     */
    public static int JXL_SIG_CONTAINER() {
        return (int) 3L;
    }

    public static MethodHandle JxlSignatureCheck$MH() {
        return RuntimeHelper.requireNonNull(constants$1.JxlSignatureCheck$MH, "JxlSignatureCheck");
    }

    /**
     * JPEG XL signature identification.
     * <p>
     * Checks if the passed buffer contains a valid JPEG XL signature. The passed
     * buf of size len doesn't need to be a full image, only the beginning of the file.
     *
     * @return a flag indicating if a JPEG XL signature was found and what type.
     * - JXL_SIG_NOT_ENOUGH_BYTES not enough bytes were passed to determine
     * if a valid signature is there.
     * - JXL_SIG_INVALID: no valid signature found for JPEG XL decoding.
     * - JXL_SIG_CODESTREAM a valid JPEG XL codestream signature was found.
     * - JXL_SIG_CONTAINER a valid JPEG XL container signature was found.
     */
    public static int JxlSignatureCheck(Addressable buf, long len) {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.JxlSignatureCheck$MH, "JxlSignatureCheck");
        try {
            return (int) mh$.invokeExact(buf, len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderCreate$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderCreate$MH, "JxlDecoderCreate");
    }

    /**
     * Creates an instance of JxlDecoder and initializes it.
     * <p>
     * memory_manager will be used for all the library dynamic allocations made
     * from this instance. The parameter may be NULL, in which case the default
     * allocator will be used. See jpegxl/memory_manager.h for details.
     *
     * @param memory_manager custom allocator function. It may be NULL. The memory
     *                       manager will be copied internally.
     * @return NULL if the instance can not be allocated or initialized, pointer to initialized JxlDecoder otherwise
     */
    public static MemoryAddress JxlDecoderCreate(Addressable memory_manager) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderCreate$MH, "JxlDecoderCreate");
        try {
            return (jdk.incubator.foreign.MemoryAddress) mh$.invokeExact(memory_manager);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderReset$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderReset$MH, "JxlDecoderReset");
    }

    public static void JxlDecoderReset(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderReset$MH, "JxlDecoderReset");
        try {
            mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderDestroy$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderDestroy$MH, "JxlDecoderDestroy");
    }

    /**
     * Deinitializes and frees JxlDecoder instance.
     *
     * @param dec instance to be cleaned up and deallocated.
     */
    public static void JxlDecoderDestroy(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderDestroy$MH, "JxlDecoderDestroy");
        try {
            mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Function call finished successfully, or decoding is finished and there is
     * nothing more to be done.
     */
    public static int JXL_DEC_SUCCESS() {
        return (int) 0L;
    }

    /**
     * An error occurred, for example invalid input file or out of memory.
     */
    public static int JXL_DEC_ERROR() {
        return (int) 1L;
    }

    /**
     * The decoder needs more input bytes to continue. Before the next
     * JxlDecoderProcessInput call, more input data must be set, by calling
     * JxlDecoderReleaseInput (if input was set previously) and then calling
     * JxlDecoderSetInput. JxlDecoderReleaseInput returns how many bytes are
     * not yet processed, before a next call to JxlDecoderProcessInput all
     * unprocessed bytes must be provided again (the address need not match, but
     * the contents must), and more bytes must be concatenated after the
     * unprocessed bytes.
     */
    public static int JXL_DEC_NEED_MORE_INPUT() {
        return (int) 2L;
    }

    /**
     * The decoder is able to decode a preview image and requests setting a
     * preview output buffer using JxlDecoderSetPreviewOutBuffer. This occurs if
     * JXL_DEC_PREVIEW_IMAGE is requested and it is possible to decode a preview
     * image from the codestream and the preview out buffer was not yet set. There
     * is maximum one preview image in a codestream.
     */
    public static int JXL_DEC_NEED_PREVIEW_OUT_BUFFER() {
        return (int) 3L;
    }

    /**
     * The decoder is able to decode a DC image and requests setting a DC output
     * buffer using JxlDecoderSetDCOutBuffer. This occurs if JXL_DEC_DC_IMAGE is
     * requested and it is possible to decode a DC image from the codestream and
     * the DC out buffer was not yet set. This event re-occurs for new frames
     * if there are multiple animation frames.
     * DEPRECATED: the DC feature in this form will be removed. You can use
     * JxlDecoderFlushImage for progressive rendering.
     */
    public static int JXL_DEC_NEED_DC_OUT_BUFFER() {
        return (int) 4L;
    }

    /**
     * The decoder requests an output buffer to store the full resolution image,
     * which can be set with JxlDecoderSetImageOutBuffer or with
     * JxlDecoderSetImageOutCallback. This event re-occurs for new frames if there
     * are multiple animation frames and requires setting an output again.
     */
    public static int JXL_DEC_NEED_IMAGE_OUT_BUFFER() {
        return (int) 5L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: JPEG reconstruction buffer is
     * too small for reconstructed JPEG codestream to fit.
     * JxlDecoderSetJPEGBuffer must be called again to make room for remaining
     * bytes. This event may occur multiple times after
     * JXL_DEC_JPEG_RECONSTRUCTION
     */
    public static int JXL_DEC_JPEG_NEED_MORE_OUTPUT() {
        return (int) 6L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: basic information such as
     * image dimensions and extra channels. This event occurs max once per image.
     */
    public static int JXL_DEC_BASIC_INFO() {
        return (int) 64L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: user extensions of the
     * codestream header. This event occurs max once per image and always later
     * than JXL_DEC_BASIC_INFO and earlier than any pixel data.
     */
    public static int JXL_DEC_EXTENSIONS() {
        return (int) 128L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: color encoding or ICC
     * profile from the codestream header. This event occurs max once per image
     * and always later than JXL_DEC_BASIC_INFO and earlier than any pixel
     * data.
     */
    public static int JXL_DEC_COLOR_ENCODING() {
        return (int) 256L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: Preview image, a small
     * frame, decoded. This event can only happen if the image has a preview
     * frame encoded. This event occurs max once for the codestream and always
     * later than JXL_DEC_COLOR_ENCODING and before JXL_DEC_FRAME.
     */
    public static int JXL_DEC_PREVIEW_IMAGE() {
        return (int) 512L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: Beginning of a frame.
     * JxlDecoderGetFrameHeader can be used at this point. A note on frames:
     * a JPEG XL image can have internal frames that are not intended to be
     * displayed (e.g. used for compositing a final frame), but this only returns
     * displayed frames. A displayed frame either has an animation duration or is
     * the only or last frame in the image. This event occurs max once per
     * displayed frame, always later than JXL_DEC_COLOR_ENCODING, and always
     * earlier than any pixel data. While JPEG XL supports encoding a single frame
     * as the composition of multiple internal sub-frames also called frames, this
     * event is not indicated for the internal frames.
     */
    public static int JXL_DEC_FRAME() {
        return (int) 1024L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: DC image, 8x8 sub-sampled
     * frame, decoded. It is not guaranteed that the decoder will always return DC
     * separately, but when it does it will do so before outputting the full
     * frame. JxlDecoderSetDCOutBuffer must be used after getting the basic
     * image information to be able to get the DC pixels, if not this return
     * status only indicates we're past this point in the codestream. This event
     * occurs max once per frame and always later than JXL_DEC_FRAME_HEADER
     * and other header events and earlier than full resolution pixel data.
     * DEPRECATED: the DC feature in this form will be removed. You can use
     * JxlDecoderFlushImage for progressive rendering.
     */
    public static int JXL_DEC_DC_IMAGE() {
        return (int) 2048L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: full frame decoded.
     * JxlDecoderSetImageOutBuffer must be used after getting the basic image
     * information to be able to get the image pixels, if not this return status
     * only indicates we're past this point in the codestream. This event occurs
     * max once per frame and always later than JXL_DEC_DC_IMAGE.
     */
    public static int JXL_DEC_FULL_IMAGE() {
        return (int) 4096L;
    }

    /**
     * Informative event by JxlDecoderProcessInput: JPEG reconstruction data
     * decoded. JxlDecoderSetJPEGBuffer may be used to set a JPEG
     * reconstruction buffer after getting the JPEG reconstruction data. If a JPEG
     * reconstruction buffer is set a byte stream identical to the JPEG codestream
     * used to encode the image will be written to the JPEG reconstruction buffer
     * instead of pixels to the image out buffer. This event occurs max once per
     * image and always before JXL_DEC_FULL_IMAGE.
     */
    public static int JXL_DEC_JPEG_RECONSTRUCTION() {
        return (int) 8192L;
    }

    public static MethodHandle JxlDecoderRewind$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderRewind$MH, "JxlDecoderRewind");
    }

    public static void JxlDecoderRewind(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderRewind$MH, "JxlDecoderRewind");
        try {
            mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSkipFrames$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderSkipFrames$MH, "JxlDecoderSkipFrames");
    }

    public static void JxlDecoderSkipFrames(Addressable dec, long amount) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderSkipFrames$MH, "JxlDecoderSkipFrames");
        try {
            mh$.invokeExact(dec, amount);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderDefaultPixelFormat$MH() {
        return RuntimeHelper.requireNonNull(constants$2.JxlDecoderDefaultPixelFormat$MH, "JxlDecoderDefaultPixelFormat");
    }

    public static int JxlDecoderDefaultPixelFormat(Addressable dec, Addressable format) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.JxlDecoderDefaultPixelFormat$MH, "JxlDecoderDefaultPixelFormat");
        try {
            return (int) mh$.invokeExact(dec, format);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetParallelRunner$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetParallelRunner$MH, "JxlDecoderSetParallelRunner");
    }

    public static int JxlDecoderSetParallelRunner(Addressable dec, Addressable parallel_runner, Addressable parallel_runner_opaque) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetParallelRunner$MH, "JxlDecoderSetParallelRunner");
        try {
            return (int) mh$.invokeExact(dec, parallel_runner, parallel_runner_opaque);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSizeHintBasicInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderSizeHintBasicInfo$MH, "JxlDecoderSizeHintBasicInfo");
    }

    public static long JxlDecoderSizeHintBasicInfo(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderSizeHintBasicInfo$MH, "JxlDecoderSizeHintBasicInfo");
        try {
            return (long) mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSubscribeEvents$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderSubscribeEvents$MH, "JxlDecoderSubscribeEvents");
    }

    /**
     * Select for which informative events (JXL_DEC_BASIC_INFO, etc...) the
     * decoder should return with a status. It is not required to subscribe to any
     * events, data can still be requested from the decoder as soon as it available.
     * By default, the decoder is subscribed to no events (events_wanted == 0), and
     * the decoder will then only return when it cannot continue because it needs
     * more input data or more output buffer. This function may only be be called
     * before using JxlDecoderProcessInput
     *
     * @param dec           decoder object
     * @param events_wanted bitfield of desired events.
     * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.
     */
    public static int JxlDecoderSubscribeEvents(Addressable dec, int events_wanted) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderSubscribeEvents$MH, "JxlDecoderSubscribeEvents");
        try {
            return (int) mh$.invokeExact(dec, events_wanted);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetKeepOrientation$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetKeepOrientation$MH, "JxlDecoderSetKeepOrientation");
    }

    /**
     * Enables or disables preserving of original orientation. Some images are
     * encoded with an orientation tag indicating the image is rotated and/or
     * mirrored (here called the original orientation).
     * <p>
     * *) If keep_orientation is JXL_FALSE (the default): the decoder will perform
     * work to undo the transformation. This ensures the decoded pixels will not
     * be rotated or mirrored. The decoder will always set the orientation field
     * of the JxlBasicInfo to JXL_ORIENT_IDENTITY to match the returned pixel data.
     * The decoder may also swap xsize and ysize in the JxlBasicInfo compared to the
     * values inside of the codestream, to correctly match the decoded pixel data,
     * e.g. when a 90 degree rotation was performed.
     * <p>
     * *) If this option is JXL_TRUE: then the image is returned as-is, which may be
     * rotated or mirrored, and the user must check the orientation field in
     * JxlBasicInfo after decoding to correctly interpret the decoded pixel data.
     * This may be faster to decode since the decoder doesn't have to apply the
     * transformation, but can cause wrong display of the image if the orientation
     * tag is not correctly taken into account by the user.
     * <p>
     * By default, this option is disabled, and the decoder automatically corrects
     * the orientation.
     * <p>
     * This function must be called at the beginning, before decoding is performed.
     *
     * @param dec              decoder object
     * @param keep_orientation JXL_TRUE to enable, JXL_FALSE to disable.
     * @return JXL_DEC_SUCCESS if no error, JXL_DEC_ERROR otherwise.
     * see JxlBasicInfo for the orientation field
     * see JxlOrientation for the possible values.
     */
    public static int JxlDecoderSetKeepOrientation(Addressable dec, int keep_orientation) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetKeepOrientation$MH, "JxlDecoderSetKeepOrientation");
        try {
            return (int) mh$.invokeExact(dec, keep_orientation);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderProcessInput$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderProcessInput$MH, "JxlDecoderProcessInput");
    }

    /**
     * Decodes JPEG XL file using the available bytes. Requires input has been
     * set with JxlDecoderSetInput. After JxlDecoderProcessInput, input can
     * optionally be released with JxlDecoderReleaseInput and then set again to
     * next bytes in the stream. JxlDecoderReleaseInput returns how many bytes are
     * not yet processed, before a next call to JxlDecoderProcessInput all
     * unprocessed bytes must be provided again (the address need not match, but the
     * contents must), and more bytes may be concatenated after the unprocessed
     * bytes.
     * <p>
     * The returned status indicates whether the decoder needs more input bytes, or
     * more output buffer for a certain type of output data. No matter what the
     * returned status is (other than JXL_DEC_ERROR), new information, such as
     * JxlDecoderGetBasicInfo, may have become available after this call. When
     * the return value is not JXL_DEC_ERROR or JXL_DEC_SUCCESS, the decoding
     * requires more JxlDecoderProcessInput calls to continue.
     *
     * @param dec decoder object
     * @return JXL_DEC_SUCCESS when decoding finished and all events handled.
     * JXL_DEC_ERROR when decoding failed, e.g. invalid codestream.
     * JXL_DEC_NEED_MORE_INPUT more input data is necessary.
     * JXL_DEC_BASIC_INFO when basic info such as image dimensions is available and this informative event is subscribed to.
     * JXL_DEC_EXTENSIONS when JPEG XL codestream user extensions are available and this informative event is subscribed to.
     * JXL_DEC_COLOR_ENCODING when color profile information is available and this informative event is subscribed to.
     * JXL_DEC_PREVIEW_IMAGE when preview pixel information is available and output in the preview buffer.
     * JXL_DEC_DC_IMAGE when DC pixel information (8x8 downscaled version of the image) is available and output in the DC buffer.
     * JXL_DEC_FULL_IMAGE when all pixel information at highest detail is available and has been output in the pixel buffer.
     */
    public static int JxlDecoderProcessInput(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderProcessInput$MH, "JxlDecoderProcessInput");
        try {
            return (int) mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetInput$MH() {
        return RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetInput$MH, "JxlDecoderSetInput");
    }

    /**
     * Sets input data for JxlDecoderProcessInput. The data is owned by the caller
     * and may be used by the decoder until JxlDecoderReleaseInput is called or
     * the decoder is destroyed or reset so must be kept alive until then.
     *
     * @param dec  decoder object
     * @param data pointer to next bytes to read from
     * @param size amount of bytes available starting from data
     * @return JXL_DEC_ERROR if input was already set without releasing,
     * JXL_DEC_SUCCESS otherwise
     */
    public static int JxlDecoderSetInput(Addressable dec, Addressable data, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.JxlDecoderSetInput$MH, "JxlDecoderSetInput");
        try {
            return (int) mh$.invokeExact(dec, data, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderReleaseInput$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderReleaseInput$MH, "JxlDecoderReleaseInput");
    }

    /**
     * Releases input which was provided with JxlDecoderSetInput. Between
     * JxlDecoderProcessInput and JxlDecoderReleaseInput, the user may not alter
     * the data in the buffer. Calling JxlDecoderReleaseInput is required whenever
     * any input is already set and new input needs to be added with
     * JxlDecoderSetInput, but is not required before JxlDecoderDestroy or
     * JxlDecoderReset. Calling JxlDecoderReleaseInput when no input is set is
     * not an error and returns 0.
     *
     * @param dec decoder object
     * @return the amount of bytes the decoder has not yet processed that are
     * still remaining in the data set by JxlDecoderSetInput, or 0 if no input is
     * set or JxlDecoderReleaseInput was already called. For a next call to
     * JxlDecoderProcessInput, the buffer must start with these unprocessed bytes.
     * This value doesn't provide information about how many bytes the decoder
     * truly processed internally or how large the original JPEG XL codestream or
     * file are.
     */
    public static long JxlDecoderReleaseInput(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderReleaseInput$MH, "JxlDecoderReleaseInput");
        try {
            return (long) mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetBasicInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetBasicInfo$MH, "JxlDecoderGetBasicInfo");
    }

    /**
     * Outputs the basic image information, such as image dimensions, bit depth and
     * all other JxlBasicInfo fields, if available.
     *
     * @param dec  decoder object
     * @param info struct to copy the information into, or NULL to only check
     *             whether the information is available through the return value.
     * @return JXL_DEC_SUCCESS if the value is available,
     * JXL_DEC_NEED_MORE_INPUT if not yet available, JXL_DEC_ERROR in case
     * of other error conditions.
     */
    public static int JxlDecoderGetBasicInfo(Addressable dec, Addressable info) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetBasicInfo$MH, "JxlDecoderGetBasicInfo");
        try {
            return (int) mh$.invokeExact(dec, info);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetExtraChannelInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetExtraChannelInfo$MH, "JxlDecoderGetExtraChannelInfo");
    }

    public static int JxlDecoderGetExtraChannelInfo(Addressable dec, long index, Addressable info) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetExtraChannelInfo$MH, "JxlDecoderGetExtraChannelInfo");
        try {
            return (int) mh$.invokeExact(dec, index, info);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetExtraChannelName$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetExtraChannelName$MH, "JxlDecoderGetExtraChannelName");
    }

    public static int JxlDecoderGetExtraChannelName(Addressable dec, long index, Addressable name, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetExtraChannelName$MH, "JxlDecoderGetExtraChannelName");
        try {
            return (int) mh$.invokeExact(dec, index, name, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Get the color profile of the original image from the metadata.
     */
    public static int JXL_COLOR_PROFILE_TARGET_ORIGINAL() {
        return (int) 0L;
    }

    /**
     * Get the color profile of the original image from the metadata.
     */
    public static int JXL_COLOR_PROFILE_TARGET_DATA() {
        return (int) 1L;
    }

    public static MethodHandle JxlDecoderGetColorAsEncodedProfile$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetColorAsEncodedProfile$MH, "JxlDecoderGetColorAsEncodedProfile");
    }

    public static int JxlDecoderGetColorAsEncodedProfile(Addressable dec, Addressable format, int target, Addressable color_encoding) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetColorAsEncodedProfile$MH, "JxlDecoderGetColorAsEncodedProfile");
        try {
            return (int) mh$.invokeExact(dec, format, target, color_encoding);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetICCProfileSize$MH() {
        return RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetICCProfileSize$MH, "JxlDecoderGetICCProfileSize");
    }

    /**
     * Outputs the size in bytes of the ICC profile returned by
     * JxlDecoderGetColorAsICCProfile, if available, or indicates there is none
     * available. In most cases, the image will have an ICC profile available, but
     * if it does not, JxlDecoderGetColorAsEncodedProfile must be used instead.
     *
     * @param dec    decoder object
     * @param format pixel format to output the data to. Only used for
     *               JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.
     * @param target whether to get the original color profile from the metadata
     *               or the color profile of the decoded pixels.
     * @param size   variable to output the size into, or NULL to only check the
     *               return status.
     * @return JXL_DEC_SUCCESS if the ICC profile is available,
     * JXL_DEC_NEED_MORE_INPUT if the decoder has not yet received enough
     * input data to determine whether an ICC profile is available or what its
     * size is, JXL_DEC_ERROR in case the ICC profile is not available and
     * cannot be generated.
     * JxlDecoderGetColorAsEncodedProfile for more information. The ICC
     * profile is either the exact ICC profile attached to the codestream metadata,
     * or a close approximation generated from JPEG XL encoded structured data,
     * depending of what is encoded in the codestream.
     */
    public static int JxlDecoderGetICCProfileSize(Addressable dec, Addressable format, int target, Addressable size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$4.JxlDecoderGetICCProfileSize$MH, "JxlDecoderGetICCProfileSize");
        try {
            return (int) mh$.invokeExact(dec, format, target, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetColorAsICCProfile$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetColorAsICCProfile$MH, "JxlDecoderGetColorAsICCProfile");
    }

    /**
     * Outputs ICC profile if available. The profile is only available if
     * JxlDecoderGetICCProfileSize returns success. The output buffer must have
     * at least as many bytes as given by JxlDecoderGetICCProfileSize.
     *
     * @param dec         decoder object
     * @param format      pixel format to output the data to. Only used for
     *                    JXL_COLOR_PROFILE_TARGET_DATA, may be nullptr otherwise.
     * @param target      whether to get the original color profile from the metadata
     *                    or the color profile of the decoded pixels.
     * @param icc_profile buffer to copy the ICC profile into
     * @param size        size of the icc_profile buffer in bytes
     * @return JXL_DEC_SUCCESS if the profile was successfully returned is
     * available, JXL_DEC_NEED_MORE_INPUT if not yet available,
     * JXL_DEC_ERROR if the profile doesn't exist or the output size is not
     * large enough.
     */
    public static int JxlDecoderGetColorAsICCProfile(Addressable dec, Addressable format, int target, Addressable icc_profile, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetColorAsICCProfile$MH, "JxlDecoderGetColorAsICCProfile");
        try {
            return (int) mh$.invokeExact(dec, format, target, icc_profile, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetPreferredColorProfile$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderSetPreferredColorProfile$MH, "JxlDecoderSetPreferredColorProfile");
    }

    public static int JxlDecoderSetPreferredColorProfile(Addressable dec, Addressable color_encoding) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderSetPreferredColorProfile$MH, "JxlDecoderSetPreferredColorProfile");
        try {
            return (int) mh$.invokeExact(dec, color_encoding);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderPreviewOutBufferSize$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderPreviewOutBufferSize$MH, "JxlDecoderPreviewOutBufferSize");
    }

    public static int JxlDecoderPreviewOutBufferSize(Addressable dec, Addressable format, Addressable size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderPreviewOutBufferSize$MH, "JxlDecoderPreviewOutBufferSize");
        try {
            return (int) mh$.invokeExact(dec, format, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetPreviewOutBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderSetPreviewOutBuffer$MH, "JxlDecoderSetPreviewOutBuffer");
    }

    public static int JxlDecoderSetPreviewOutBuffer(Addressable dec, Addressable format, Addressable buffer, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderSetPreviewOutBuffer$MH, "JxlDecoderSetPreviewOutBuffer");
        try {
            return (int) mh$.invokeExact(dec, format, buffer, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetFrameHeader$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetFrameHeader$MH, "JxlDecoderGetFrameHeader");
    }

    public static int JxlDecoderGetFrameHeader(Addressable dec, Addressable header) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetFrameHeader$MH, "JxlDecoderGetFrameHeader");
        try {
            return (int) mh$.invokeExact(dec, header);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderGetFrameName$MH() {
        return RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetFrameName$MH, "JxlDecoderGetFrameName");
    }

    public static int JxlDecoderGetFrameName(Addressable dec, Addressable name, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$5.JxlDecoderGetFrameName$MH, "JxlDecoderGetFrameName");
        try {
            return (int) mh$.invokeExact(dec, name, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderDCOutBufferSize$MH() {
        return RuntimeHelper.requireNonNull(constants$6.JxlDecoderDCOutBufferSize$MH, "JxlDecoderDCOutBufferSize");
    }

    public static int JxlDecoderDCOutBufferSize(Addressable dec, Addressable format, Addressable size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$6.JxlDecoderDCOutBufferSize$MH, "JxlDecoderDCOutBufferSize");
        try {
            return (int) mh$.invokeExact(dec, format, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetDCOutBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$6.JxlDecoderSetDCOutBuffer$MH, "JxlDecoderSetDCOutBuffer");
    }

    public static int JxlDecoderSetDCOutBuffer(Addressable dec, Addressable format, Addressable buffer, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$6.JxlDecoderSetDCOutBuffer$MH, "JxlDecoderSetDCOutBuffer");
        try {
            return (int) mh$.invokeExact(dec, format, buffer, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderImageOutBufferSize$MH() {
        return RuntimeHelper.requireNonNull(constants$6.JxlDecoderImageOutBufferSize$MH, "JxlDecoderImageOutBufferSize");
    }

    /**
     * Returns the minimum size in bytes of the image output pixel buffer for the
     * given format. This is the buffer for JxlDecoderSetImageOutBuffer. Requires
     * the basic image information is available in the decoder.
     *
     * @param dec    decoder object
     * @param format format of the pixels.
     * @param size   output value, buffer size in bytes
     * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as
     * information not available yet.
     */
    public static int JxlDecoderImageOutBufferSize(Addressable dec, Addressable format, Addressable size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$6.JxlDecoderImageOutBufferSize$MH, "JxlDecoderImageOutBufferSize");
        try {
            return (int) mh$.invokeExact(dec, format, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetImageOutBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$6.JxlDecoderSetImageOutBuffer$MH, "JxlDecoderSetImageOutBuffer");
    }

    /**
     * Sets the buffer to write the full resolution image to. This can be set when
     * the JXL_DEC_FRAME event occurs, must be set when the
     * JXL_DEC_NEED_IMAGE_OUT_BUFFER event occurs, and applies only for the current
     * frame. The size of the buffer must be at least as large as given by
     * JxlDecoderImageOutBufferSize. The buffer follows the format described by
     * JxlPixelFormat. The buffer is owned by the caller.
     *
     * @param dec    decoder object
     * @param format format of the pixels. Object owned by user and its contents
     *               are copied internally.
     * @param buffer buffer type to output the pixel data to
     * @param size   size of buffer in bytes
     * @return JXL_DEC_SUCCESS on success, JXL_DEC_ERROR on error, such as
     * size too small.
     */
    public static int JxlDecoderSetImageOutBuffer(Addressable dec, Addressable format, Addressable buffer, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$6.JxlDecoderSetImageOutBuffer$MH, "JxlDecoderSetImageOutBuffer");
        try {
            return (int) mh$.invokeExact(dec, format, buffer, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetImageOutCallback$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetImageOutCallback$MH, "JxlDecoderSetImageOutCallback");
    }

    public static int JxlDecoderSetImageOutCallback(Addressable dec, Addressable format, Addressable callback, Addressable opaque) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetImageOutCallback$MH, "JxlDecoderSetImageOutCallback");
        try {
            return (int) mh$.invokeExact(dec, format, callback, opaque);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderExtraChannelBufferSize$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderExtraChannelBufferSize$MH, "JxlDecoderExtraChannelBufferSize");
    }

    public static int JxlDecoderExtraChannelBufferSize(Addressable dec, Addressable format, Addressable size, int index) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderExtraChannelBufferSize$MH, "JxlDecoderExtraChannelBufferSize");
        try {
            return (int) mh$.invokeExact(dec, format, size, index);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetExtraChannelBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetExtraChannelBuffer$MH, "JxlDecoderSetExtraChannelBuffer");
    }

    public static int JxlDecoderSetExtraChannelBuffer(Addressable dec, Addressable format, Addressable buffer, long size, int index) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetExtraChannelBuffer$MH, "JxlDecoderSetExtraChannelBuffer");
        try {
            return (int) mh$.invokeExact(dec, format, buffer, size, index);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderSetJPEGBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetJPEGBuffer$MH, "JxlDecoderSetJPEGBuffer");
    }

    public static int JxlDecoderSetJPEGBuffer(Addressable dec, Addressable data, long size) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderSetJPEGBuffer$MH, "JxlDecoderSetJPEGBuffer");
        try {
            return (int) mh$.invokeExact(dec, data, size);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderReleaseJPEGBuffer$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderReleaseJPEGBuffer$MH, "JxlDecoderReleaseJPEGBuffer");
    }

    public static long JxlDecoderReleaseJPEGBuffer(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderReleaseJPEGBuffer$MH, "JxlDecoderReleaseJPEGBuffer");
        try {
            return (long) mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle JxlDecoderFlushImage$MH() {
        return RuntimeHelper.requireNonNull(constants$7.JxlDecoderFlushImage$MH, "JxlDecoderFlushImage");
    }

    public static int JxlDecoderFlushImage(Addressable dec) {
        var mh$ = RuntimeHelper.requireNonNull(constants$7.JxlDecoderFlushImage$MH, "JxlDecoderFlushImage");
        try {
            return (int) mh$.invokeExact(dec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MemoryAddress NULL() {
        return constants$8.NULL$ADDR;
    }

    public static long INT64_MAX() {
        return 9223372036854775807L;
    }

    public static long INT64_MIN() {
        return -9223372036854775808L;
    }

    public static long UINT64_MAX() {
        return -1L;
    }

    public static long __INT_LEAST64_MIN() {
        return -9223372036854775808L;
    }

    public static long __INT_LEAST64_MAX() {
        return 9223372036854775807L;
    }

    public static long __UINT_LEAST64_MAX() {
        return -1L;
    }

    public static int __INT_LEAST32_MIN() {
        return (int) -2147483648L;
    }

    public static int __INT_LEAST32_MAX() {
        return (int) 2147483647L;
    }

    public static int __UINT_LEAST32_MAX() {
        return (int) 4294967295L;
    }

    public static int __INT_LEAST16_MIN() {
        return (int) -32768L;
    }

    public static int __INT_LEAST16_MAX() {
        return (int) 32767L;
    }

    public static int __UINT_LEAST16_MAX() {
        return (int) 65535L;
    }

    public static int __INT_LEAST8_MIN() {
        return (int) -128L;
    }

    public static int __INT_LEAST8_MAX() {
        return (int) 127L;
    }

    public static int __UINT_LEAST8_MAX() {
        return (int) 255L;
    }

    public static long INT_LEAST64_MIN() {
        return -9223372036854775808L;
    }

    public static long INT_LEAST64_MAX() {
        return 9223372036854775807L;
    }

    public static long UINT_LEAST64_MAX() {
        return -1L;
    }

    public static long INT_FAST64_MIN() {
        return -9223372036854775808L;
    }

    public static long INT_FAST64_MAX() {
        return 9223372036854775807L;
    }

    public static long UINT_FAST64_MAX() {
        return -1L;
    }

    public static int INT32_MAX() {
        return (int) 2147483647L;
    }

    public static int INT32_MIN() {
        return (int) -2147483648L;
    }

    public static int UINT32_MAX() {
        return (int) 4294967295L;
    }

    public static int INT_LEAST32_MIN() {
        return (int) -2147483648L;
    }

    public static int INT_LEAST32_MAX() {
        return (int) 2147483647L;
    }

    public static int UINT_LEAST32_MAX() {
        return (int) 4294967295L;
    }

    public static int INT_FAST32_MIN() {
        return (int) -2147483648L;
    }

    public static int INT_FAST32_MAX() {
        return (int) 2147483647L;
    }

    public static int UINT_FAST32_MAX() {
        return (int) 4294967295L;
    }

    public static int INT16_MAX() {
        return (int) 32767L;
    }

    public static int INT16_MIN() {
        return (int) -32768L;
    }

    public static int UINT16_MAX() {
        return (int) 65535L;
    }

    public static int INT_LEAST16_MIN() {
        return (int) -32768L;
    }

    public static int INT_LEAST16_MAX() {
        return (int) 32767L;
    }

    public static int UINT_LEAST16_MAX() {
        return (int) 65535L;
    }

    public static int INT_FAST16_MIN() {
        return (int) -32768L;
    }

    public static int INT_FAST16_MAX() {
        return (int) 32767L;
    }

    public static int UINT_FAST16_MAX() {
        return (int) 65535L;
    }

    public static int INT8_MAX() {
        return (int) 127L;
    }

    public static int INT8_MIN() {
        return (int) -128L;
    }

    public static int UINT8_MAX() {
        return (int) 255L;
    }

    public static int INT_LEAST8_MIN() {
        return (int) -128L;
    }

    public static int INT_LEAST8_MAX() {
        return (int) 127L;
    }

    public static int UINT_LEAST8_MAX() {
        return (int) 255L;
    }

    public static int INT_FAST8_MIN() {
        return (int) -128L;
    }

    public static int INT_FAST8_MAX() {
        return (int) 127L;
    }

    public static int UINT_FAST8_MAX() {
        return (int) 255L;
    }

    public static long INTPTR_MIN() {
        return -9223372036854775808L;
    }

    public static long INTPTR_MAX() {
        return 9223372036854775807L;
    }

    public static long UINTPTR_MAX() {
        return -1L;
    }

    public static long PTRDIFF_MIN() {
        return -9223372036854775808L;
    }

    public static long PTRDIFF_MAX() {
        return 9223372036854775807L;
    }

    public static long SIZE_MAX() {
        return -1L;
    }

    public static long INTMAX_MIN() {
        return -9223372036854775808L;
    }

    public static long INTMAX_MAX() {
        return 9223372036854775807L;
    }

    public static long UINTMAX_MAX() {
        return -1L;
    }

    public static int SIG_ATOMIC_MIN() {
        return (int) -2147483648L;
    }

    public static int SIG_ATOMIC_MAX() {
        return (int) 2147483647L;
    }

    public static int WINT_MIN() {
        return (int) -2147483648L;
    }

    public static int WINT_MAX() {
        return (int) 2147483647L;
    }

    public static int WCHAR_MAX() {
        return (int) 2147483647L;
    }

    public static int WCHAR_MIN() {
        return (int) -2147483648L;
    }

    public static int JXL_PARALLEL_RET_RUNNER_ERROR() {
        return (int) -1L;
    }
}



// Generated by jextract

package com.github.gotson.nightmonkeys.webp.lib.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class mux_h {

    mux_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("webp"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _CRT_HAS_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int EDEADLK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 36
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 38
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 39
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 40
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)41L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 41
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EILSEQ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 42
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int STRUNCATE = (int)80L;
    /**
     * {@snippet lang=c :
     * #define STRUNCATE 80
     * }
     */
    public static int STRUNCATE() {
        return STRUNCATE;
    }
    private static final int EADDRINUSE = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 100
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)101L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 101
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int EAFNOSUPPORT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 102
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EALREADY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 103
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EBADMSG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 104
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int ECANCELED = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 105
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ECONNABORTED = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 106
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNREFUSED = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 107
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int ECONNRESET = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 108
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int EDESTADDRREQ = (int)109L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 109
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EHOSTUNREACH = (int)110L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 110
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EIDRM = (int)111L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 111
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int EINPROGRESS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 112
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int EISCONN = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 113
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ELOOP = (int)114L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 114
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int EMSGSIZE = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 115
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int ENETDOWN = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 116
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETRESET = (int)117L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 117
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ENETUNREACH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 118
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENOBUFS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 119
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int ENODATA = (int)120L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 120
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)121L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 121
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOMSG = (int)122L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 122
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int ENOPROTOOPT = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 123
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int ENOSR = (int)124L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 124
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 125
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENOTCONN = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 126
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ENOTRECOVERABLE = (int)127L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 127
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ENOTSOCK = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 128
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int ENOTSUP = (int)129L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 129
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int EOPNOTSUPP = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 130
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EOTHER = (int)131L;
    /**
     * {@snippet lang=c :
     * #define EOTHER 131
     * }
     */
    public static int EOTHER() {
        return EOTHER;
    }
    private static final int EOVERFLOW = (int)132L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 132
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EOWNERDEAD = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 133
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EPROTO = (int)134L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 134
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EPROTONOSUPPORT = (int)135L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 135
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int EPROTOTYPE = (int)136L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 136
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ETIME = (int)137L;
    /**
     * {@snippet lang=c :
     * #define ETIME 137
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ETIMEDOUT = (int)138L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 138
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ETXTBSY = (int)139L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 139
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EWOULDBLOCK = (int)140L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 140
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int WEBP_MUX_ABI_VERSION = (int)265L;
    /**
     * {@snippet lang=c :
     * #define WEBP_MUX_ABI_VERSION 265
     * }
     */
    public static int WEBP_MUX_ABI_VERSION() {
        return WEBP_MUX_ABI_VERSION;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = mux_h.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                mux_h.C_POINTER
            );
        private static final MemorySegment ADDR = mux_h.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = mux_h.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = mux_h.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = mux_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = mux_h.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = mux_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = mux_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = mux_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = mux_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = mux_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = mux_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = mux_h.C_LONG_LONG;

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor _memicmp$descriptor() {
        return _memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle _memicmp$handle() {
        return _memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment _memicmp$address() {
        return _memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int _memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = _memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_memicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _memicmp_l$descriptor() {
        return _memicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _memicmp_l$handle() {
        return _memicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _memicmp_l$address() {
        return _memicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _memicmp_l(MemorySegment _Buf1, MemorySegment _Buf2, long _Size, MemorySegment _Locale) {
        var mh$ = _memicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp_l", _Buf1, _Buf2, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _Size) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", _Dst, _Src, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memicmp$descriptor() {
        return memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memicmp$handle() {
        return memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memicmp$address() {
        return memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_SHORT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_SHORT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_SHORT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy_s$descriptor() {
        return strcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcpy_s$handle() {
        return strcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcpy_s$address() {
        return strcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat_s$descriptor() {
        return strcat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcat_s$handle() {
        return strcat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcat_s$address() {
        return strcat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor strerror_s$descriptor() {
        return strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MethodHandle strerror_s$handle() {
        return strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MemorySegment strerror_s$address() {
        return strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static int strerror_s(MemorySegment _Buffer, long _SizeInBytes, int _ErrorNumber) {
        var mh$ = strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_s", _Buffer, _SizeInBytes, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncat_s$descriptor() {
        return strncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncat_s$handle() {
        return strncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncat_s$address() {
        return strncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncpy_s$descriptor() {
        return strncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncpy_s$handle() {
        return strncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncpy_s$address() {
        return strncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strtok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static FunctionDescriptor strtok_s$descriptor() {
        return strtok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MethodHandle strtok_s$handle() {
        return strtok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s$address() {
        return strtok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = strtok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _memccpy$descriptor() {
        return _memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle _memccpy$handle() {
        return _memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy$address() {
        return _memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _MaxCount) {
        var mh$ = _memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memccpy", _Dst, _Src, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static int strcmp(MemorySegment _Str1, MemorySegment _Str2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", _Str1, _Str2);
            }
            return (int)mh$.invokeExact(_Str1, _Str2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _strcmpi$descriptor() {
        return _strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _strcmpi$handle() {
        return _strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _strcmpi$address() {
        return _strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int _strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static int strcoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strcoll_l$descriptor() {
        return _strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strcoll_l$handle() {
        return _strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strcoll_l$address() {
        return _strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _strcoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strcspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static FunctionDescriptor _strdup$descriptor() {
        return _strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MethodHandle _strdup$handle() {
        return _strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup$address() {
        return _strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup(MemorySegment _Source) {
        var mh$ = _strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdup", _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror$descriptor() {
        return _strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror$handle() {
        return _strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror$address() {
        return _strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror(MemorySegment _ErrorMessage) {
        var mh$ = _strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror_s$descriptor() {
        return _strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror_s$handle() {
        return _strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror_s$address() {
        return _strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static int _strerror_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _ErrorMessage) {
        var mh$ = _strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror_s", _Buffer, _SizeInBytes, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror(int _ErrorMessage) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricmp$descriptor() {
        return _stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricmp$handle() {
        return _stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricmp$address() {
        return _stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_stricoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricoll$descriptor() {
        return _stricoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricoll$handle() {
        return _stricoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricoll$address() {
        return _stricoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_stricoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricoll_l$descriptor() {
        return _stricoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricoll_l$handle() {
        return _stricoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricoll_l$address() {
        return _stricoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_stricmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricmp_l$descriptor() {
        return _stricmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricmp_l$handle() {
        return _stricmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricmp_l$address() {
        return _stricmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static long strlen(MemorySegment _Str) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", _Str);
            }
            return (long)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strlwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strlwr_s$descriptor() {
        return _strlwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strlwr_s$handle() {
        return _strlwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strlwr_s$address() {
        return _strlwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strlwr_s(MemorySegment _String, long _Size) {
        var mh$ = _strlwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor _strlwr$descriptor() {
        return _strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MethodHandle _strlwr$handle() {
        return _strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr$address() {
        return _strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr(MemorySegment _String) {
        var mh$ = _strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strlwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_s_l$descriptor() {
        return _strlwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_s_l$handle() {
        return _strlwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_s_l$address() {
        return _strlwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strlwr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strlwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strlwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_l$descriptor() {
        return _strlwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_l$handle() {
        return _strlwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l$address() {
        return _strlwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strlwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static int strncmp(MemorySegment _Str1, MemorySegment _Str2, long _MaxCount) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", _Str1, _Str2, _MaxCount);
            }
            return (int)mh$.invokeExact(_Str1, _Str2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicmp$descriptor() {
        return _strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicmp$handle() {
        return _strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicmp$address() {
        return _strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicmp_l$descriptor() {
        return _strnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicmp_l$handle() {
        return _strnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicmp_l$address() {
        return _strnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicoll$descriptor() {
        return _strnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicoll$handle() {
        return _strnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicoll$address() {
        return _strnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicoll_l$descriptor() {
        return _strnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicoll_l$handle() {
        return _strnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicoll_l$address() {
        return _strnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strncoll$descriptor() {
        return _strncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strncoll$handle() {
        return _strncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strncoll$address() {
        return _strncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strncoll_l$descriptor() {
        return _strncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strncoll_l$handle() {
        return _strncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strncoll_l$address() {
        return _strncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strncnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("__strncnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static FunctionDescriptor __strncnt$descriptor() {
        return __strncnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MethodHandle __strncnt$handle() {
        return __strncnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MemorySegment __strncnt$address() {
        return __strncnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static long __strncnt(MemorySegment _String, long _Count) {
        var mh$ = __strncnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strncnt", _String, _Count);
            }
            return (long)mh$.invokeExact(_String, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long strnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnset_s$descriptor() {
        return _strnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnset_s$handle() {
        return _strnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnset_s$address() {
        return _strnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static int _strnset_s(MemorySegment _String, long _SizeInBytes, int _Value, long _MaxCount) {
        var mh$ = _strnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset_s", _String, _SizeInBytes, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_String, _SizeInBytes, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static FunctionDescriptor _strnset$descriptor() {
        return _strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MethodHandle _strnset$handle() {
        return _strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset$address() {
        return _strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset(MemorySegment _Destination, int _Value, long _Count) {
        var mh$ = _strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset", _Destination, _Value, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", _Str, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static FunctionDescriptor _strrev$descriptor() {
        return _strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MethodHandle _strrev$handle() {
        return _strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev$address() {
        return _strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev(MemorySegment _Str) {
        var mh$ = _strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strrev", _Str);
            }
            return (MemorySegment)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static FunctionDescriptor _strset_s$descriptor() {
        return _strset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MethodHandle _strset_s$handle() {
        return _strset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MemorySegment _strset_s$address() {
        return _strset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static int _strset_s(MemorySegment _Destination, long _DestinationSize, int _Value) {
        var mh$ = _strset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset_s", _Destination, _DestinationSize, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _DestinationSize, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static FunctionDescriptor _strset$descriptor() {
        return _strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MethodHandle _strset$handle() {
        return _strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset$address() {
        return _strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset(MemorySegment _Destination, int _Value) {
        var mh$ = _strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset", _Destination, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok(MemorySegment _String, MemorySegment _Delimiter) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", _String, _Delimiter);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strupr_s$descriptor() {
        return _strupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strupr_s$handle() {
        return _strupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strupr_s$address() {
        return _strupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strupr_s(MemorySegment _String, long _Size) {
        var mh$ = _strupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static FunctionDescriptor _strupr$descriptor() {
        return _strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MethodHandle _strupr$handle() {
        return _strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr$address() {
        return _strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr(MemorySegment _String) {
        var mh$ = _strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_s_l$descriptor() {
        return _strupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_s_l$handle() {
        return _strupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_s_l$address() {
        return _strupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_l$descriptor() {
        return _strupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_l$handle() {
        return _strupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l$address() {
        return _strupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long strxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("_strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strxfrm_l$descriptor() {
        return _strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strxfrm_l$handle() {
        return _strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strxfrm_l$address() {
        return _strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _strxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup(MemorySegment _String) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcmpi$descriptor() {
        return strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcmpi$handle() {
        return strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcmpi$address() {
        return strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor stricmp$descriptor() {
        return stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle stricmp$handle() {
        return stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment stricmp$address() {
        return stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor strlwr$descriptor() {
        return strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MethodHandle strlwr$handle() {
        return strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr$address() {
        return strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr(MemorySegment _String) {
        var mh$ = strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnicmp$descriptor() {
        return strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnicmp$handle() {
        return strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnicmp$address() {
        return strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnset$descriptor() {
        return strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnset$handle() {
        return strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset$address() {
        return strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset(MemorySegment _String, int _Value, long _MaxCount) {
        var mh$ = strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static FunctionDescriptor strrev$descriptor() {
        return strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MethodHandle strrev$handle() {
        return strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev$address() {
        return strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev(MemorySegment _String) {
        var mh$ = strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static FunctionDescriptor strset$descriptor() {
        return strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MethodHandle strset$handle() {
        return strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset$address() {
        return strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset(MemorySegment _String, int _Value) {
        var mh$ = strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static FunctionDescriptor strupr$descriptor() {
        return strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MethodHandle strupr$handle() {
        return strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr$address() {
        return strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr(MemorySegment _String) {
        var mh$ = strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = mux_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = mux_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = mux_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = mux_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = mux_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = mux_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = mux_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = mux_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = mux_h.C_LONG_LONG;

    private static class WebPMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *WebPMalloc(size_t size)
     * }
     */
    public static FunctionDescriptor WebPMalloc$descriptor() {
        return WebPMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *WebPMalloc(size_t size)
     * }
     */
    public static MethodHandle WebPMalloc$handle() {
        return WebPMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *WebPMalloc(size_t size)
     * }
     */
    public static MemorySegment WebPMalloc$address() {
        return WebPMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *WebPMalloc(size_t size)
     * }
     */
    public static MemorySegment WebPMalloc(long size) {
        var mh$ = WebPMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMalloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void WebPFree(void *ptr)
     * }
     */
    public static FunctionDescriptor WebPFree$descriptor() {
        return WebPFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void WebPFree(void *ptr)
     * }
     */
    public static MethodHandle WebPFree$handle() {
        return WebPFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void WebPFree(void *ptr)
     * }
     */
    public static MemorySegment WebPFree$address() {
        return WebPFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void WebPFree(void *ptr)
     * }
     */
    public static void WebPFree(MemorySegment ptr) {
        var mh$ = WebPFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPFree", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ANIMATION_FLAG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.ANIMATION_FLAG = 2
     * }
     */
    public static int ANIMATION_FLAG() {
        return ANIMATION_FLAG;
    }
    private static final int XMP_FLAG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.XMP_FLAG = 4
     * }
     */
    public static int XMP_FLAG() {
        return XMP_FLAG;
    }
    private static final int EXIF_FLAG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.EXIF_FLAG = 8
     * }
     */
    public static int EXIF_FLAG() {
        return EXIF_FLAG;
    }
    private static final int ALPHA_FLAG = (int)16L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.ALPHA_FLAG = 16
     * }
     */
    public static int ALPHA_FLAG() {
        return ALPHA_FLAG;
    }
    private static final int ICCP_FLAG = (int)32L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.ICCP_FLAG = 32
     * }
     */
    public static int ICCP_FLAG() {
        return ICCP_FLAG;
    }
    private static final int ALL_VALID_FLAGS = (int)62L;
    /**
     * {@snippet lang=c :
     * enum WebPFeatureFlags.ALL_VALID_FLAGS = 62
     * }
     */
    public static int ALL_VALID_FLAGS() {
        return ALL_VALID_FLAGS;
    }
    private static final int WEBP_MUX_DISPOSE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxAnimDispose.WEBP_MUX_DISPOSE_NONE = 0
     * }
     */
    public static int WEBP_MUX_DISPOSE_NONE() {
        return WEBP_MUX_DISPOSE_NONE;
    }
    private static final int WEBP_MUX_DISPOSE_BACKGROUND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxAnimDispose.WEBP_MUX_DISPOSE_BACKGROUND = 1
     * }
     */
    public static int WEBP_MUX_DISPOSE_BACKGROUND() {
        return WEBP_MUX_DISPOSE_BACKGROUND;
    }
    private static final int WEBP_MUX_BLEND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxAnimBlend.WEBP_MUX_BLEND = 0
     * }
     */
    public static int WEBP_MUX_BLEND() {
        return WEBP_MUX_BLEND;
    }
    private static final int WEBP_MUX_NO_BLEND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxAnimBlend.WEBP_MUX_NO_BLEND = 1
     * }
     */
    public static int WEBP_MUX_NO_BLEND() {
        return WEBP_MUX_NO_BLEND;
    }
    private static final int WEBP_MUX_OK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_OK = 1
     * }
     */
    public static int WEBP_MUX_OK() {
        return WEBP_MUX_OK;
    }
    private static final int WEBP_MUX_NOT_FOUND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_NOT_FOUND = 0
     * }
     */
    public static int WEBP_MUX_NOT_FOUND() {
        return WEBP_MUX_NOT_FOUND;
    }
    private static final int WEBP_MUX_INVALID_ARGUMENT = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_INVALID_ARGUMENT = -1
     * }
     */
    public static int WEBP_MUX_INVALID_ARGUMENT() {
        return WEBP_MUX_INVALID_ARGUMENT;
    }
    private static final int WEBP_MUX_BAD_DATA = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_BAD_DATA = -2
     * }
     */
    public static int WEBP_MUX_BAD_DATA() {
        return WEBP_MUX_BAD_DATA;
    }
    private static final int WEBP_MUX_MEMORY_ERROR = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_MEMORY_ERROR = -3
     * }
     */
    public static int WEBP_MUX_MEMORY_ERROR() {
        return WEBP_MUX_MEMORY_ERROR;
    }
    private static final int WEBP_MUX_NOT_ENOUGH_DATA = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum WebPMuxError.WEBP_MUX_NOT_ENOUGH_DATA = -4
     * }
     */
    public static int WEBP_MUX_NOT_ENOUGH_DATA() {
        return WEBP_MUX_NOT_ENOUGH_DATA;
    }
    private static final int WEBP_CHUNK_VP8X = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_VP8X = 0
     * }
     */
    public static int WEBP_CHUNK_VP8X() {
        return WEBP_CHUNK_VP8X;
    }
    private static final int WEBP_CHUNK_ICCP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_ICCP = 1
     * }
     */
    public static int WEBP_CHUNK_ICCP() {
        return WEBP_CHUNK_ICCP;
    }
    private static final int WEBP_CHUNK_ANIM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_ANIM = 2
     * }
     */
    public static int WEBP_CHUNK_ANIM() {
        return WEBP_CHUNK_ANIM;
    }
    private static final int WEBP_CHUNK_ANMF = (int)3L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_ANMF = 3
     * }
     */
    public static int WEBP_CHUNK_ANMF() {
        return WEBP_CHUNK_ANMF;
    }
    private static final int WEBP_CHUNK_DEPRECATED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_DEPRECATED = 4
     * }
     */
    public static int WEBP_CHUNK_DEPRECATED() {
        return WEBP_CHUNK_DEPRECATED;
    }
    private static final int WEBP_CHUNK_ALPHA = (int)5L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_ALPHA = 5
     * }
     */
    public static int WEBP_CHUNK_ALPHA() {
        return WEBP_CHUNK_ALPHA;
    }
    private static final int WEBP_CHUNK_IMAGE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_IMAGE = 6
     * }
     */
    public static int WEBP_CHUNK_IMAGE() {
        return WEBP_CHUNK_IMAGE;
    }
    private static final int WEBP_CHUNK_EXIF = (int)7L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_EXIF = 7
     * }
     */
    public static int WEBP_CHUNK_EXIF() {
        return WEBP_CHUNK_EXIF;
    }
    private static final int WEBP_CHUNK_XMP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_XMP = 8
     * }
     */
    public static int WEBP_CHUNK_XMP() {
        return WEBP_CHUNK_XMP;
    }
    private static final int WEBP_CHUNK_UNKNOWN = (int)9L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_UNKNOWN = 9
     * }
     */
    public static int WEBP_CHUNK_UNKNOWN() {
        return WEBP_CHUNK_UNKNOWN;
    }
    private static final int WEBP_CHUNK_NIL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum WebPChunkId.WEBP_CHUNK_NIL = 10
     * }
     */
    public static int WEBP_CHUNK_NIL() {
        return WEBP_CHUNK_NIL;
    }

    private static class WebPGetMuxVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT    );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPGetMuxVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int WebPGetMuxVersion()
     * }
     */
    public static FunctionDescriptor WebPGetMuxVersion$descriptor() {
        return WebPGetMuxVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int WebPGetMuxVersion()
     * }
     */
    public static MethodHandle WebPGetMuxVersion$handle() {
        return WebPGetMuxVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int WebPGetMuxVersion()
     * }
     */
    public static MemorySegment WebPGetMuxVersion$address() {
        return WebPGetMuxVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int WebPGetMuxVersion()
     * }
     */
    public static int WebPGetMuxVersion() {
        var mh$ = WebPGetMuxVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPGetMuxVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPNewInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPNewInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMux *WebPNewInternal(int)
     * }
     */
    public static FunctionDescriptor WebPNewInternal$descriptor() {
        return WebPNewInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMux *WebPNewInternal(int)
     * }
     */
    public static MethodHandle WebPNewInternal$handle() {
        return WebPNewInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMux *WebPNewInternal(int)
     * }
     */
    public static MemorySegment WebPNewInternal$address() {
        return WebPNewInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMux *WebPNewInternal(int)
     * }
     */
    public static MemorySegment WebPNewInternal(int x0) {
        var mh$ = WebPNewInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPNewInternal", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxDelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxDelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void WebPMuxDelete(WebPMux *mux)
     * }
     */
    public static FunctionDescriptor WebPMuxDelete$descriptor() {
        return WebPMuxDelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void WebPMuxDelete(WebPMux *mux)
     * }
     */
    public static MethodHandle WebPMuxDelete$handle() {
        return WebPMuxDelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void WebPMuxDelete(WebPMux *mux)
     * }
     */
    public static MemorySegment WebPMuxDelete$address() {
        return WebPMuxDelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void WebPMuxDelete(WebPMux *mux)
     * }
     */
    public static void WebPMuxDelete(MemorySegment mux) {
        var mh$ = WebPMuxDelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxDelete", mux);
            }
            mh$.invokeExact(mux);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxCreateInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxCreateInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMux *WebPMuxCreateInternal(const WebPData *, int, int)
     * }
     */
    public static FunctionDescriptor WebPMuxCreateInternal$descriptor() {
        return WebPMuxCreateInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMux *WebPMuxCreateInternal(const WebPData *, int, int)
     * }
     */
    public static MethodHandle WebPMuxCreateInternal$handle() {
        return WebPMuxCreateInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMux *WebPMuxCreateInternal(const WebPData *, int, int)
     * }
     */
    public static MemorySegment WebPMuxCreateInternal$address() {
        return WebPMuxCreateInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMux *WebPMuxCreateInternal(const WebPData *, int, int)
     * }
     */
    public static MemorySegment WebPMuxCreateInternal(MemorySegment x0, int x1, int x2) {
        var mh$ = WebPMuxCreateInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxCreateInternal", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxSetChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxSetChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetChunk(WebPMux *mux, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static FunctionDescriptor WebPMuxSetChunk$descriptor() {
        return WebPMuxSetChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetChunk(WebPMux *mux, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static MethodHandle WebPMuxSetChunk$handle() {
        return WebPMuxSetChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetChunk(WebPMux *mux, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static MemorySegment WebPMuxSetChunk$address() {
        return WebPMuxSetChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetChunk(WebPMux *mux, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static int WebPMuxSetChunk(MemorySegment mux, MemorySegment fourcc, MemorySegment chunk_data, int copy_data) {
        var mh$ = WebPMuxSetChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxSetChunk", mux, fourcc, chunk_data, copy_data);
            }
            return (int)mh$.invokeExact(mux, fourcc, chunk_data, copy_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxGetChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxGetChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetChunk(const WebPMux *mux, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static FunctionDescriptor WebPMuxGetChunk$descriptor() {
        return WebPMuxGetChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetChunk(const WebPMux *mux, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static MethodHandle WebPMuxGetChunk$handle() {
        return WebPMuxGetChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetChunk(const WebPMux *mux, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static MemorySegment WebPMuxGetChunk$address() {
        return WebPMuxGetChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetChunk(const WebPMux *mux, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static int WebPMuxGetChunk(MemorySegment mux, MemorySegment fourcc, MemorySegment chunk_data) {
        var mh$ = WebPMuxGetChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxGetChunk", mux, fourcc, chunk_data);
            }
            return (int)mh$.invokeExact(mux, fourcc, chunk_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxDeleteChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxDeleteChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteChunk(WebPMux *mux, const char fourcc[4])
     * }
     */
    public static FunctionDescriptor WebPMuxDeleteChunk$descriptor() {
        return WebPMuxDeleteChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteChunk(WebPMux *mux, const char fourcc[4])
     * }
     */
    public static MethodHandle WebPMuxDeleteChunk$handle() {
        return WebPMuxDeleteChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteChunk(WebPMux *mux, const char fourcc[4])
     * }
     */
    public static MemorySegment WebPMuxDeleteChunk$address() {
        return WebPMuxDeleteChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteChunk(WebPMux *mux, const char fourcc[4])
     * }
     */
    public static int WebPMuxDeleteChunk(MemorySegment mux, MemorySegment fourcc) {
        var mh$ = WebPMuxDeleteChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxDeleteChunk", mux, fourcc);
            }
            return (int)mh$.invokeExact(mux, fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxSetImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxSetImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetImage(WebPMux *mux, const WebPData *bitstream, int copy_data)
     * }
     */
    public static FunctionDescriptor WebPMuxSetImage$descriptor() {
        return WebPMuxSetImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetImage(WebPMux *mux, const WebPData *bitstream, int copy_data)
     * }
     */
    public static MethodHandle WebPMuxSetImage$handle() {
        return WebPMuxSetImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetImage(WebPMux *mux, const WebPData *bitstream, int copy_data)
     * }
     */
    public static MemorySegment WebPMuxSetImage$address() {
        return WebPMuxSetImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetImage(WebPMux *mux, const WebPData *bitstream, int copy_data)
     * }
     */
    public static int WebPMuxSetImage(MemorySegment mux, MemorySegment bitstream, int copy_data) {
        var mh$ = WebPMuxSetImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxSetImage", mux, bitstream, copy_data);
            }
            return (int)mh$.invokeExact(mux, bitstream, copy_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxPushFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxPushFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxPushFrame(WebPMux *mux, const WebPMuxFrameInfo *frame, int copy_data)
     * }
     */
    public static FunctionDescriptor WebPMuxPushFrame$descriptor() {
        return WebPMuxPushFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxPushFrame(WebPMux *mux, const WebPMuxFrameInfo *frame, int copy_data)
     * }
     */
    public static MethodHandle WebPMuxPushFrame$handle() {
        return WebPMuxPushFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxPushFrame(WebPMux *mux, const WebPMuxFrameInfo *frame, int copy_data)
     * }
     */
    public static MemorySegment WebPMuxPushFrame$address() {
        return WebPMuxPushFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxPushFrame(WebPMux *mux, const WebPMuxFrameInfo *frame, int copy_data)
     * }
     */
    public static int WebPMuxPushFrame(MemorySegment mux, MemorySegment frame, int copy_data) {
        var mh$ = WebPMuxPushFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxPushFrame", mux, frame, copy_data);
            }
            return (int)mh$.invokeExact(mux, frame, copy_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxGetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxGetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFrame(const WebPMux *mux, uint32_t nth, WebPMuxFrameInfo *frame)
     * }
     */
    public static FunctionDescriptor WebPMuxGetFrame$descriptor() {
        return WebPMuxGetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFrame(const WebPMux *mux, uint32_t nth, WebPMuxFrameInfo *frame)
     * }
     */
    public static MethodHandle WebPMuxGetFrame$handle() {
        return WebPMuxGetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFrame(const WebPMux *mux, uint32_t nth, WebPMuxFrameInfo *frame)
     * }
     */
    public static MemorySegment WebPMuxGetFrame$address() {
        return WebPMuxGetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFrame(const WebPMux *mux, uint32_t nth, WebPMuxFrameInfo *frame)
     * }
     */
    public static int WebPMuxGetFrame(MemorySegment mux, int nth, MemorySegment frame) {
        var mh$ = WebPMuxGetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxGetFrame", mux, nth, frame);
            }
            return (int)mh$.invokeExact(mux, nth, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxDeleteFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxDeleteFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteFrame(WebPMux *mux, uint32_t nth)
     * }
     */
    public static FunctionDescriptor WebPMuxDeleteFrame$descriptor() {
        return WebPMuxDeleteFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteFrame(WebPMux *mux, uint32_t nth)
     * }
     */
    public static MethodHandle WebPMuxDeleteFrame$handle() {
        return WebPMuxDeleteFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteFrame(WebPMux *mux, uint32_t nth)
     * }
     */
    public static MemorySegment WebPMuxDeleteFrame$address() {
        return WebPMuxDeleteFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxDeleteFrame(WebPMux *mux, uint32_t nth)
     * }
     */
    public static int WebPMuxDeleteFrame(MemorySegment mux, int nth) {
        var mh$ = WebPMuxDeleteFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxDeleteFrame", mux, nth);
            }
            return (int)mh$.invokeExact(mux, nth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxSetAnimationParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxSetAnimationParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetAnimationParams(WebPMux *mux, const WebPMuxAnimParams *params)
     * }
     */
    public static FunctionDescriptor WebPMuxSetAnimationParams$descriptor() {
        return WebPMuxSetAnimationParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetAnimationParams(WebPMux *mux, const WebPMuxAnimParams *params)
     * }
     */
    public static MethodHandle WebPMuxSetAnimationParams$handle() {
        return WebPMuxSetAnimationParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetAnimationParams(WebPMux *mux, const WebPMuxAnimParams *params)
     * }
     */
    public static MemorySegment WebPMuxSetAnimationParams$address() {
        return WebPMuxSetAnimationParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetAnimationParams(WebPMux *mux, const WebPMuxAnimParams *params)
     * }
     */
    public static int WebPMuxSetAnimationParams(MemorySegment mux, MemorySegment params) {
        var mh$ = WebPMuxSetAnimationParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxSetAnimationParams", mux, params);
            }
            return (int)mh$.invokeExact(mux, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxGetAnimationParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxGetAnimationParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetAnimationParams(const WebPMux *mux, WebPMuxAnimParams *params)
     * }
     */
    public static FunctionDescriptor WebPMuxGetAnimationParams$descriptor() {
        return WebPMuxGetAnimationParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetAnimationParams(const WebPMux *mux, WebPMuxAnimParams *params)
     * }
     */
    public static MethodHandle WebPMuxGetAnimationParams$handle() {
        return WebPMuxGetAnimationParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetAnimationParams(const WebPMux *mux, WebPMuxAnimParams *params)
     * }
     */
    public static MemorySegment WebPMuxGetAnimationParams$address() {
        return WebPMuxGetAnimationParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetAnimationParams(const WebPMux *mux, WebPMuxAnimParams *params)
     * }
     */
    public static int WebPMuxGetAnimationParams(MemorySegment mux, MemorySegment params) {
        var mh$ = WebPMuxGetAnimationParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxGetAnimationParams", mux, params);
            }
            return (int)mh$.invokeExact(mux, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxSetCanvasSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxSetCanvasSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetCanvasSize(WebPMux *mux, int width, int height)
     * }
     */
    public static FunctionDescriptor WebPMuxSetCanvasSize$descriptor() {
        return WebPMuxSetCanvasSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetCanvasSize(WebPMux *mux, int width, int height)
     * }
     */
    public static MethodHandle WebPMuxSetCanvasSize$handle() {
        return WebPMuxSetCanvasSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetCanvasSize(WebPMux *mux, int width, int height)
     * }
     */
    public static MemorySegment WebPMuxSetCanvasSize$address() {
        return WebPMuxSetCanvasSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxSetCanvasSize(WebPMux *mux, int width, int height)
     * }
     */
    public static int WebPMuxSetCanvasSize(MemorySegment mux, int width, int height) {
        var mh$ = WebPMuxSetCanvasSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxSetCanvasSize", mux, width, height);
            }
            return (int)mh$.invokeExact(mux, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxGetCanvasSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxGetCanvasSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetCanvasSize(const WebPMux *mux, int *width, int *height)
     * }
     */
    public static FunctionDescriptor WebPMuxGetCanvasSize$descriptor() {
        return WebPMuxGetCanvasSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetCanvasSize(const WebPMux *mux, int *width, int *height)
     * }
     */
    public static MethodHandle WebPMuxGetCanvasSize$handle() {
        return WebPMuxGetCanvasSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetCanvasSize(const WebPMux *mux, int *width, int *height)
     * }
     */
    public static MemorySegment WebPMuxGetCanvasSize$address() {
        return WebPMuxGetCanvasSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetCanvasSize(const WebPMux *mux, int *width, int *height)
     * }
     */
    public static int WebPMuxGetCanvasSize(MemorySegment mux, MemorySegment width, MemorySegment height) {
        var mh$ = WebPMuxGetCanvasSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxGetCanvasSize", mux, width, height);
            }
            return (int)mh$.invokeExact(mux, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxGetFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxGetFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFeatures(const WebPMux *mux, uint32_t *flags)
     * }
     */
    public static FunctionDescriptor WebPMuxGetFeatures$descriptor() {
        return WebPMuxGetFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFeatures(const WebPMux *mux, uint32_t *flags)
     * }
     */
    public static MethodHandle WebPMuxGetFeatures$handle() {
        return WebPMuxGetFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFeatures(const WebPMux *mux, uint32_t *flags)
     * }
     */
    public static MemorySegment WebPMuxGetFeatures$address() {
        return WebPMuxGetFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxGetFeatures(const WebPMux *mux, uint32_t *flags)
     * }
     */
    public static int WebPMuxGetFeatures(MemorySegment mux, MemorySegment flags) {
        var mh$ = WebPMuxGetFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxGetFeatures", mux, flags);
            }
            return (int)mh$.invokeExact(mux, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxNumChunks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxNumChunks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxNumChunks(const WebPMux *mux, WebPChunkId id, int *num_elements)
     * }
     */
    public static FunctionDescriptor WebPMuxNumChunks$descriptor() {
        return WebPMuxNumChunks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxNumChunks(const WebPMux *mux, WebPChunkId id, int *num_elements)
     * }
     */
    public static MethodHandle WebPMuxNumChunks$handle() {
        return WebPMuxNumChunks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxNumChunks(const WebPMux *mux, WebPChunkId id, int *num_elements)
     * }
     */
    public static MemorySegment WebPMuxNumChunks$address() {
        return WebPMuxNumChunks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxNumChunks(const WebPMux *mux, WebPChunkId id, int *num_elements)
     * }
     */
    public static int WebPMuxNumChunks(MemorySegment mux, int id, MemorySegment num_elements) {
        var mh$ = WebPMuxNumChunks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxNumChunks", mux, id, num_elements);
            }
            return (int)mh$.invokeExact(mux, id, num_elements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPMuxAssemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPMuxAssemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxAssemble(WebPMux *mux, WebPData *assembled_data)
     * }
     */
    public static FunctionDescriptor WebPMuxAssemble$descriptor() {
        return WebPMuxAssemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxAssemble(WebPMux *mux, WebPData *assembled_data)
     * }
     */
    public static MethodHandle WebPMuxAssemble$handle() {
        return WebPMuxAssemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxAssemble(WebPMux *mux, WebPData *assembled_data)
     * }
     */
    public static MemorySegment WebPMuxAssemble$address() {
        return WebPMuxAssemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPMuxAssemble(WebPMux *mux, WebPData *assembled_data)
     * }
     */
    public static int WebPMuxAssemble(MemorySegment mux, MemorySegment assembled_data) {
        var mh$ = WebPMuxAssemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPMuxAssemble", mux, assembled_data);
            }
            return (int)mh$.invokeExact(mux, assembled_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderOptionsInitInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderOptionsInitInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions *, int)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderOptionsInitInternal$descriptor() {
        return WebPAnimEncoderOptionsInitInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions *, int)
     * }
     */
    public static MethodHandle WebPAnimEncoderOptionsInitInternal$handle() {
        return WebPAnimEncoderOptionsInitInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions *, int)
     * }
     */
    public static MemorySegment WebPAnimEncoderOptionsInitInternal$address() {
        return WebPAnimEncoderOptionsInitInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions *, int)
     * }
     */
    public static int WebPAnimEncoderOptionsInitInternal(MemorySegment x0, int x1) {
        var mh$ = WebPAnimEncoderOptionsInitInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderOptionsInitInternal", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderNewInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderNewInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPAnimEncoder *WebPAnimEncoderNewInternal(int, int, const WebPAnimEncoderOptions *, int)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderNewInternal$descriptor() {
        return WebPAnimEncoderNewInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPAnimEncoder *WebPAnimEncoderNewInternal(int, int, const WebPAnimEncoderOptions *, int)
     * }
     */
    public static MethodHandle WebPAnimEncoderNewInternal$handle() {
        return WebPAnimEncoderNewInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPAnimEncoder *WebPAnimEncoderNewInternal(int, int, const WebPAnimEncoderOptions *, int)
     * }
     */
    public static MemorySegment WebPAnimEncoderNewInternal$address() {
        return WebPAnimEncoderNewInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPAnimEncoder *WebPAnimEncoderNewInternal(int, int, const WebPAnimEncoderOptions *, int)
     * }
     */
    public static MemorySegment WebPAnimEncoderNewInternal(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = WebPAnimEncoderNewInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderNewInternal", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAdd(WebPAnimEncoder *enc, struct WebPPicture *frame, int timestamp_ms, const struct WebPConfig *config)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderAdd$descriptor() {
        return WebPAnimEncoderAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAdd(WebPAnimEncoder *enc, struct WebPPicture *frame, int timestamp_ms, const struct WebPConfig *config)
     * }
     */
    public static MethodHandle WebPAnimEncoderAdd$handle() {
        return WebPAnimEncoderAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAdd(WebPAnimEncoder *enc, struct WebPPicture *frame, int timestamp_ms, const struct WebPConfig *config)
     * }
     */
    public static MemorySegment WebPAnimEncoderAdd$address() {
        return WebPAnimEncoderAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAdd(WebPAnimEncoder *enc, struct WebPPicture *frame, int timestamp_ms, const struct WebPConfig *config)
     * }
     */
    public static int WebPAnimEncoderAdd(MemorySegment enc, MemorySegment frame, int timestamp_ms, MemorySegment config) {
        var mh$ = WebPAnimEncoderAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderAdd", enc, frame, timestamp_ms, config);
            }
            return (int)mh$.invokeExact(enc, frame, timestamp_ms, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderAssemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderAssemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAssemble(WebPAnimEncoder *enc, WebPData *webp_data)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderAssemble$descriptor() {
        return WebPAnimEncoderAssemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAssemble(WebPAnimEncoder *enc, WebPData *webp_data)
     * }
     */
    public static MethodHandle WebPAnimEncoderAssemble$handle() {
        return WebPAnimEncoderAssemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAssemble(WebPAnimEncoder *enc, WebPData *webp_data)
     * }
     */
    public static MemorySegment WebPAnimEncoderAssemble$address() {
        return WebPAnimEncoderAssemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int WebPAnimEncoderAssemble(WebPAnimEncoder *enc, WebPData *webp_data)
     * }
     */
    public static int WebPAnimEncoderAssemble(MemorySegment enc, MemorySegment webp_data) {
        var mh$ = WebPAnimEncoderAssemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderAssemble", enc, webp_data);
            }
            return (int)mh$.invokeExact(enc, webp_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *WebPAnimEncoderGetError(WebPAnimEncoder *enc)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderGetError$descriptor() {
        return WebPAnimEncoderGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *WebPAnimEncoderGetError(WebPAnimEncoder *enc)
     * }
     */
    public static MethodHandle WebPAnimEncoderGetError$handle() {
        return WebPAnimEncoderGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *WebPAnimEncoderGetError(WebPAnimEncoder *enc)
     * }
     */
    public static MemorySegment WebPAnimEncoderGetError$address() {
        return WebPAnimEncoderGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *WebPAnimEncoderGetError(WebPAnimEncoder *enc)
     * }
     */
    public static MemorySegment WebPAnimEncoderGetError(MemorySegment enc) {
        var mh$ = WebPAnimEncoderGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderGetError", enc);
            }
            return (MemorySegment)mh$.invokeExact(enc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderDelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderDelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void WebPAnimEncoderDelete(WebPAnimEncoder *enc)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderDelete$descriptor() {
        return WebPAnimEncoderDelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void WebPAnimEncoderDelete(WebPAnimEncoder *enc)
     * }
     */
    public static MethodHandle WebPAnimEncoderDelete$handle() {
        return WebPAnimEncoderDelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void WebPAnimEncoderDelete(WebPAnimEncoder *enc)
     * }
     */
    public static MemorySegment WebPAnimEncoderDelete$address() {
        return WebPAnimEncoderDelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void WebPAnimEncoderDelete(WebPAnimEncoder *enc)
     * }
     */
    public static void WebPAnimEncoderDelete(MemorySegment enc) {
        var mh$ = WebPAnimEncoderDelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderDelete", enc);
            }
            mh$.invokeExact(enc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderSetChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_INT
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderSetChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderSetChunk(WebPAnimEncoder *enc, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderSetChunk$descriptor() {
        return WebPAnimEncoderSetChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderSetChunk(WebPAnimEncoder *enc, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static MethodHandle WebPAnimEncoderSetChunk$handle() {
        return WebPAnimEncoderSetChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderSetChunk(WebPAnimEncoder *enc, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static MemorySegment WebPAnimEncoderSetChunk$address() {
        return WebPAnimEncoderSetChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderSetChunk(WebPAnimEncoder *enc, const char fourcc[4], const WebPData *chunk_data, int copy_data)
     * }
     */
    public static int WebPAnimEncoderSetChunk(MemorySegment enc, MemorySegment fourcc, MemorySegment chunk_data, int copy_data) {
        var mh$ = WebPAnimEncoderSetChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderSetChunk", enc, fourcc, chunk_data, copy_data);
            }
            return (int)mh$.invokeExact(enc, fourcc, chunk_data, copy_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderGetChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderGetChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderGetChunk(const WebPAnimEncoder *enc, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderGetChunk$descriptor() {
        return WebPAnimEncoderGetChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderGetChunk(const WebPAnimEncoder *enc, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static MethodHandle WebPAnimEncoderGetChunk$handle() {
        return WebPAnimEncoderGetChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderGetChunk(const WebPAnimEncoder *enc, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static MemorySegment WebPAnimEncoderGetChunk$address() {
        return WebPAnimEncoderGetChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderGetChunk(const WebPAnimEncoder *enc, const char fourcc[4], WebPData *chunk_data)
     * }
     */
    public static int WebPAnimEncoderGetChunk(MemorySegment enc, MemorySegment fourcc, MemorySegment chunk_data) {
        var mh$ = WebPAnimEncoderGetChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderGetChunk", enc, fourcc, chunk_data);
            }
            return (int)mh$.invokeExact(enc, fourcc, chunk_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WebPAnimEncoderDeleteChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            mux_h.C_INT,
            mux_h.C_POINTER,
            mux_h.C_POINTER
        );

        public static final MemorySegment ADDR = mux_h.findOrThrow("WebPAnimEncoderDeleteChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderDeleteChunk(WebPAnimEncoder *enc, const char fourcc[4])
     * }
     */
    public static FunctionDescriptor WebPAnimEncoderDeleteChunk$descriptor() {
        return WebPAnimEncoderDeleteChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderDeleteChunk(WebPAnimEncoder *enc, const char fourcc[4])
     * }
     */
    public static MethodHandle WebPAnimEncoderDeleteChunk$handle() {
        return WebPAnimEncoderDeleteChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderDeleteChunk(WebPAnimEncoder *enc, const char fourcc[4])
     * }
     */
    public static MemorySegment WebPAnimEncoderDeleteChunk$address() {
        return WebPAnimEncoderDeleteChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern WebPMuxError WebPAnimEncoderDeleteChunk(WebPAnimEncoder *enc, const char fourcc[4])
     * }
     */
    public static int WebPAnimEncoderDeleteChunk(MemorySegment enc, MemorySegment fourcc) {
        var mh$ = WebPAnimEncoderDeleteChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WebPAnimEncoderDeleteChunk", enc, fourcc);
            }
            return (int)mh$.invokeExact(enc, fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = mux_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final int EDEADLOCK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 36
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int _NLSCMPERROR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _NLSCMPERROR 2147483647
     * }
     */
    public static int _NLSCMPERROR() {
        return _NLSCMPERROR;
    }
}

